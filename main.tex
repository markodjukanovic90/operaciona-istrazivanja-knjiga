\documentclass[a4paper, utf8, 11pt, colorlinks]{book} 
\bibliography{localbibliography}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage[serbian]{babel}
 
\usepackage[OT2,T1]{fontenc}
\usepackage[latin1,utf8]{inputenc}
\usepackage{amssymb}
\newtheorem{definition}{Definicija}
\newtheorem{thm}{Teorema}
\newtheorem{lm}{Lema}
\newtheorem{prop}{Propozicija}
\newtheorem{poslje}{Posljedica}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{dot2texi}
\usepackage{subcaption}
%\usetikzlibrary{arrows,shapes}
%\usepackage{epstopdf}
\newenvironment{proof}{{Dokaz:}}{\hfill$\square$}

% redefinicija nekih konstanti: 
\renewcommand{\figurename}{Slika}
\renewcommand{\tablename}{Tabela}
\usepackage{url}

\usepackage{fixme}

\usepackage{tikz}
\usetikzlibrary{intersections,calc}
\usepackage{pgfplots}   

 

	
\pgfplotsset{compat=newest}
\pgfplotsset{plot coordinates/math parser=false}
\pgfplotsset{
    every non boxed x axis/.style={
        xtick align=center,
        enlarge x limits=true,
        x axis line style={line width=0.8pt, -latex}
},
    every boxed x axis/.style={}, enlargelimits=false
}
\pgfplotsset{
    every non boxed y axis/.style={
        ytick align=center,
        enlarge y limits=true,
        y axis line style={line width=0.8pt, -latex}
},
    every boxed y axis/.style={}, enlargelimits=false
}
\usetikzlibrary{
   arrows.meta,
  intersections,
}


\usetikzlibrary{positioning,shapes.multipart}


\def\textA{$L_0$:\\
	$(x*, y^*)=(2.25, 3.75)$ \\
	$z = 41.25$ \\
	 $z^* \leq 41$
	\vdots
}

\def\textB{$\text{min}\  x_1-2x_2$\\
	subject to\\
	\hspace{1cm}\vdots
	\nodepart{two}
	{\scriptsize $x_1^*=1,x_2^*=2.1667$}
}

\def\textC{$L_1$:\\
	 $x^*=(1.8,  4)$\\
	 $z=41$ \\
	$LB=41$ 
}

\def\textD{$L_2$\\
	$x^*=(3, 3)$ \\
	$z^* = 39 < LB$
}

\def\textE{$L_3$:\\
	potproblem nedopustiv
 }

\def\textF{ $L_4$:\\
    $x^*=(1, 4\frac{4}{9})$ \\
    $z^*=40\frac{5}{9}$ 
}

\def\textG{$L_5$: \\
	$x^*=(1, 4)$ \\
	$z^*=37<LB$
}

\def\textH{$L_6$: \\
	$x^*=(0, 5)$ \\
	$z^*=40<LB$
}

\tikzset{>=stealth,parent node/.style={rectangle split, rectangle split parts=2,align=left,text width=2.5cm,draw,node distance=1cm and 1cm}}
  

\usetikzlibrary{positioning}
\newdimen\nodeDist
\nodeDist=25mm
% \ChapterDOI{} %will be filled in at production
\author{
 Marko Đukanović  \& Dragan Matić
% Noam Chimpsky\affiliation{University of Pluto}\lastand 
% Jane Wilson\affiliation{National Institute for Language}
}
%\university{Univerzitet u Banjoj Luci}
%\department{Prirodno-matematički fakultet}
\title{Uvod u Operaciona Istraživanja}

\begin{document}
\maketitle
\newpage
\tableofcontents

\newpage

\chapter{Predmet izučavanja Operacionih istraživanja}

Operaciona istraživanja su oblast koja pripada matematičkim disciplinama. Ona predstavlja osnovnu disciplinu u menadžmentu, a naziv joj potiče iz njene osnovne uloge, a to je istraživanje  operacija u organizacionim sistemima (logistika, problem raspoređivanja, itd.) gdje je svrha optimizacija (troškova, vremena, $\ldots$). Operaciona istraživanja u osnovi predstavljaju analitički metod rješavanja problema i donošenja odluka koje se primjenjuju u organizaciji raznih sistema. Metodologija ovih istraživanja  najčešće obuhvata razbijanje problema na bazne komponente a potom njihovo rješavanje u definisanim koracima uz pomoć matematičkog aparata. 

Koncept operacionih istraživanja potiče iz Drugog svjetskog rata gdje su vojni planeri razvijali strategiju postavljanja vojske i vojne opreme sa ciljem što veće mobilnosti i efikasnosti. Poslije rata, ove tehnike su primjenjivane u rješavanju mnogih problema u biznisu, socijalnim problemima, i mnogim drugim. 

Proces u operacionom istraživanju se ugrubo može predstaviti sljedećim koracima:
\begin{itemize}
    \item Opisati problem koji rješavamo.
    \item Konstrukcija modela problema koji opisuje taj problem preko varijabli i relacija između njih. 
    \item Korištenje modela za generisanje rješenja problema.
    \item Testiranje svakog od rješenja i analiziranje njihovih  kvaliteta.
    \item Implementacija odabranog rješenja za dati problem. 
\end{itemize}
O njima će više biti riječi u narednoj sekciji.
 
Glavne karakteristike operacionih istraživanja su
\begin{itemize}
    \item \emph{Optimizacija:} %Uloga operacionih istraživanja je dohvatiti najbolje performanse pod unaprijed zadanim resursima (limit u vremenu, memoriji, itd.). 
     uključuje poređenja i navođenje pretrage prema potencijalno boljim opcijama.
    \item \emph{Simulacija}:  podrazumijeva izgradnju modela problema iz koga se dobijaju rješenja koja se potom provjeravaju prije nego se implementiraju u realnoj situaciji.
    \item \emph{Vjerovatnoća i statistika}:  podrazumijeva ($i$) upotreba matematičkih algoritama i podataka u smislu otkrivanja korisnih informacija koje služe u davanju pouzdanih predviđanja u realnom svijetu; ($ii$) testiranja dobrote rješenja.
\end{itemize}
 
 Operaciona istraživanja imaju nezamjenjivu ulogu u nizu obasti kao što su problemi raspoređivanja, urbanog planiranja, optimizacije na mrežama i inženjeringu, rutiranja paketa, upravljanja rizicima, upravljanja lancem snabdjevanja i mnogim drugim. 

 Što se tiče   šire slike pojma Operaciona istraživanja, taj pojam nije trivijalno opisati. U osnovi, Operacona istraživanja su nauka o tome kako donijeti niz efikasnih odluka za skup operacija koji se izvodi. Matematičko programiranje je jedna od najmoćnijih tehnika 
 korištena u Operacionim istrraživanjima do te mjere da  se   ova dva termina ponekad čak poistovjećuju. Treba imati na umu da riječ ``programiranje'' nema standardno značenje na koje smo i navikli, već ono označava optimizaciju. Operaciona istraživanja rješavaju probleme iz prakse (nazovimo ih biznis problemi) koje ljudima štede novac i vrijeme. Ovi problemi mogu biti raznoliki i po pravilu izgledaju bez povezanosti jedan sa drugim. Gledajući šire, osnovica im je uvijek ista, donošenje niza odluka da bi se došlo do cilja na što efikasniji način.  %Diskretna optimizacija 

  Put od učenja o problemu kojeg klijent izlaže do pronalaska rješenja može biti jako izazovan. Ovaj proces rješavanja se može podijeliti u četiri osnovna nivoa apstrakcije:
  \begin{enumerate}
      \item Biznis problemi;
      \item Generički problemi; 
      \item Paradigma modelovanja;
      \item Algoritamska rješenja. 
  \end{enumerate}
  
 Pod \emph{biznis problemima} ne podrazumijevaju se  samo problemi iz domena ekonomije. Tu su svi problemi koji imaju primjenu u stvarnom svijetu. Pojam ``biznis'' više odgovara tome da problem nema svoju preciznu matematičku formulaciju, nego je manje formalno definisan, kroz jezički (deskriptivan) opis.  Najčešće, ovi problemi proizilaze iz problem u industriji i kao takvi se i opisuju. Primjer takvog problema je u problemu raspoređivanja medicinskog osoblja u (tri) smjene sa uslovima poput toga da svaki radnik mora da odradi 40 sati sedmično ili da niti jedan radnik ne smije da radi više od dvije noćne smjene u toku sedmice. Sljedeći korak 
 je formalno definisanje problema, dakle, spuštanje (opisa) problema na niži nivo apstrakcije. U praksi, ovo ide iterativno. Ovaj proces se povezuje sa terminom \emph{Generički problemi}. 

Pri konceptualizaciji Operacionih istraživanja na početku nije bilo jakog matematičkog formalizma. Matematičari su prepoznali da se većina biznis problema može  mapirati u generičke familije problema nižeg nivoa. Ovom mapiranju je posvećeno dosta vremena, da bi se na kraju završilo sa nekoliko standardnih generičkih klasa na koje se mapira gotovo svaki problem iz operacionih istraživanja. U praksi, najveći dio vremena se provodi u konvertovanju biznis problema u jedan od poznatih generičkih problema. Nakon toga, rješavanje problema je manje-više standardna procedura. Generički problemi operacionih istraživanja su dovoljno koncizni da se mogu pretstaviti preko matematičke notacije. Međutim, u svrhu boljeg razumijevanja u praksi se koriste jezici modelovanja koji su na višem nivou apstrakcije od njih; tako npr. problemi raspoređivanja se obično opisuju preko resursa, aktivnosti i uslova raspoređivanja (prioriteta). 

\emph{Paradigma modelovanja}. Kod generičkih operacinih problema koji su definisani jezikom višeg nivoa, notacija je najčešće vezana uz problem koji se razmatra.
Kao primjer, resursi i aktivnosti nisu nešto što se može definisati u, recimo, problemu trgovačkog putnika. U osnovi, svaki od ovih generičkih problema se mogu opisati nekom od paradigmi modelovanja. Paradigma modelovanja predstavlja skup pravila koja omogućuju da predstavimo probleme višeg nivoa koristeći strukture nižeg nivoa, kao što su, recimo, matrice. Kada se primjenjuje ova paradigma, problem se izražava koristeći matematičku notaciju ili algebarski jezik modelovanja (eng. \emph{Algebraic Modelling Language} (AML)) koji konvertuje matematičku notaciju u matrice koje su prosljeđene sljedećem nivou (\emph{algoritamska rješenja}) koja generišu rješenja. Najpoznatije paradigme modelovanja su sljedeće: Linearno, Cjelobrojno i Mješovito-cjelobrojno programiranje. Postoje još neke paradigme poput Modelovanje ograničenjima (eng. \emph{Constraint Programming}) i mrežno modelovanje (eng. \emph{Network models}). 

\emph{Algoritamska rješenja}. Algoritam je procedura ili konačan niz instrukcija čijim izvršavanjem možemo riješiti problem. Neki algoritmi su opšti, kao što su sortiranje ili pretrage i primjenjivi su u raznim poljima kompjuterskih nauka, dok su drugi vezani uz specifične probleme. Algoritmi pretrage su izuzetno važni u rješavanju problema operacionih istraživanja. Među njima se izdvajaju ``Branch \& X''-tip algoritama koji rješavaju Cjelobrojna, Mješovito-cjelobrojne probleme kao i probleme zasnovane na modelovanju ograničenjima. Specifično, među ove algoritme spadaju Branch \& Bound (za rješavanje problema cjelobrojnog programiranja), Branch \& Cut, Branch \& Price (tj. metod generisanja kolona), itd.

Među programskim paradigmama koje su značajne u operacionim istraživanjima takođe izdvajamo i dinamičko programiranje. Ova familija algoritama rješava probleme tako što eksploatiše optimalnu pod-strukturu problema. U prevodu, ako problem može da bude riješen koristeći identične zadatke, riješimo jedan od zadataka i smjestimo rješenje u tabelu (memorišemo). Kada u sljedećem momentu   rješavanja problema naiđemo na isti potproblem, jednostavno ga ne rješavamo ponovo, već rješenje pročitamo iz tabele. Ova programska paradigma ima značajnu ulogu u rješavanju grafovskih problema. Jedan od najpoznatijih takvih algoritama je \emph{Bellman-Ford}-ov algoritam, nazvan po izumitelju ove paradigme, Ričardu Belmanu. 
U praksi problemi mogu biti prilično teški za egzaktno rješavanje, a potrebno je naći brzo rješenje. Za to nam služe pohlepni algoritmi. Oni obično ne mogu 
garantovati optimalnost pri svom prekidu, ali su oni po svojoj prirodi jako brzi. Najpoznatiji takav algoritam je \emph{Dajkstrin} algoritam za problem pronalaska najkraćeg puta koji pri nekim karakteristikama grafa čak nalazi optimalno rješenje. 

\begin{figure}
    \centering
    \includegraphics[width=300, height=230pt]{overview.eps}
    \caption{Četiri nivoa apstrakcije pri rješavanu problema operacionih istraživanja.}
    \label{fig:OR_four_levels}
\end{figure}
%https://towardsdatascience.com/the-big-picture-of-operations-research-8652d5153aad


U nastavku knjige ćemo objasniti u detalje svaki od nivoa apstrakcije u operacionim istraživanjima kao i svaku od paradigmi modelovanja i najznačajnije algoritame za rješavanje. Odnos između sva četiri nivoa apstrakcije su data na Slici~\ref{fig:OR_four_levels}. 
 Na kraju knjige će biti riječi o generalnom rješavaču koji je alatka za rješavanje problema u operacionim istraživanjima. 
 \\
 \newpage
 
 
\chapter{Principi Modelovanja u Operacionim Istraživanjima}
Uobičajeno je izraz Operaciona istraživanja zapisivati skraćenom akronimom OR (eng. \emph{operational research}). 
U ovoj glavi ćemo objasniti   glavne faze tipičnog OR istraživanja koje se realizuje u  komercijalne svrhe. Faze OR možemo sumirati u sljedeće (preklapajuće) faze: 
\begin{itemize}
    \item Definisanje problema i sakupljanje relevantnih podataka.
    \item Formulisanje matematičkog modela datog problema.
    \item Razvoj računarske procedure koja će pronaći rješenja datog problema na osnovu modela.
    \item Testiranje modela i, po potrebi, rad na njegovom poboljšanju.
    \item Pripremu za primjenu modela, kako je definisano od strane uprave koja naručuje/finansira sistem.
    \item Implementaciju i upotrebu rješenja.
\end{itemize}
 U nastavku ćemo opisati svaku od ovih faza.
 
 \section{Definisanje problema i sakupljanje relevantnih podataka}
 
Većina praktičnih problema sa kojima se susreću OR timovi su u početku opisani na neprecizan način. Stoga, prvi zadatak podrazumijeva dobro definisanje  cilja/namjene  (engl. objectives) samog zadatka koji treba riješiti, uslova pod kojim je rješenje problema validno,  vremenska ograničenja za donošenje odluka, moguće alternativne scenarije itd.  Definisanje problema na dovoljno dobar način je krucijalan, jer uveliko utiče na relevantnost zaključaka istraživanja. Izvlačenje odgovora ili dobijanje rezultata iz pogrešne postavke polaznog problema sigurno neće dovesti do ispravnog rješenja.  

Zbog toga je važno da OR tim unajmljen za modelovanje problema ne radi samostalno, već funkcioniše na principu savjetovanja. Članovi tima koji su zaduženi za formulisanje problema savjetuju se sa upravom firme za koju se razvija sistem, poslije koga tim izvodi detaljne tehničke analize u vezi problema i prezentuje preporuke za rješenje  osobi u upravi koja je ključna u donošenju odluka.   


Najčešće, izvještaj za upavu će sadržavati osnovno rješenje, ali i brojne alternative koje u osnovi odgovaraju različitim uslovima ili različitim  vrijednostima parametara koje su zatražene od strane uprave (kao na primjer, vaganje između cijene i dobiti). Uprava zatim vrednuje istraživanje i prijedloge, uzimajući u obzir  niz faktora, te donosi odluku zasnovanu na najboljoj procjeni. Važno je i da OR tim bude približno sličnog mišljenja kao i uprava. Utvrđivanje odgovarajućih ciljeva je  neophodno za ispravno definisanje problema.  Za to je potrebno imati osobu iz uprave koja je donosilac odluka u vezi sistema koji se razvija, pa potom pristupiti inidividualnoj realizaciji svakog od ciljeva.

OR istraživanje po ``defaultu'' traži ona rješenja koja su optimalna prije nego suboptimalna -- optimalna samo za određenu komponentu procesa za koji se sistem razvija. Prema tome, ciljevi koji su formulisani bi trebali biti oni koji traže optimalna rješenja čitavog procesa koji se optimizuje.  Obično to nije trivijalno, pa se problem svodi na razmatranje dijela inicijalnog (opisanog) problema (ili njegove pojednostavljene varijante), jer bi analiza postala glomazna ako bi zadani ciljevi bili previše uopšteni. Umjesto toga, ciljevi bi trebalo biti specifični 
koliko god je to moguće, ali da pri tome obuhvate glavne ciljeve donosioca odluka, zadržavajući razuman stepen konzistentnosti sa osnovim ciljevima čitave organizacije. 

Kada su u pitanju profitne organizacije, jedan od mogućih pristupa zaobilaženja problema pod-optimizacije je koristiti dugoročnu maksimizaciju profita. Riječ dugoročno ukazuje da ovaj cilj pruža fleksibilnost u razmatranju aktivnosti koje ne donose dobit momentalno, ali se moraju uključiti na kraju kako bi omogućili profit. Ovakav cilj je   dovoljno specifičan, a ipak i dovoljno širok da obuhvati osnovni cilj profitnih organizacija, odnosno zaradu. Zapravo, svi drugi legitimni ciljevi ovakvih organizacija mogu se prevesti u prethodno pomenuti. U praksi, profitne organizacije rijetko koriste ovaj pristup. Velik broj profitnih organizacija prilagođava zadovoljavajući profit sa drugim ciljevima, umjesto fokusiranja na maksimizovanje dugoročne zarade. Neki od tih ciljeva su: izgradnja stabilnog profita, proširivanje tržišta, zadržavanje stabilnosti cijena, povećanje uticaja kompanije, povećanje ponude proizvoda, itd. 
Dalje, postoje dodatna razmatranja poput društvenih odgovornosti koje nisu direktno motivisane profitom.  

Postoji nekoliko strana kojih se direktno tiču poslovi firme: (1) vlasnici (dioničari, itd.), koji žele profit;   (2) zaposlenici koji žele stalno zaposlenje, stabilan posao, te razumne plate; (3) kupci koji žele proizvod zadovoljavajućeg kvaliteta po razumnoj cijeni;
(4) dobavljači, koji žele integritet i razumnu prodajnu cijenu proizvoda; i
(5) vlada, koja želi plaćanje poreza te razmjenu dobara. Svih pet strana utiču na doprinos firme. Stoga, dok je glavna odgovornost uprave profit (što u konačnici koristi svim stranama), napomenimo da se treba sagledati i širi društveni uticaj ovakvog procesa. 
 
 Timovi zaduženi za modelovanje obično provode veliku količinu vremena prikupljajući relevantne podatke o problemu. Mnogo podataka je potrebno prikupiti kako bi se došlo do tačnog razumijevanja problema i dolaska do potrebnih ulaznih podataka za matematički model, koji se konstruiše u narednoj fazi.  Mnogi  podaci često nisu dostupni, bilo zbog toga što informacije nikada nisu sačuvane ili su zastarjele ili su pak sačuvane u pogrešnom obliku.   Članovi tima će obično   tražiti pomoć ključnih osoba u organizaciji, kako bi pronašli sve podatke značajne za projekat. Međutim, mnogi podaci mogu biti prilično ``neprecizni'', tj. mogu biti grube procjene zasnovane samo na iskustvenim pretpostavkama. Tada treba provesti značajnu količinu vremena pokušavajući da se poboljša 
preciznost podataka, a zatim nastavi proces sa najboljim mogućim resursima koji su prikupljeni. 

\textbf{Primjer.}  OR studija je urađena za policijsku upravu jednog grada %San Francisca 
na razvoj kompjuterizovanog sistema za optimalno raspoređivanje i postavljanje patrolnih službenika. U procjeni   ove studije, identifikovani su sljedeći ciljevi:
\begin{enumerate}
    \item  Održavati visok nivo sigurnosti građana.
    \item  Održavati visok nivo zadovoljstva u policiji.
     \item Minimizovati troškove operacija.
\end{enumerate}
Da bi se postigao prvi cilj, policijska uprava i gradska vlada  su zajednički radili na uspostavljanju željenog nivoa zaštite.  Matematički model koji je razvijen je nametnuo uslov da će se postići potreban nivo zaštite preko funkcije cilja.  Da bi se postigao drugi cilj, u samom modelu je uključen i uslov o ravnopravno uravnotežnim radnim satima među policajcima. Treći cilj je ugrađen u model usvajanjem dugoročnog cilja smanjenja broja policajaca potrebnih za postizanje prva dva cilja. 

\section{Proces Formulisanja Matematičkog Modela}

Nakon što se definiše problem odlučivanja, sljedeća faza je formulisanje tog problema u obliku koji je odgovarajući za dalju analizu. Konvencionalni OR pristup se sastoji od konstrukcije matematičkog modela koji obuhvata suštinu problema. Prije nego što objasnimo kako konstruisati takav model, recimo nešto o modelima u opštem slučaju, a posebno o matematičkim modelima.

Modeli (idealizovani prikazi) su sastavni dio svakodnevnog života. Uobičajeni 
primjeri uključuju model aviona, portreta, globusa i tako dalje. Slično tome, modeli igraju
važnu ulogu u nauci i poslovanju, što uključuje modele atoma, modele 
genetskih struktura, matematičke jednačine koje opisuju fizičke zakone kretanja, grafikoni, itd. Takvi modeli
su od neprocjenjive važnosti za apstraktno poimanje suštine predmeta istraživanja, ukazivanje na međusobnu interakciju pojava i olakšavanja analize. 

Matematički modeli su obično izraženi preko matematičkih simbola, kao što je, na primjer, poznata formula $F=ma$ u fizike. Slično, matematički model biznis problema   
se sastoji od sistema jednačina i matematičkih izraza koji opisuju osnov problema. Na primjer, postoji $n$ mjerljivih odluka koje treba da budu donesene i koje su predstavljene pomoću nepoznatih (varijable) $x_1,\ldots, x_n$.  Odgovarajuća mjera učinka (profita) je izražena preko matematičkih funkcija nepoznatih koje odgovaraju  odlukama (primjer, $3x_1 + 5x_2 + x_3$). Ovaj funkcija se naziva \emph{ciljna} (objektivna) funkcija, ili \emph{funkcija cilja}. Ograničenja  vrijednosti promjenjivih se takođe izražavaju matematičkim izrazima, preko jednakosti ili nejednakosti (npr. $x_1 + x_2 + x_3 \leq 1$).  Ovakvi matematički izrazi za ograničenja se tako i nazivaju -- \emph{ograničenja} (eng. constraints). Konstante u ograničenjima, te u ciljnoj funkciji, se nazivaju \emph{parametri} modela.

Prema tome, rješavanje matematičkog modela 
podrazumijeva izbor vrijednosti varijabli (odluka), tako da se maksimizuje vrijednost funkcije cilja u odnosu na određena ograničenja. Takvi modeli, sa manjim varijacijama, karakterišu i modele koji su korišteni u OR polju. 
Određivanje odgovarajućih vrijednosti, koje se dodijeljuju parametrima modela, je kritični dio procesa konstrukcije modela.

Za razliku od problema koji su već definisani u udžbenicima, u kojima su ove vrijednosti unaprijed date,   određivanje parametara u stvarnim situacijama najprije zahtijeva prikupljanje relevantnih podataka. Kao što je objašnjeno u prethodnoj sekciji,  prikupljanje tačnih podataka je veoma izazovan proces.  Dodijeljena vrijednost parametru često predstavlja  samo grubu procjenu. Zbog nepouzdanosti vrijednosti parametara, važno je analizirati kako se rješenje, koje je izvedeno iz modela, mijenja pri malim promjenama vrijednosti parametara. 
 Problemi iz prakse obično nemaju samo jedan ``pravi'' model.  U praski   često   dva ili više potpuno različitih modela odgovaraju jednom problemu. 
Ovo je stvar razvoja modela koji je iterativni proces koji proizilazi iz rezultata testiranja i potrebe za boljim modelom.

Postoji i nepisano pravilo da nijedan matematički model koji opisuje realnu situaciju nije potpuno tačan, te je zbog toga cilj konstruisati onaj model koji  što je moguće tačnije i preciznije opisuje tu realnu situaciju.


 U nastavku  ćemo vidjeti brojne primjere matematičkih modela. Jedna posebno važna vrsta modela koju proučavamo u sljedećih nekoliko poglavlja
je model linearnog programiranja, gdje su i ciljna funkcija i ograničenja zadati kao linearne funkcije. 
Matematički modeli imaju još prednost u odnosu na jezički opis problema -- problem se opisuje mnogo sažetije. Na taj način, cjelokupna struktura problema je razumljivija, a otkrivanje važnih uzročno-posljedičnih veza u samom problemu je dosta lakše. Takođe, matematički
model čini most za korišćenje moćnih matematičkih tehnika i računara u
analizi i rješavanju problema. Zapravo, računarski programi za rješavanje raznih tipova modela su  u današnje vrijeme  široko dostupni (na primjer, poznati rješavači ovakih problema su Cplex, Gurobi, Lindo itd.). 

  Postoje i zamke na koje treba paziti kada koristimo matematičke modele. Kako je model ``apstraktna idealizacija problema'', aproksimacije i pojednostavljivanje pretpostavki uglavnom su neophodni ako želimo da je model izvršiv (tj. sposoban za rješavanje problema). Stoga se mora paziti da model ostane valjan prikaz problema nakon pojednostavljenja. To znači da 
  sve što je potrebno je da postoji velika korelacija između onoga što model predviđa i onoga što bi se zapravo dobilo u stvarnom svijetu. Da bi se utvrdilo da li je ovaj zahtjev zadovoljen, potrebno je izvršiti znatna ispitivanja i posljedične izmjene u inicijalnom modelu. O ovome ćemo govoriti u narednim sekcijama. U osnovi, provjera valjanosti modela zapravo se provodi tokom svih  faza izrade modela. 
  
 U razvoju modela, dobar pristup je započeti sa pojednostavljenom verzijom, te   krenuti sa evolucionim načinom prema složenijim modelima koji će dobro odražavati složenost stvarnog problema. Ovaj proces obogaćivanja modela nastavlja se sve dok je model rješiv. Osnovni kompromis kojeg se pridržavamo je odnos između preciznosti modela i njegove izvršivosti. Ključni korak u razvoju modela je konstrukcija funkcije cilja.
On podrazumijeva razvijanje kvantitativne mjere uspješnosti u odnosu na svaki   krajnji cilj koji je identifikovan tokom definisanja problema.
Ako postoji više ciljeva, njihove se mjere obično transformišu
i kombinuju u jednu složenu mjeru.  Ukupna mjera može biti nešto opipljivo (npr. dobit) koja odgovara višem cilju
organizacije ili može biti apstraktna.  Nakon što se razvije cjelokupna mjera,  ciljna se funkcija izražava kao matematička funkcija čiji su argumenti varijable odluke. 

% primjer preuzet iz: http://www.mathos.unios.hr/~mdjumic/uploads/diplomski/ČOR03.pdf
\textbf{Primjer.}  Uzmimo jednog proizvođa\v ca negaziranih pi\'ca. On pravi dvije vrste soka: multivitaminski gusti i multivitaminski bistri sok, od sastojaka $A$ i $B$, te vode. Da bi se napravilo 100$l$ multimitaminskog gustog soka potrebno je 3$l$
sastojka $A$ i 8$l$ sastojka $B$, a za bistri sok je potrebno 6$l$ sastojka $A$ i 4$l$ sastojka $B$. Sto litara gustog soka nosi zaradu od 100KM, a 100$l$ bistrog zaradu od 125KM. Proizvođa\v c u skladi\v stu
ima na raspolaganju 30$l$ sastojka $A$ i 44$l$ sastojka $B.$ Napravljene sokove sipa u burad. Za
gusti sok ima bure u koje stane 500$l$ teku\' cine, a za bistri sok bure kapaciteta 400$l$. Na kraju dana dolazi preprodava\v c koji kupuje sok. Cilj proizvođa\v ca sokova je da napravi koliko god
mo\v ze soka, uzimaju\' ci u obzir data ograni\v cenja, kako bi maksimizovao svoj profit. Drugim
rije\v cima, treba napraviti plan proizvodnje koji \' ce maksimizovati profit.

Model za ovakav problem bi išao ovako:
\begin{itemize}
    \item 
Varijable odluke: $x_1$ i $x_2$ koje označavaju koliko litara gustog soka i koliko litara bistrog soka proizvođač treba da napravi.  
\item Funkcija cilja: $f(x_1, x_2) = c_1x_1 + c_2 x_2$, gdje su $c_1 = 100$ i  $c_2 = 125$ koeficijenti. Funkciju $f$ treba maksimizovati. \\
\item Ograničenja: $0 \leq x_1 \leq 5, 0 \leq x_2 \leq 4$,   $3 x_1 + 6 x_2 \leq 30$, $8 x_1 + 4 x_2 \leq 44.$
\end{itemize}

\section{Izvođenje Rješenja iz Modela}

Nakon formulacije matematičkog modela za definisani problem, sljedeća faza u OR procesu je razvoj postupka (algoritma) za
izvođenje rješenja na osnovu konstruisanog modela. Nekada je to relativno jednostavan korak, u kojem neki od standardnih algoritama biva pokrenut na računaru pomoću nekog od   odgovarajućih računarskih paketa/rješavača modela.
Dodatni posao dolazi u sljedećim koracima, koji uključuje 
analizu dobijenih rezultata, koju ćemo objasniti kasnije. 

Veći dio ove knjige posvećujemo metodama koje pronalaze rješenja iz modela i prirodi dobijenih  rješenja.  Uobičajena tema u OR polju je potraga za optimalnim (najboljim) rješenjem i razvoj odgovarajućih postupaka koji služe za pronala\-ženje optimalnih rješenja na osnovu zadatog modela. Treba imati na umu da su ta rješenja optimalna samo za dati model. Kako model ne mora modelovati stvarni problem, već najčešće njegovu idealizovanu varijantu, ne postoji garancija da će se optimalno rješenje tog modela pokazati najboljim mogućim rješenjem za stvarni problem koji se razmatra. Međutim, ako je
model dobro formulisan i testiran, rezultujuće rješenje  bi trebalo da bude prihvatljiva zamjena rješenja stvarnog problema. U praksi se često pokaže da je ``dovoljno dobro'' rješenje čak prihvatljivije nego trošenje nerazumno mnogo vremena za traženje optimalnog.

Najčešće se prvo postavi lista zahtjeva koje dati model treba da ispuni, a rješenje koje zadovoljava te uslove najčešće se onda uzima kao prihvatljivo. U procesu donošenja odluka OR pokušava da unese što je moguće više ``vrhunske nauke'', tj. primarni cilj OR-a je pronalazak globalnog optimuma za posmatrani model. Međutim,  uslov da se u razumnom vremenskom roku dođe do modela koje vode ka rješenju koje je zadovoljavajuće, najčešće ima prednost u odnosu na nalazak optimuma u nerazumnom vremenu. Tim, koji rukovodi procesom, razmatra troškove procesa razvoja modela, a zatim
pokušava maksimizovati korist u oba smjera. OR timovi povremeno koriste samo približne (heurističke) pristupe rješavanju problema (tj. intuitivno dizajnirane postupke kojima se ne garantiraju optimalno rješenje) kako bi pronašli dovoljno  rješenje, koje ne mora biti optimalno. Posljednjih nekoliko decenija postignut je velik napredak u razvoju efiksanih heurističkih postupaka (uključujući tzv. metaheuristike o kojima će biti riječi u Glavi 9), pa njihova upotreba u ovom polju iz dana u dan  dobija sve više na značaju.  

Pronađeno optimalno/podoptimalno rješenje za konstruisani model može biti daleko od idealnog za stvarni problem, pa su potrebne dodatne analize. Stoga je analiza ``postoptimalnosti'' (analiza provedena nakon pronalaska (pod)optimalnog rješenja) vrlo važan dio OR studija.  Ova analiza se ponekad naziva i šta--ako analiza, jer uključuje postavljanje pitanja o tome što bi bilo sa optimalnim rješenjem ako se uvedu različite pretpostavke što implicira dodavanje novih ograničenja u postojeći model. Ova pitanja često postavlja uprava (firme) koja će donijeti konačne odluke u vezi procesa dodavanja uslova, a ne tim koji radi na modelovanju.

Pojava softvera koji rade sa proračunskim tabelama (prvenstveno Excel-a) igra centralnu ulogu u provođenju analize postoptimalnosti. Jedna od velikih prednosti ovakvih softvera je jednostavnost u korišćenju, gdje se lako dobija analiza šta se događa sa optimalnim rješenjem kada se naprave promjene na modelu.  Ovakva eksperimentisanja sa promjenama u modelu mogu biti od velike pomoći u razumijevanju ponašanja samog modela i uvjeravanja u njegovu valjanost.  Analiza postoptimalnosti dijelom  uključuje provođenje analize osjetljivosti radi utvrđivanja koji parametri modela su najkritičniji (``osjetljivi parametri'') u određivanju rješenja. Uobičajena definicija osjetljivog parametra je sljedeća:

Osjetljivi parametri matematičkog modela su oni parametri čije se vrijednosti ne mogu mijenjati bez promjene optimalnog rješenja. 

Prepoznavanjem osjetljivih parametara pronalazimo one parametre čija se vrijednost mora dodijeliti sa posebnom pažnjom, kako bi se izbjeglo narušavanje rezultata modela. Da napomenemo, vrijednost koja se parametru obično dodjeljuje samo je procjena neke veličine
(npr. jedinična dobit ili vrijeme potrebno da se neka aktivnost izvrši) čija će tačna vrijednost postati preciznije tek nakon što se rješenje primijeni na problem. Stoga, nakon
što se identifikuju osjetljivi parametri, posebna pažnja se posvećuje bližoj procjeni svakog parametra, te  raspona njihovih mogućih vrijednosti.  U nekim slučajevima, određeni parametri modela predstavljaju interesne odluke (npr. dodjele resursa). Ako je to slučaj, često postoji određena fleksibilnost u vrijednostima koje se dodjeljuju ovakvim parametrima u smislu da se neke vrijednosti povećavaju  smanjenjem drugih. Postoptimalna analiza uključuje i istraživanje takvih kompromisa. Analiza postoptimalnosti takođe uključuje i dobijanje niza rješenja koji aktivira niz poboljšanja u modelu i konvergenciju prema idealnom modelu. Postupak poboljšanja modela se nastavlja sve dok    poboljšanja u sljedećim rješenjima ne postanu premala da bi se nastavilo sa ovakvim iterativnim procesom.   Alternativna rješenja (rješenja koja su optimalna za jedan od nekoliko probližnih modela) se takođe mogu predstaviti upravi za konačan odabir. 

%\textbf{Primjer.}  Posmatrajmo OR studiju o nacionalnom upravljanja vodama.


\section{Testiranje Modela}
Razvoj velikih matematičkih modela je analogan razvoju velikih softvera. U praksi se često dešava da se, po završetku izrade prve verzije softvera, javi i određen broj grešaka (bagova). Zbog toga se pristupa raznim procedurama testiranja proizvoda, kako bi se pokušalo pronaći i
ispraviti što više grešaka. Na kraju, nakon niza iteracija poboljšanja programa, programeri zaključuju da trenutni program sada
daje generalno valjane rezultate. Dešava se i da neke manje pogreške ostaju skrivene u programu i možda se nikada i ne uklone.

Slično tome, prva verzija matematičkog modela neizbježno sadrži određene
nedostatke. Neki relevantni faktori ili međusobni odnosi često ne budu  ispravno ugrađeni
u model, a neki parametri ne budu pravilno procijenjeni. 

Iako su nepoželjne, ove pojave ne treba shvatati kao fatalne greške, već kao očekivanu pojavu s obzirom na potencijalne probleme u komunikaciji, teškoću razumijevanja svih aspekata problema te poteškoća pri prikupljanju pouzdanih podataka. Stoga, prije nego što upotrijebimo model, on se mora  temeljno testirati kako bismo mogli  identifikovati 
i ispraviti što više njegovih nedostataka. Na kraju, nakon velikog broja iteracija poboljšanja 
modela, OR tim koji radi na modelu zaključuje da trenutni model sada daje razumno valjane rezultate.  Iako neki manji nedostaci nesumnjivo ostaju skriveni u modelu (a možda nikada neće ni biti otkriveni), glavni nedostaci su otklonjeni, te se može tvrditi da je model pouzdan. Ovaj postupak ispitivanja i poboljšanja modela radi povećanja njegove valjanosti se naziva \emph{validacija modela}. 

Budući da OR tim može provesti mjesece na izradi svih detalja modela, može se desiti i da se zbog detalja odstupi od suštine modela. Stoga, nakon što su detalji uključeni u 
početnu verziju modela, dobar način za početak provjere valjanosti je ponovni pogled na cjelokupni model kako bi se provjerilo da li ima  očiglednih grešaka ili propusta. U cilju što objektivnijeg pristupa, poželjno je da grupa koja radi ovaj pregled uključi barem jednog pojedinca koji nije učestvovao u konstrukciji modela. Preispitivanje definicije
problema i poređenje sa modelom mogu pomoći u otkrivanju nekih pogrešaka. Takođe, korisno je da su svi matematički izrazi dimenzionalno konzistentni.  Ponekad se  dodatni uvid u valjanost modela dobija i 
mijenjanjem vrijednosti parametara i / ili varijabli odluke, kao i provjerom da li se  izlaz iz modela ponaša na očekivan način. To se često može otkriti kada se parametrima ili varijablama dodjeljuju ekstremne vrijednosti u blizini njihovih maksimuma ili minimuma (takozvani ``korner slučajevi'' -- engl. \textit{corner cases}). 

Sistematski pristup ispitivanju modela podrazumijeva upotrebu retrospektivnog testa. Ovaj test uključuje upotrebu istorijskih podataka koji prate konstrukciju modela, a zatim utvrđuje koliko bi dobro funkcionisali model i rezultujuće rješenje, ako bi ono  bilo korišteno u praksi.  Ovaj pristup može da ukaže na dijelove na kojima model ima nedostatke, što zahtijeva dalje izmjene i poboljšanja. 
S druge strane, nedostatak retrospektivnog ispitivanja je taj što koristi iste podatke kao i oni koji vode ka formulaciju modela. %Ključno je pitanje da li prošlost zaista reprezentuje budućnost. %Da bi se zaobišao   nedostatak retrospektivnog testiranja, ponekad je korisno privremeno nastaviti sa statusom quo. To će dati nove podatke koji nisu bili dostupni kada  je
%model konstruiran. 
Važno je još dokumentovati postupke koji se koriste u testiranju valjanosti modela. Ovo može  povećati povjerenje u model za buduće korisnike. Takođe, ako se u budućem vremenu pojave pitanja u vezi sa modelom, ova dokumentacija će  biti korisna u dijagnosticiranju problema. 

\begin{comment}
\textbf{Primjer.}  Primjer se odnosi na OR studiju provedenu   za IBM kako bi se integrisala nacionalna mreža zaliha rezervnih dijelova radi poboljšanja servisne podrške za IBM-ove kupce.

Ovom studijom je dobijen  novi inventarni sistem koji je poboljšao korisničku uslugu kroz koju se uštedilo dodatnih 20 milijuna USD po godini kroz poboljšanu operativnu efikasnost. Posebno zanimljiv aspekt faze provjere validnosti modela ove studije bio je način na koji su  budući korisnici inventarnog sistema ugrađeni u postupak ispitivanja. Prvo su odabrani predstavnici koji su činili korisnički tim čija je uloga bila  savjetovati OR tim. Nakon što je razvijena preliminarna verzija novog sistema izvršeno je njgovo testiranje. Opsežne povratne informacije korisničkog tima dovele su do glavnih poboljšanja u predloženom sistemu.  
\end{comment}

\section{Priprema za primjenu modela}
Ako želimo da model bude iskorišten više puta, sljedeći  korak je instaliranje dobro dokumentovanog sistema za primjenu modela po propisima naručioca (uprave). Ovaj sistem uključuje implementaciju samog modela, postupak dobijanja rješenja (uključujući analizu postoptimalnosti), operativne postupke za izvođenje, itd. %Tada, čak i kad se osoblje mijenja, sistem se može pozvati na regularnoj bazi da se ponudi određeno numeričko rješenje
Svaki put pri korištenju sistema, baze podataka i informacioni sistem za upravljanje treba da omoguće ažuran unos za model, te je zbog toga potrebno obezbijediti i odgovarajući interfejs. Nakon što se na model primijeni postupak rješavanja (drugi program), dodatni  programi mogu automatski pokrenuti implementaciju rezultata kako bi ih korisnici mogli odmah primijeniti u realnoj situaciji. U drugim slučajevima, može se instalirati i interaktivni računarski sistem  za podršku odlučivanju, koji pomaže upravi da koriste podatke i modele kako bi, po potrebi, podržali (a ne zamijenili) njihovo donošenje odluka. Drugi program može generisati menadžerske izvještaje (na jeziku upravljanja) koji tumače izlazne podatke modela i njegove implikacije na primjenu u realnom okruženju.  U velikim OR studijama potrebno je nekoliko mjeseci (a nekada čak i duže) za razvoj, testiranje i instaliranje ovakvog računarskog sistema. Dio ovog napora uključuje razvoj i izvođenje postupka održavanja sistema  tokom njegove buduće upotrebe. Kako se uslovi mijenjaju tokom vremena, potrebno je obezbijediti i mogućnost za  izmjene sistema, uključujući i izmjene samog modela, u skladu sa tim uslovima.  

Sljedeći primjer nam opisuje sistem u IBM-u za kontrolu usluga i zaliha rezervi da bi se dobio osjećaj o kompleksnosti ovakvih sistema.  

\textbf{Primjer.}
%OR studija  za IBM predstavljena na kraju prošle sekcije je primjer   velikog sistema koji integriše model.
Sistem nazvan \emph{Optimizer} pruža optimalnu kontrolu usluga i zaliha rezervnih dijelova u cijeloj IBM-ovoj mreži za distribuciju dijelova u SAD-u, koja uključuje dva središnja
automatizovana skladišta, deseci terenskih distribucijskih centara i stanica za dijelove te nekoliko hiljada vanjskih (povezanih) lokacija. Inventar dijelova koji se održava u ovoj mreži se procijenjuje u milijardama dolara. \emph{Optimizer} se sastoji od četiri glavna modula. Modul sistema predviđanja sadrži nekoliko programa za procjenu stope kvara pojedinih vrsta dijelova. Modul sistema za dostavljanje podataka sastoji se od otprilike 100 programa koji    obrađuju
preko 15 Gb podataka kako bi se osigurali ulazni podaci za model. Sistem odlučivanja potom rješava model koji traje i  sedmicu dana kako bi se optimizovala kontrola zaliha. Četvrti modul uključuje šest programa koji integrišu \emph{Optimizer} u IBM-ov sistem upravljanja zalihama dijelova. %PIMS je sofisticirani informacijski i kontrolni sustav koji sadrži milijune redaka koda 
\section{Implementacija}
Nakon što se razvije sistem za primjenu modela, posljednja faza OR studije je upotreba ovog sistema kako ga je uprava (koja naručuje razvoj sistema) propisala. Ova je faza ključna jer se ovdje ``ubiru plodovi rada''. Stoga je važno da OR tim  sudjeluje u  realizaciji ove faze, kako bi se osiguralo da se rješenja modela precizno prevedu u operativni postupak i kako bi se ispravili svi nedostaci u rješenjima koja se otkriju. Uspjeh faze implementacije uvelike zavisi i od podrške vrha uprave (firme). Mnogo je vjerovatnije da će OR tim dobiti podršku ako je dobro informisao upravu i podsticao  njeno aktivno učestvovanje tokom razvoja rješenja. Dobra komunikacija pomaže da istraživanje postigne ono što je uprava željela.  Faza implementacije uključuje nekoliko koraka. Prvo, OR tim daje operativnom rukovodstvu opis novog sistema koji treba da bude usvojen. Dalje, ove dvije strane dijele odgovornost za razvijanje koraka potrebnih za pokretanje ovog sistema. Operativno rukovodstvo zatim posmatra  osoblje koje je uključeno u proces implementacije, te mu daje detaljna uputstva za korištenje sistema. Time može da počne proces primjene sistema u realnim uslovima. Nakon uspješnog uvođenja sistema, očekuje se da će se on koristiti u nekom narednom periodu (na primjer u narednim godinama). Imajući to na umu, OR tim nadgleda iskustva korisnika sistema i nastoji da utvrdi koje izmjene u budućnosti bi trebalo uraditi na sistemu  u cilju njegovog lakšeg korištenja.  Tokom vremena u kojem se koristi novi sistem, važno je i dalje dobijati povratne informacije o funkcionisanju sistema, te da li su pretpostavke o modelu i dalje zadovoljene. Kada se pojave značajna odstupanja od originalnih pretpostavki modela, model treba ponovno pregledati i eventualno izvršiti korekcije. Nakon završetka projekta, potrebno je da OR tim  dovoljno jasno i precizno dokumentuje svoju metodologiju, kako bi se čitav posao mogao ponoviti. Repliciranje bi trebalo
biti dio profesionalnog etičkog kodeksa projektovanja (informacionih) sistema. %Ovo je stanje osobito važno kada se proučavaju kontroverzna pitanja javne politike. 

\textbf{Primjer.} Vratimo se na realni  IBM projekat pomenut u prethodnim sekcijama.  Tri su se glavna faktora pokazala posebno važnim za uspješan završetak projekta. Kao što je raspravljano u prethodnim poglavljima, 
prvo je   uključivanje korisničkog tima i (operativnog rukovodstva) koji je savjetovao tim tokom trajanja   projekta. U vrijeme faze implementacije, operativno rukovodstvo imalo je snažan  uticaj i naglašavali su važnost instaliranja \emph{Optimizer}-a u  funkcionalna područja poslovanja IBM-a. Drugi faktor uspjeha bio je dobijanje vrlo široke povratne informacije korisnika sistema, gdje su identifikovane problematične tačke u sistemu koje su  trebale biti ispravljene prije potpune implementacije. 
Treći faktor je bio taj da je novi sistem  uvođen postepeno, fazu po fazu, uz pažljivo testiranje u svakoj fazi, kako bi se veće greške mogle ukloniti prije nego što je sistem   pušten na  globalnom nivou.  
\vspace{0.5cm}

Ostatak ove knjige je fokusiran prvenstveno na razvoj matematičkih modela i odgovarajućih metoda za njihovo rješavanje. Ovim poglavljem smo objasnili, a kroz neke primjere i ilustrovali, kako konstrukcija modela složenih problema ne sadrži samo ova dva koraka, već su oni samo dio cjelokupnog OR procesa. Treba imati na umu da su sve faze vrlo važne za provođenje uspješnog OR projekta. Predlažemo da se nakon izučavanja algoritama za rješavanja modela, čitalac vrati na ovo poglavlje u cilju što jasnije slike razvoja potpunog OR projekta zasnovanog na kompleksnim procesima u praksi.  OR zahtijeva značajnu količinu domišljatosti, kreativnosti i inovativnosti, tako da u praksi i ne postoji jedan standardni postupak kojeg bi se timovi trebali pridržavati pri razvijaju sistema zasnovanih na operacionim istraživanjima. %Prethodni opis može da se promatra kao model koji otprilike pokazuje koliko je uspješan ILI se provode studije. 
%\newpage

\chapter{Linearno Programiranje} 
  
  Početak razvoja linearnog programiranja datira u period sredine dvadesetog vijeka. Sovjetski matematičar i ekonomista Leonid Kantorovič je tokom drugog svjetskog rata formulisao problem ekvivalentan problemu linearnog programiranja u cilju boljeg upravljanja resursima i smanjenja troškova u vojsci. Neposredno nakon drugog svjetskog rata, američki matematičar Džordž Dencig razvija čuveni simpleks algoritam, čime se otvara prostor za efikasno rješavanje problema linearnog programiranja. U periodu koji je uslijedio, pa sve do danas, linearno programiranje se koristi kao standardan alat za rješavanje raznih problema u industriji i ekonomiji uopšte, što je dovelo do uštedio milionskih ušteda ogromnom broju kompanija u raznim zemljama svijeta. Stoga se 
razvoj linearnog programiranja  smatra jednim od najvažnijih naučnih dostignu\-ća XX vijeka.  Napisano je na desetine, pa i stotine udžbenika
o linearnom programiranju i objavljeno je na hiljade naučnih radova koji   ovu paradigmu primjenjuju na probleme iz raznih naučnih i praktičnih domena. 

Linearno programiranje koristi matematički model za opisivanje problema; 
pridjev ``linearno'' podrazumijeva da su  matematičke funkcije korištene u modelu linearne funkcije. Riječ ``programiranje'' se ne odnosi na računarsko programiranje, već je to sinonim za planiranje i optimizaciju. Dakle, linearno programiranje uključuje planiranje aktivnosti u cilju postizanja optimalnog rezultata, tj. rezultata koji najbolje postiže navedeni cilj (prema matematičkom modelu) među svim izvedivim alternativama.  Za rješavanje problema linearnog programiranja razvijeno je dosta efikasnih metoda. Iako jedan od nastarijih,  \emph{simpleks metod} se i danas koristi za rješavanje problema velikih dimenzija te je zaslužan za ogroman uticaj linearnog  programiranja u raznim oblastima nauke i privrede.

\textbf{Primjer}. U ovom primjeru opisujemo jedan industrijski projekat 
-- {WYNDOR--GLASS CO projekat}, te kako OR može da riješi ozbiljne probleme jedne firme. 
  
Firma \texttt{WYNDOR--GLASS} proizvodi visokokvalitetne staklene proizvode, uključujući prozore i staklena vrata. Postoje tri pogona. Aluminijski okviri i okovi izrađuju se u pogonu 1, drveni okviri izrađuju se u pogonu 2, a pogon 3 proizvodi staklo i sastavlja proizvode.
Zbog pada zarade, rukovodstvo firme   odlučio je da obnovi liniju proizvoda koje nudi. Neprofitabilni proizvodi se ukidaju, oslobađajući proizvodne kapacitete za lansiranje dva nova proizvoda sa velikim prodajnim potencijalom:
\begin{itemize}
    \item Proizvod 1: Staklena vrata od 2$m$ sa aluminijskim okvirom;
    \item Proizvod 2: Dvostruka drvena vrata s okvirom visine 1.5$m$.
\end{itemize}
Uslovi i zahtjevi proizvodnje su sljedeći:
\begin{itemize}
    \item Proizvod 1 zahtijeva   korištenje proizvodnih kapaciteta u postrojenjima 1 i 3, ali ne korisiti pogon 2; 
    \item Proizvod 2 treba   postrojenja 2 i 3 za proizvodnju. 
\end{itemize}
    Rukovodstvo kompanije je zaključilo da bi kompanija mogla prodati sve proizvode koje bi mogla proizvesti u postrojenjima. Međutim, budući da   oba proizvoda koriste proizvodni kapacitet u pogonu 3, nije bilo jasno koja bi kombinacija proizvodnje dva proizvoda bila najisplativija. %Stoga je formiran tim za proučavanje ovog pitanja, te davanja adekvatnog odgovora.

Nakon razgovora, glavni ciljevi istraživanja su utvrđeni, te se došlo se do definicije (idealizovanog) problema koji treba da se riješi:
\begin{itemize}
    \item Utvrditi  stope proizvodnje  ova dva proizvoda kako bi se maksimizovala ukupna dobit, koja je podložna ograničenjima nametnuta od strane   proizvodnih kapaciteta koji su dostupni u sva tri pogona. 
    \item Svaki proizvod se proizvodi u serijama od po 20 komada, tako da se stopa proizvodnje definiše kao broj serija proizvedenih na nivou jedne sedmice. 
    \item Dopuštena je bilo koja kombinacija stope proizvodnje koja zadovoljava ograničenja, uključujući i slučaj da se ne proizvede niti jedan od (dva) proizvoda kao i slučaj da se proizvede maksimalan broj drugog proizvoda. 
\end{itemize}

Da bi se razvio model, informacije koje je bilo neophodno prikupiti prije modelovanja su:
\begin{itemize}
	\item[($i$)]   Broj radnih sati u sedmici dostupan u svakom pogonu za nove proizvode;  
	\item[($ii$)]   Broj radnih sati korištenih u svakom pogonu za svaku proizvedenu seriju svakog novog proizvoda;
	\item[($iii$)] Dobit po proizvedenoj seriji svakog novog proizvoda. Dobit po proizvedenoj seriji je  odabrana   kao odgovarajuća mjera jer je zaključeno da   dobit svake dodatne proizvedene serije  raste približno konstantno bez obzira na ukupan broj proizvedenih serija.
\end{itemize} 

Budući da značajniji troškovi za pokretanje proizvodnje i promovisanje novih proizvoda nisu postojali, ukupna dobit je aproksimirana dobiti po proizvedenoj seriji koja je pomnožena sa brojem serija proizvodnje.  

Dalje, trebalo je procijeniti konstante (parametre)  u modelu. Ovo je ostvareno u komunikaciji između uprave firme i tima zadužen za rješavanje problema. 
Za dobijanje razumnih procjena, pomoć ključnog osoblja u raznim odjelima firme je odigrala bitnu ulogu. Osoblje u proizvodnom odjelu informisalo  je o podacima za stavku ($i$). Za procjenu slučaja ($ii$) ključna je bila analiza proizvodnih inženjera uključenih u dizajniranje proizvodnih procesa novih proizvoda. Analizirajući podatke o resursima te uključivanje  marketinškog odjela firme,  data je procjena za slučaj ($iii$). Tabela~\ref{tab:procjene-1} daje sve ove procjene. 


\begin{table}[!ht]
    \centering
    \scalebox{0.85}{
    \begin{tabular}{c|c c | c}
    \      &      \multicolumn{2}{l}{Vrijeme proizvodnje serije ($h$)}    & \  \\ \hline
    \      &      \multicolumn{2}{c}{Proizvod}                      & \  \\ 
    Pogon  &  1    &      2                                 & Vrijeme za proizvodnju po sedm. ($h$) \\ \hline 
           1 & 1  &  0 &  4  \\
           2 & 0  &  2 &  12  \\ 
           3 & 3  &  2 &  18  \\ \hline
           Profit po seriji & 3000 & 5000 & \  \\
           \hline
    \end{tabular}}
    \caption{Procjene konstanti modela.}
    \label{tab:procjene-1}
\end{table}

U nastavku konstruišemo model problema. Uvedimo varijablu $x_1$ za broj serija proizvoda 1 proizvedenog na sedmičnom nivou, te $x_2$ broj serija proizvoda 2 koji je proizveden na sedmičnom nivou. Funkcija profita je jednaka $f(x_1, x_2) = 3 x_1 + 5 x_2$ pod ograničenjima
\begin{itemize}
    \item $x_1, x_2 \geq 0$
    \item  $x_1 \leq 4, 2 x_2 \leq 12$
    \item $3 x_1 + 2 x_2 \leq 18$
\end{itemize}

Dakle, na osnovu realnog problema, formirali smo odgovarajući matematički model (idealizovanog problema) koji sadrži funkciju dvije promjenljive i nekoliko ograničenja, koja su zapisana kao nejednačine. Cilj rješavanja ovog matematičkog modela je pronalaženje onih vrijednosti promjenljivih $x_1$ i $x_2$, za koje posmatrana funkcija ima maksimalnu vrijednost.

%https://www.desmos.com/calculator
\section{Rješenje grafičkom metodom}
 Problem iz prethodne sekcije je malih dimenzija jer sadrži samo dvije varijable odluke i samim tim sva moguća (dopustiva) rješenja mogu biti predstavljene u dvije dimenzije. U ovom slučaju, možemo koristiti \emph{grafičku metodu} za rješavanje problema linearnog programiranja. Ovaj postupak uključuje dvodimenzionalni Dekartov koordinatni sistem sa osama $x_1$ i $x_2$.  Prvi korak je identifikovati vrijednosti ($x_1$, $x_2$) koje zadovoljavaju ograničenja. Naglasimo još jednom da ona rješenja koja zadovoljavaju sva ograničenja modela  problema zovemo \emph{dopustivim rješenjima}. Grafički predstavimo svako od ograničenja, odakle dobijamo prostor koji uključuje svih 6 ograničenja; vidjeti Sliku~\ref{fig:fig1}.  Rezultujući region rješenja $(x_1, x_2)$ se naziva \emph{dopustivi region} problema.
 
 Posljednji korak se sastoji u odabiru tačke u ovom regionu  koja maksimizira vrijednost (ciljne) funkcije $f = 3x_1 + 5x_2$. 

%) The resulting region of permissible values of (x1, x2), called the feasible region,
\begin{figure}
    \centering
    \includegraphics[width=150pt,height=150pt]{fig1.eps}
    \caption{Dopustiv region.}
    \label{fig:fig1}
\end{figure}
Pogledajmo sada niz (implicitnih) funkcija $3x_1 + 5 x_2 = c$, za $c \in \{10,20, 36\}$, kao na Slici~\ref{fig:fig2}. Jasno se vidi da prava $f = 36$ prolazi kroz tačku (vrh) regiona $(2,6)$ koja je svakako dopustiva. Takođe, vidimo da niti jedna druga funkcija $f=c, c > 36$ ne presijeca dopustiv region, odatkle zaključujemo da je tačka $(2, 6)$ rješenje problema. Dakle, funkcija cilja ima maksimalnu vrijednost 36 i dostiže se u tački $(x_1, x_2)=(2,6)$.

Ovaj se postupak često naziva \emph{grafičkom metodom za linearno programiranje}. Ona se može koristiti za rješavanje bilo kojeg problema linearnog programiranja sa dvije varijable. Uz znatan angažman, moguće je proširiti ovu metodu na problem sa tri varijable, što je krajnji domet grafičke metode. Za uopšten slučaj se koriste naprednije metode,  o kojima će biti riječi u narednim sekcijama.

\section{Standardna Forma Linearnog Programiranja}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=160pt, height=160pt]{fig2.eps}
    \caption{Dodavanje $f = c$ i nalazak optimuma transliranjem po dopustivom regionu.}
    \label{fig:fig2}
\end{figure}

U ovoj sekciji govorimo o opštoj formi modela linearnog programiranja. 
%Iako to sa matematičkog stanovišta nije neophodno, 

Uvedimo neke ključne pojmove koji se standardno koriste u modelovanju i rješavanju problema linearnog programiranja. 

Pođimo od pojmova \textit{resursi} i \textit{aktivnosti}. Pretpostavimo da u našem razmatranju imamo $m$ resursa i $n$ aktivnosti. Standardni resursi su vrijeme, novac, oprema, mašine, radnici itd. Aktivnosti uključuju ulaganje novca u određene projekte, dodjelu posla nekoj mašini ili radniku,  dostavljanje robe iz jednog u drugo mjesto, itd. 
 Najčešći tip primjene linearnog programiranja uključuje povezivanje resursa i aktivnosti, odnosno dodjelu resursa određenim aktivnostima. Dostupna količina svakog resursa je najčešće ograničena, pa aktivnosti trebaju biti pažljivo raspoređene u odnosu na dostupne odgovarajuće resurse.  Utvrđivanje ove raspodjele uključuje odabir vrsta i nivoa aktivnosti za koje se postiženajbolja moguća vrijednost ukupne mjere učinka. Ukupna mjera učinka može biti mjerenje dobiti (profita), mjerenje vremena realizacije aktivnosti, mjerenje broja proizvedenih proizvoda itd.

U nastavku navodimo notaciju koja se najčešće koriste u formiranju opšteg oblika modela linearnog programiranja:

\begin{itemize}
    \item $f$: funkcija cilja (dobiti) 
    \item $x_j$: količina aktivnosti $j$ ($j = 1,\ldots,n$);
    \item $c_j$: povećanje u profitu ako se količna aktivnosti $j$ podigne za jediničnu vrijednost;
    \item $b_i$: ukupna količina resursa $i$ ($i=1,\ldots,m$) koja je dozvoljena za alociranje aktivnosti;
    \item $a_{ij}$: količina resursa $i$ koja se uzima od strane jedinične (vrijednosti) aktivnosti $j$.
\end{itemize}
Prema ovoj notaciji, matematički modeli problema linearnog programiranja ima sljedeću postavku:

\begin{align} 
      &f = c_1 x_1 + \cdots + c_n x_n \rightarrow \max \label{form:LP-1}\\
      & s.t. \nonumber \\
      & a_{11}x_1 + a_{12} x_{12} + \cdots + a_{1n}x_n \leq b_1 \label{form:LP-2} \\
      &\ldots \nonumber \\
      & a_{m1}x_1 + a_{12} x_{m2} + \cdots + a_{mn}x_n \leq b_m \label{form:LP-3} \\
      & x_i \geq 0,\ i=1,\ldots,n.\label{form:LP-4}
\end{align}

Postavka (\ref{form:LP-1})--(\ref{form:LP-4}) se još naziva i \emph{standardna forma} problema linearnog programiranja. Funkcija (\ref{form:LP-1}) se naziva funkcija cilja koju je potrebno maksimizovati pod uslovima (\ref{form:LP-2})--(\ref{form:LP-3}), koji se nazivaju \emph{funkcionalna ograničenja}. Ograničenja (\ref{form:LP-4}) se nazivaju \emph{nenegativna ograničenja}. 

Kompaktiniji oblik standardne forme je dat sa:
\begin{align}
    & f = c^T x \rightarrow \max \label{eq:LP-o1}\\
    & \mbox{s.t.} \nonumber \\
    &  A x \leq b \label{eq:LP-c1} \\
    & x \geq 0 \label{eq:LP-c2},
\end{align}

gdje je matrica $A \in \mathbb{R}^{m \times n}$, vektori  $x,c \in \mathbb{R}^n$ i vektor $b \in \mathbb{R}^{m}$.

Treba imati na umu da ograničenja (\ref{eq:LP-c1}) mogu da imaju i oblike:
\begin{itemize}
    \item $Ax \geq b$;
    \item $Ax = b$;
    \item neke od varijabli $x_i\leqslant 0$.
\end{itemize}
Bilo koji problem koji koristi neke od prethodna tri ograničenja predstavlja i dalje problem linearnog programiranja. Dodavajući tzv. \emph{izravnavajuće varijabe} $s \in \mathbb{R}^m$ u linearni program sa ograničenjima $Ax \leq b$, dobijamo linearni program sa ograničenjia $Ax + s = b, s \geq 0$. Isto tako, linearni program sa ograničenja $Ax \leq b$ se može izmijeniti u ograničenja sa jednakostima dodavanjem izravnavajućih varijabli kao $Ax - s = b, s\geq 0$.

 Forma linearnog programa sa ograničenjima $Ax = b$ se naziva \emph{kanonska} forma linearnog programiranja. 
 
 Takođe, ako u linearnom
programu postoji varijabla koja ne zadovoljava uslov nenegativnosti, ona se može zamijeniti razlikom dve nove nenegativne promenljive. Kanonski oblik linearnog programiranja je pogodan za efikasno izvođenje Gausovih transformacija  nad matricom problema, što će biti od koristi u konstrukciji simpleks metoda.   %, jer je svaki broj razlika dva nenegativna broja.

 U nastavku pratimo sljedeću terminologiju u vezi linearnog programiranja (LP):
\begin{itemize}
    \item \emph{Rješenje} u standardnom matematičkom značenju najčešće označava krajnje rješenje   (u LP-u bi to bilo najbolje rješenje). Međutim, u rješavanju problema LP-a to  nije slučaj. Bilo koja specifikacija vrijednosti varijabli  $(x_1,\ldots, x_n)$ se smatra rješenjem bez obzira da li je riječ o željenom rješenju ili čak o nekom rješenju koje i ne zadovoljava kriterijume. U zavisnosti od toga, rješenja  možemo podijeliti na:
    \begin{itemize}
        \item \emph{dopustiva rješenja} (eng. \emph{feasible solution}) -- podrazumijevanju ona rješenja koja zadovoljavaju sva ograničenja u modelu;
        \item \emph{nedopustiva rješenja} (eng. \emph{infreasible solution}) -- ona rješenja koja ne zadovoljavaju barem jedno od ograničenja u modelu. 
    \end{itemize}
  \item \emph{Dopustivi region}: označava skup svih rješenja koja su dopustiva. Ovo je prostor koji pretražujemo u svrhu pronalaska najboljeg rješenja modela. Takođe, može se desiti da problem nema niti jedno dopustivo rješenje. Kažemo da je taj problem \emph{nedopustiv}. 
  \item \emph{Optimalno rješenje} je ono rješenje iz dopustivog skupa za koje je funkcija cilja najveća (pod pretpostavkom da maksimizujemo funkciju cilja), odnosno najmanja (pod pretpostavkom da minimizujemo funkciju cilja). Ova vrijednost ne mora biti jedinstvena, pogledati Sliku~\ref{fig:multi_solution} gdje je dopustiv region isti kao u primjeru sa Slike~\ref{fig:fig1}, dok je funkcija cilja data sa $f = 3x_1 + 2 x_2$.  
 \end{itemize}
 
 \begin{figure}
     \centering
     \includegraphics[width=160pt, height=160pt]{fig3.eps}
     \caption{LP sa više od jednog optimalnog rješenja.}
     \label{fig:multi_solution}
 \end{figure}
 
 Za razliku od nedopustivog problema, može se desiti i sasvim druga situacija, da je problem neograničen. U tom slučaju vrijednosti (jedne od) varijabli se mogu povećavati tako da funkcija cilja (u problemu maksimizacije) teži ka beskonačno, tj. nije ograničena odozgo nekom vrijednošću. Za taj problem kažemo da je \emph{neograničen} problem.
 
 Primjer takvog problema možemo vidjeti na Slici~\ref{fig:unbounded_solution}, gdje je potrebno maksimizovati funkciju $f = 3 x_1 + x_2$, pod uslovima $0\leq x_1 \leq 4$, te $x_2 \geq 0$. Kao što se može vidjeti, što se više povećava vrijednost varijable $x_2$, to funkcija $f$ više raste. Ako bi $x_2$ bilo $\infty$, to bi i funkcija $f$ bila neograničena ($f = \infty$).
 
  \begin{figure}
     \centering
     \includegraphics[width=160pt, height=160pt]{fig4.eps}
     \caption{Primjer LP-a koji je neograničen.}
     \label{fig:unbounded_solution}
 \end{figure}
 
Uvedimo sada pojam \emph{ekstremalnih tačaka}, koje igraju bitnu ulogu u simpleks metodi. Za rješenje $x$ kažemo da je \emph{ekstremna tačka} ako se nalazi u vrhu dopustivog regiona (u presjeku granica dopustivog regiona).

Postoji važne veze između ovih tačaka i optimalnog rješenja LP-a, o čemu će biti riječi u nastavku ove knjige.
Prije toga, za početak, razmotrimo bilo koji problem LP-a sa dopustivim rješenjima i ograničenim dopustivim regionom. Tada će važiti, što ćemo uskoro i pokazati, da problem tada posjeduje barem jednu tačku koja je vrh tog regiona i barem jedno optimalno rješenje. Nadalje, jedan od vrhova mora biti optimalno rješenje. Dakle, ako problem ima tačno jedno optimalno rješenje, to rješenje je tačka koja je vrh regiona. Ako problem ima više optimalnih rješenja, barem dva moraju biti rješenja koja su tačke  vrhova dopustivog regiona.

\textit{Napomena.} Imajte na umu da (optimalno) rješenje LP-a ne mora da bude cjelobrojno. Budući da svaka varijabla odluke predstavlja nivo odgovarajuće aktivnosti, pretpostavlja se da se aktivnosti mogu izvoditi na razlomljenim nivoima (aktivnost  se ne dijeli samo na diskretne dijelove), na osnovu nenegativnih ograničenja.  

Ako su sve varijable u problemu LP-a cjelobrojne, riječ je o problemima \emph{Cjelobrojnog programiranja}. Ako pored cjelobrojnih, postoje i neke varijable koje su neprekidne, riječ je o problemima \emph{Mješovitog--cjelobrojnog linearnog programiranja}. Veliki broj realnih problema koji dolaze iz prakse su upravo problemi Mješovitog--cjelobrojnog linearnog programiranja.

\section{Modelovanje nekih Problema paradigmom Linearnog Programiranja}\label{sec:modeli_lp}

\emph{Problem optimalne prehrane.} Pretpostavimo da su nam na raspolaganju namirnice $N_1, \ldots, N_n$. Cijena namirnice $N_j$ po jedinici je $c_j, j = 1, \ldots, n$. U namirnicama su prisutni nutritivni elementi $e_j,j=1,\ldots,m$ pri čemu
u namirnici $N_j$ ima $a_{ij} \geq 0$ nutritivnog elementa $e_i$, $i = 1, \ldots, n$, $j = 1, \ldots, m$. Svaka osoba u toku dana treba da unese barem $b_i$
jedinica nutritivnog elementa $e_i$. Potrebno je modelovati
sljedeći problem: 

\emph{Koliko je koje namirnice potrebno kupiti za (dnevnu) prehranu da bi se zadovoljila dnevna
potreba za svim nutritivnim elementima, a da se pri tome minimizuje cijena prehrane?}
 
 \emph{Rješenje.}  Uvedimo prvo varijable $x_j \geq 0$ za količinu hrane namirnice $N_j$, $j = 1, \ldots, n$ koja će da bude korištena za prehranu. Funkcija cilja je da se minimizuje cijena prehrane, pa je, prema tome 
 $$f(x) = c_1 x_1 + \cdots + c_n x_n.$$
 
 Dalje, ograničenja su sljedeća: treba da se zadovolje dnevne potrebe za unos svakog nutritivnog elementa, odakle slijedi da za $i$-ti element treba da bude zadovoljeno
 
 $$ a_{i,1} x_1 + \ldots + a_{i,n} x_n \geq b_i $$
 
 za svako $i=1,\ldots,m$. 
 
 Dodajući još uslove nenegativnosti, $x_i \geq 0$, formulisali smo linearni model za ovaj problem.  
 
\emph{Problem najboljeg pravca (problem linearne regresije)}. Zadani su podaci $(x_i, y_i), i = 1, \ldots , n$. Potrebno je odrediti pravu sa jednačinom $y = k x + l,
k, l \in \mathbb{R}$ koja u smislu $l_1$ norme najbolje aproksimira date podatke. U prevodu, potrebno je minimizovati  funkcija cilja $$f(k, l) = \sum_{i=1}^n |k x_i + l - y_i|.$$

\emph{Rješenje}.
Označimo $z_i = |k x_i + l - y_i| = \max\{k x_i + l - y_i, y_i - k x_i - l \}$, $i=1,\ldots,n$. 

Primijetimo da apsolutna vrijednost ne odgovara direktno problemu LP-a bilo da je prisutna u funkciji cilja ili ograničenjima, jer ona sama po sebi nije linearna funkcija. Međutim, elementarnim transformacijama, polazni problem možemo da preformulišemo na sljedeći  problem linearnog programiranja: % ogranizenje |kx_i + l - y_i | <= z_i <=> dalje se svodi na dva ogranicenja...

$f(x) = c^T w$, pod uslovima
\begin{itemize}
    \item $ -w_i \leq k x_i + l - y_i$ 
    \item $ k x_i + l - y_i \leq w_i $
\end{itemize}
za sve $i = 1, \ldots, n$ gdje je 
$w_i = z_i, i=1,\ldots,n$, $w_{n+1} = k, w_{n+2} = l$, dok 
$c_i = 1, i=1,\ldots,n$, i $c_{n+1} = 0, c_{n+2} = 0$. 



 
Kada je riječ o linearnim programima,  oni imaju nekoliko osnovnih implicitnih pretpostavki. 
\begin{enumerate}
    \item \emph{Proporcionalnost.} Doprinos svake aktivnosti ciljnoj funkciji $f$ proporcionalan je njenom koeficijentu doprinosa, tj. $c_ix_i$. Doprinos svake aktivnosti svakom od  ograničenja u modelu proporcionalan je njenom  koeficijentu doprinosa, tj. $a_ix_i$.
    \item  \emph{Aditivnost.} Svaka funkcija u modelu je zbir  doprinosa pojedinih aktivnosti, npr. $f(x) = \sum_i a_i x_i$.
    \item \emph{Djeljivost}. Varijable odluke se mogu podijeliti na vrijednosti koje nisu cijele, uzimajući u obzir  razlomljene vrijednosti, dok god su ograničenja zadovoljena.  
    \item \emph{Sigurnost}. Pretpostavljamo da su vrijednosti parametara u modelu poznate
    sa nekom dozom sigurnosti ili se barem tako tretiraju. Dobijeno optimalno rješenje je optimalno za specifični formulisani problem. Ako su vrijednosti parametara pogrešne, tada rezultirajuće rješenje po pravilu ima malu (upotrebnu)  vrijednost.  
\end{enumerate}
%Ako model zadovoljava prethodne 4 pretpostavke, onda je riješ o modelu linearnog programiranja. 

\section{Teorija Linearnog Programiranja}
U ovom poglavlju ćemo formalno izvesti načine rješavanja linearnog problema. U osnovi, pokazaćemo da ako je problem
linearnog programiranja dopustiv i ograničen i postoje vrhovi, onda postoji i optimalno rješenje tog LP problema. Kako smo ranije neformalno pomenuli,  to rješenje se nalazi upravo u jednom od vrhova poliedra. 

Prije nego ovo formalno pokažemo, uvedimo nekoliko osnovnih definicija. 

\begin{definition}
  Za skup $S \in \mathbb{R}^n$ kažemo da je konveksan akko za sve $x,y\in S$ i $\lambda\in [0, 1]$ vrijedi $\lambda x + (1 - \lambda)y \in S$
\end{definition}
\begin{definition}
   Za funkciju $f:\mathbb{R}^n \mapsto \mathbb{R}$ kažemo da je konveksna akko 
   $$ f( \lambda x + (1-\lambda) y) \leq \lambda f(x) + (1 -\lambda) f(y),$$
   za svaki $x,y \in \mathbb{R}^n$ i svaki $\lambda \in [0,1].$
\end{definition}
Primijetimo da je svaka funkcija data u obliku $f(x_1, \ldots, x_n) = \sum_{i=1}^n c_i x_i$ za neke $c_i \in \mathbb{R}$, konveksna, što se direktno provjerava na osnovu definicije konveksnosti funkcije. Dakle, LP u svom opštem obliku  ima ciljnu funkciju koja je konveksna. Geometrijska interpretacija konveksnosti funkcije je prikazana na Slici~\ref{fig:convex_function}.

%\begin{figure}
%    \centering
%    \includegraphics[width=180pt,height=180pt]{convex_function.png}
%    \caption{Primjer konveksne funkcije}
%    \label{fig:convex_function}
%\end{figure}
\begin{figure}
   \centering
\begin{tikzpicture}
\begin{axis}[width=5in,axis equal image,
    axis lines=middle,
    xmin=0,xmax=8,
    xlabel=$x$,ylabel=$y$,
    ymin=-0.25,ymax=4,
    xtick={\empty},ytick={\empty}, axis on top
]

% 
\addplot[thick,domain=0.25:7,blue,name path = A]  {-x/3 + 2.75} coordinate[pos=0.4] (m) ;
\draw[thick,blue, name path =B] (0.15,4) .. controls (1,1) and (4,0) .. (6,2) node[pos=0.95, color=black, right]  {$f(x)$} coordinate[pos=0.075] (a1)  coordinate[pos=0.95] (a2);
\path [name intersections={of=A and B, by={a,b}}];

% 
\draw[densely dashed] (0,0) -| node[pos=0.5, color=black, label=below:$a$] {}(a1);
\draw[densely dashed] (0,0) -| node[pos=0.5, color=black, label=below:$x_{1}$] {}(a);
\draw[densely dashed, name path=D] (3,0) -|node[pos=0.5, color=black, label=below:$\lambda x_{1}+ (1-\lambda)x_{2}$] {} node[pos=1, fill,circle,inner sep=1pt] {}(m);
\draw[densely dashed] (0,0) -|node[pos=0.5, color=black, label=below:$x_{2}$] {}(b);
\draw[densely dashed] (0,0) -|node[pos=0.5, color=black, label=below:$b$] {}(a2);

% 
\path [name intersections={of=B and D, by={c}}] node[fill,circle,inner sep=1pt] at (c) {}; 

% 
\node[anchor=south west, text=black] (d) at (0.75,3) {$f[\lambda x_{1}+(1-\lambda)x_{2}]$};
\node[anchor=south west, text=black] (e) at (5,2.5) {$\lambda f(x_{1})+(1-\lambda)f(x_{2})$};
\draw[-{Latex[width=4pt,length=6pt]}, densely dashed] (d) -- (c);
\draw[-{Latex[width=4pt,length=6pt]}, densely dashed] (e) -- (m);
\end{axis}
\end{tikzpicture}
   \caption{Konveksna funkcija: geometrijska interpretacija.}
   \label{fig:convex_function}
\end{figure}

\begin{definition}
   Neka su dati vektori $z^i \in \mathbb{R}^n$,  te $\lambda_i \in [0,1]$ $i=1,\ldots,m$ tako da je $\sum_{i=1}^m \lambda_i = 1.$ Vektor $x =  \sum_{i=1}^m \lambda_i z^i$ se naziva konveksna kombinacija vektora $z^i$.
\end{definition}

Konveksne funkcije imaju lijepa svojstva sa stanovišta teorije i u kombinaciji sa konveksnim skupovima čine osnov  teorije optimalnosti. 

Inače, vrijedi sljedeća teorema.
\begin{thm}
  Neka je $f : S \mapsto \mathbb{R}$ konveksna funkcija definisana na konveksnom skupu $S \subseteq \mathbb{R}^n$. Ako funkcija $f$ u tački $x^* \in S$
 postiže lokalni minimum, onda je ta tačka predstavlja i tačku globalnog minimuma.
\end{thm}

\begin{comment}
\begin{proof}  
 Neka je $x^* \in S$ tačka lokalnog minimuma funkcije $f$. Prema tome, postoji $r >0$ za što vrijedi $f(x^*) \leq f(x)$, za sve $x \in S \cap K(x^*, r)$. Odaberimo vektor $x \neq x^* \in S$ i definišimo vektor 
 $z(\lambda) = \lambda x + (1 - \lambda) x^*$ za neki $\lambda \in [0, 1]$. Kako je $S$ konveksan, slijedi da je $z \in S$.  Definišimo $\lambda_0 <  \min\{1, r ||x - x^*||^{-1}\}$, $\lambda_0 \in (0, 1]$. Tada za svaki $\lambda \in (0, \lambda_0)$ vrijedi 
 \begin{equation}
     ||z(\lambda) - x^* ||  =  || \lambda ( x - x^*) ||  = \lambda ||x - x^* || \leq \lambda_0 ||x - x^* ||  \leq r.
 \end{equation}
 Dakle, pokazano je da je $z(\lambda) \in S \cap K(x^*, r)$. Prema tome, vrijedi 
 \begin{equation}
     f(x^*) \leq f(z(\lambda)) = \lambda f(x) + (1-\lambda) f(x^*) 
 \end{equation}
 odakle slijedi 
 \begin{equation}
      \lambda f(x^*) \leq   \lambda f(x) \Rightarrow f(x^*) \leq f(x),  
 \end{equation}
 za proizvoljno odabrano $x \in S$, čime smo pokazali teoremu. 
\end{proof}
% http://home.ku.edu.tr/~mturkay/indr262/Indr262LectureNotes_2-LPModels.pdf
% (Assumptions of Linear Programming)
\\
U sljedeće dvije definicije definišimo pojmove poliedra, hiperravni i poluprostora. 
\end{comment}
\begin{definition}
   Neka je $A \in \mathbb{R}^{m \times n}, b \in \mathbb{R}^m$. Skup $P=\{x \in \mathbb{R}^n \mid Ax \geq b\}$ se naziva poliedar u $\mathbb{R}^n$. 
\end{definition}
\begin{definition}
   Neka je $a\in \mathbb{R}^n $ i $b \in \mathbb{R}$. Skup $\{ x \in \mathbb{R}^n \mid a^T x = b \}$ se naziva hiperravan u $\mathbb{R}^n$ čiji je vektor  normale $a$, dok se $\{ x \in \mathbb{R}^n \mid a^T x \geq b \}$ naziva poluprostor. 
\end{definition}
Pokažimo sada da je poliedar konveksan skup. To je važna karakteristika jer se uslovima problema LP-a formira odgovarajući poliedar, a kako je on konveksan skup, prethodna teorema nam garantuje da, uz pretpostavku da postoji lokalni minimum (maksimum), postoji  i globalni minimum (maksimum), tj. optimalno rješenje zadanog problema LP-a.

\begin{prop}Vrijede sljedeće tvrdnje: \\
  ($i$)  Poluprostor u $\mathbb{R}^n$ je konveksan skup.  \\
  ($ii$) Presjek konačno mnogo konveksnih skupova je konveksan skup. 
\end{prop}

\begin{proof}
  ($i$) Neka je dat poluprostor $P = \{ x \in \mathbb{R}^n \mid a^T x \geq b \}$. Uzmimo $x, y \in P$, te neko $\lambda \in [0, 1]$. Treba da pokažemo da konveksna kombinacija ova dva vektora takođe pripada $P$. Iz $x \in P$, slijedi  $a^T x \geq b$. Takođe, kako je $y \in P$, to je  $a^T y \geq b$. 
  Sada jednostavno slijedi sljedeće:
  \begin{align}
      a^T (\lambda x) \geq \lambda b \\
      a^T ((1-\lambda) y) \geq (1-\lambda) b 
  \end{align}
  Sabirajući posljednje dvije nejednakosti, dobijamo 
  \begin{equation}
      a^T( \lambda x + (1 - \lambda) y ) \geq b,
  \end{equation}
  odakle slijedi da $\lambda x + (1-\lambda) y \in P$, odakle slijedi tvrdnja. 
  
  ($ii$) Neka su $S_1,\ldots, S_n$ konveksni skupovi. Ako $x,y \in \cap_{i=1}^n S_i$, onda slijedi da $x,y \in S_i$ za svaki $i=1,\ldots,n$. Zbog konveksnosti svakog od skupova,  
  $\lambda x + (1 - \lambda) y \in S_i$, za svaki $i=1,\ldots,n$. Prema tome, vrijedi $ \lambda x + (1-\lambda) y \in \cap_{i=1}^n S_i$, odakle slijedi da je $\cap_{i=1}^n S_i$ konveksan. 
\end{proof}

Iz prethodne teoreme slijedi sljedeća posljedica.

\begin{poslje}
Poliedar $P$ nekog problema LP-a je konveksan skup.	
\end{poslje}
 
\begin{proof}
  Definišimo $S_i:= \{ (x_1,\ldots, x_n) \in \mathbb{R}^n \mid c^T x \geq b_i \}$, za  $c = (a_{i,1}, \ldots, a_{i, n}),$  $ i=1,\ldots, m$. Kako je $\cap_{i=1}^m S_i$ poliedar koji odgovara problemu LP-a, na osnovu prethodne propozicije ($ii$), slijedi tvrdnja. 
\end{proof}



Nadalje, formalno definišimo ekstremne tačke, vrhove i bazna dopustiva rješenja koja su već ranije pomenuta u ne tako strogom obliku. 


\begin{definition}
   Neka je $P$ poliedar u $\mathbb{R}^n$.  Vektor $x \in P$ se naziva ekstremna tačka poliedra $P$
   ako ne postoje vektori $y, z \in P$, $y \neq x, z \neq x$ i skalar $\lambda \in [0, 1]$ takvi da je  $x = \lambda y + (1-\lambda)z$.
\end{definition}

 Drugim riječima, ekstremna tačka $x$ ne leži između neke dvije tačke $y,z$    poliedra $P$.
Možemo reći i ovako: One tačke koje se ne mogu napisati kao netrivijalna konveksna kombinacija tačaka iz poliedra čine skup ekstremnih tačaka. 
 
 
\begin{definition}
   Neka je dat poliedar $P$ u $\mathbb{R}^n$. Tačku $x \in P$ nazivamo vrh (poliedra) ako postoji linearna funkcija  $c^T x$ koja je strogo minimizovana u toj tački, tj. za sve  $y\in P, y \neq x$, vrijedi $c^T x < c^T y$. 
\end{definition}
Geometrijski posmatrano,  vrh poliedra $P$ je ona tačka poliedra  kroz koju možemo provući poluravan sa svojstvom da se sve tačke iz $P$ (izuzev vrha) nalaze sa iste strane te poluravni.

Uvedimo sada nekoliko novih pojmova koji će nam pomoći da definišemo bazno dopustivo rješenje.

\begin{definition}\label{dfn:lp_aktivan}
   Neka je poliedar $P$ zadan na sljedeći način
   \begin{itemize}
       \item $a_i^T x \geq b_i, i \in C_1$
       \item $a_i^T x = b_i, i \in C_2 $
       \item $a_i^T x \leq b_i, i \in C_3 $. 
   \end{itemize}
   Ako za neko $x^* \in P$ i neki $i_0 \in C_1 \cup C_1 \cup C_2$ vrijedi 
   $a_{i_0}^T x^* = b_{i_0}$, onda je indeks (ograničenje) $i_0$ aktivan u $x^*$. 
\end{definition}

\begin{definition}
      Neka je zadan poliedar iz Definicije~\ref{dfn:lp_aktivan}. Neka je 
      $I = \{ i \in C_1 \cup C_2 \cup C_3 \mid a_i^T x^* = b_i \}$  skup indeksa aktivnih u $x^*\in \mathbb{R}^n$.  Ako je skup $\{ a_i \mid i \in I \}$ linearno nezavisan onda se $x^*$  naziva bazno rješenje. 
\end{definition}
% https://faculty.math.illinois.edu/~mlavrov/docs/482-fall-2019/lecture8.pdf
\begin{definition}
	 Bazno dopustivo rješenje $x^*$ je bazno rješenje koje zadovoljava  uslove linearnog programa. 
\end{definition}
Pokažimo sada da su vrhovi, ekstremne tačke poliedra i bazna dopustiva rješenja predstavljaju istu stvar kada je riječ o LP-u.

\begin{thm}
   Neka je $P$ poliedar i neka je $x^* \in P$. Sljedeće tri tvrdnje su ekvivalentne:
   \begin{enumerate}
       \item $x^*$ je vrh poliedra;
       \item $x^*$ je ekstremna tačka poliedra;
       \item $x^*$ je bazno dopustivo rješenje (BDR).
   \end{enumerate}
\end{thm}

\begin{proof}
      Pokažimo da vrijedi $1 \Rightarrow 2, 2 \Rightarrow 3$, pa onda $3 \Rightarrow 1$, čime ćemo pokazati ekvivalenciju sve tri tvrdnje.
      
      $1 \Rightarrow 2$. Neka je $x^*$ vrh poliedra. Iz definicije slijedi da 
      postoji $c\in \mathbb{R}^n$ tako da $c^Tx^* < c^T x$, za sve $x \in P, x \neq x^*$. Pretpostavimo da $x^*$ nije ekstremna tačka poliedra $P$. 
      To bi značilo da postoje $y,z \in P$, koji su različiti od $x^*$, takvi da se $x^*$ može predstaviti kao njihova (netrivijalna) konveksna kombinacija, tj. $x^* = \lambda y + (1 - \lambda) z $, za neko $\lambda \in (0,1 )$. Na osnovu pretpostavke je $c^T x^* < c^T y$. Sada je 
      \begin{align}
          &c^T x^* = c^T ( \lambda y + (1 - \lambda) z )  = c^T( \lambda y) + c^T((1- \lambda) z) > \nonumber \\
          &>\lambda c^T x^* + ( 1 - \lambda) c^T x^* = c^T x^*.
      \end{align}
      što je nemoguće, odakle slijedi tvrdnja. \\
      $2 \Rightarrow 3$.
       Ovu implikaciju ćemo dokazati kontrapozicijom. Pretpostavimo da tačka $x^*$ nije BDR i pokažimo da iz toga slijedi da ona nije ni ekstremna tačka.
      Bez smanjenja opštosti, zapišimo poliedar $P$ sa 
       \begin{align}
            & a_i^T x \geq b_i, i \in C_1 \\
            & a_i^T x  = b_i, i \in C_2.
       \end{align}
       Ako $x^*$ nije BDR, to znači da je broj uslova koji su aktivni u $x^*$ manji od $n$. 
       Ako sa $I \subseteq C_1 \cup C_2$ označimo skup aktivnih indeksa u $x^*$, onda 
       je $\{ a_i \mid i \in I \} \subseteq \mathbb{R}^n$ pravi potprostor od $\mathbb{R}^n$.  Prema tome, postoji vektor $d \in \mathbb{R}^n \setminus \{0\}$ za koji vrijedi $a_i^T d = 0$, za sve $i \in I$. Definišimo vektore 
       $$ y = x^* + \epsilon d, z = x^* - \epsilon d, $$
       za neko $\epsilon > 0$, pa pokažimo da $y, z \in P$.
       
       Ako je $i \in I$, onda je $$a_i^T y = a_i^T (x^* + \epsilon d) = a_i^T x^* + \epsilon a_i^T d = a_i^T x^* = b_i. $$
       Pokažimo još da za $i \not \in I$ vrijedi $a_i^T x^* \geq b_i$, odakle bi slijedilo da $y \in P$. Dakle, $a_i^T y = a_i^T (x^* + \epsilon d) = a_i^T x^* + \epsilon a_i^T d $. Ako je $a_i^T d \geq 0$, slijedi da je 
       $a_i^T x^* > b_i$, odakle slijedi da je $y \in  P$. Ako je $a_i^T d < 0$, onda odaberimo takve $\epsilon$ za koje će vrijediti $a_i^T x^* + \epsilon a_i^T d > b_i$. Interval   vrijednosti za $\epsilon$ dobijemo iz sljedećeg računa:
       $$ a_i^T x^* + \epsilon a_i^T d > b_i \Rightarrow \epsilon < \frac{b_i - a_i^T x^*}{a_i^T d}  $$
       Za svaki $\epsilon \in (0,  \frac{b_i - a_i^T x^*}{a_i^T d} )$ vrijedi $a_i^T y > b_i$, odakle slijedi $y \in P$. Slično pokažemo i da vrijedi $z \in P$. 
       Prema tome lako je vidjeti da vrijedi $x^* = \frac{1}{2}y +\frac{1}{2} z$, dakle $x^*$ se dobija kao netrivijalna konveksna kombinacija, što je u suprotnosti sa definicijom ekstremne tačke. \\
       $3 \Rightarrow 1$. Neka je $x^*$ BDR. Treba da pokažemo da je ona takođe vrh poliedra $P$. Iz pretpostavke, za BDR, označimo sa $I$ skup aktivnih indeksa u $x^*$ i definišimo $c = \sum_{i \in I} a_i$.  Tada imamo 
       $ c^T x^* = \sum_{i \in I } a_i^T x^* = \sum_{i \in I} b_i$. Za proizvoljno $x \in P$ dobijamo
       \begin{equation}\label{eq:3_impl_1}
          c^T x = \sum_{i \in I} a_i^T x \geq c^T x^*  
       \end{equation}
     Iz toga vidimo da je $x^*$ rješenje LP problema minimizacije. Jednakost u (\ref{eq:3_impl_1}) vrijedi ako i samo ako je $a_i^T x = b_i$ za sve $i \in I$. Kako je $x^*$ BDR, broj linearno nezavisnih vektora $a_i, i \in I$ koji su  aktivni u $x^*$ je jednak $n$, pa sistem $a_i^T x = b_i, i \in I$ ima jedinstveno rješenje koje je upravo $x^*$. Prema tome, pokazano je da postoji vektor $c \in \mathbb{R}^n$ za koji vrijedi $c^T x > c^T x^*$ za sve $x \neq x^*$, $x \in P$, odake, na osnovu definicije vrha poliedra, slijedi tvrdnja. 
\end{proof}\\

U nastavku ćemo dati uslove koji treba da vrijede za postojanje BDR-a, tj. 
 ekstremne tačke poliedra. Takođe, daćemo i postupak za konstrukciju BDR-a, te ćemo uvesti pojam degenerativnog rješenja.

\begin{thm}
   Neka je $P = \{ x \in \mathbb{R}^n \mid A x = b, x \geq 0\}, A \in \mathbb{R}^{m \times n}, b \in \mathbb{R}^m$ i $rang(A)= m, m < n$.
   Vektor $x$ je bazno rješenje  akko je $A x = b$ i ako postoje indeksi $p_1,p_2,\ldots, p_m$ tako da vrijedi:
   \begin{enumerate}
       \item kolone $A_{p_1},\ldots, A_{p_m}$ su linearno nezavisne
       \item ako $i \notin \{p_1,\ldots, p_m\}$, onda $x_i = 0$.
   \end{enumerate}
   
\end{thm}
Iz prethodne teoreme zaključujemo da bismo  konstruisali bazno rješenje, sljedeći koraci se izvršavaju:
\begin{enumerate}
    \item Odaberemo $m$ linearno nezavisnih kolona $A_{p_1}, \ldots, A_{p_m}$ matrice $A$.
    %\item Postavimo $x_i = 0$, za sve $i \in \{p_1,\ldots, p_m \}$.
    \item Riješimo sistem $B x_B = b$, za $x_B = [x_{p_1}, \ldots, x_{p_m}]$ i $B= [A_{p_1}. \ldots, A_{p_m}]$
    \item Dodijelimo $$x = (x_1,\ldots, x_n):= \begin{cases}
    	          0, j  \not \in \{p_1,\ldots, p_m \} \\
    	         x_{p_i} = (x_B)_i, j \in \{ p_1,\ldots, p_m \}
    \end{cases},$$  čime dobijamo bazno rješenje. 
\end{enumerate}
Varijable $x_{p_1},\ldots, x_{p_m}$ nazivamo \emph{bazne varijable}, a vektore  $A_{p_1}, \ldots, A_{p_m}$ \emph{bazni vektori}, indekse $p_1,\ldots, p_m$ \emph{bazni indeksi}, dok matricu $B$ matrica baze. 


Definišimo sada pojam \emph{degenerativnog} rješenje i degenerativnog baznog rješenja. Pokazaćemo kako se na primjeru pronalazi bazno rješenje te kako izgleda degenerativno bazno rješenje.

\begin{definition}
      Neka je dat poliedar $P = \{ x \in \mathbb{R}^n \mid a_i^T x \geq b_i, x_i \geq 0, i=1,\ldots,m \}$. Za bazno rješenje $x^*\in \mathbb{R}^n$ kažemo da je degenerativno ako je više od $n$  ograničenja aktivno u $x^*$. 
      
\end{definition}

\begin{definition}
      Neka je $P = \{ x \in \mathbb{R}^n \mid A x = b, x \geq 0\}, A \in \mathbb{R}^{m \times n}, b \in \mathbb{R}^m$    i neka je $x$ bazno rješenje. Vektor $x$ nazivamo degenerativno bazno rješenje ako je više od $n-m$ komponenti u vektoru $x$   jednako 0.
\end{definition}
\emph{\textbf{Primjer.}} Zadajmo poliedar $P= \{ (x_1,x_2,x_3)^T \mid x_2 - x_1 = 0, x_1 + x_2 +   x_3 = 2, x_1,x_2,x_3 \geq 0 \}$.  Pronaći bazna dopustiva rješenja i odrediti jesu li ona degenerativna. \\

\emph{Rješenje.} Lako je vidjeti da je  
$A=\left (\begin{array}{ccc}
   -1  &  1 & 0  \\
   1  &  1 & 1 \\
\end{array} \right )$ te $b = [0\ 2]^T$. Prateći postupak konstrukcije baznog rješenja, pronađimo dve linearno nezavisne kolone matrice $A$, recimo prve dvije, odakle je matica $B=\left (\begin{array}{cc}
   -1  & 1    \\
   1  &  1   \\
\end{array} \right ) .$ Riješimo sistem jednačina (stavka 3), odakle je rješenje $x_B = [1\ 1]^T$, a krajnje rješenje je $x^* = [1\ 1\ 0]^T$. Kako je 
$x^*$ aktivan u sva tri uslova $x_2 - x_1 = 0, x_1 + x_2 +  x_3 = 2$ i $x_3 = 0$, rješenje je nedegenerativno bazno dopustivo rješenje.  Takođe, možemo odabrati drugu i treću kolonu matrice za bazne kolone (kao i prvu i treću), odakle bismo dobili rješenje $x^* = [0\ 0\ 2]^T$, aktivno u četiri uslova, pa smo dobili degenerativno bazno dopustivo rješenje. \\


U nastavku govorimo o egzistenciji optimalnog rješenja problema LP-a. U narednoj definiciji objašnjavamo pojam pravca u poliedru.

\begin{definition}
      Poliedar $P$ sadrži pravac akko postoji $x \in P$ i $d \in \mathbb{R}^n \setminus \{0\}$ tako da je $x + \lambda d \in P$, za sve $\lambda \in \mathbb{R}$. 
\end{definition}

Sljedeću teoremu, koja daje vezu između ekstremnih tačaka poliedra i dopustivih pravaca, navodimo bez dokaza.

\begin{thm}
   Neka je dat poliedar $P=\{ x \in \mathbb{R}^n  \mid a_i^T x \geq b_i, i=1,\ldots,m\} \neq \emptyset$. Tada su sljedeće tri tvrdnje ekvivalentne:
   \begin{itemize}
       \item  Poliedar $P$ ima barem jednu ekstremnu tačku.
       \item Poliedar $P$ ne sadrži pravac.
       \item Postoji $n$ linearno nezavisnih vektora  među kolonama matrice $A$. %, tj. među $a_i, i=1,\ldots,m$.
   \end{itemize}
\end{thm}

Sljedeća teorema nam daje dovoljan uslov za postojanje optimalnog rješenja koje je uvijek jedna od ekstremnih tačka poliedra (dopustivog regiona) problema linearnog programiranja.

\begin{thm}
   Neka je zadan problem LP-a sa funkcijom cilja $c^Tx$ koju je potrebno minimizovati na poliedru $P$. Pretpostavimo da za poliedar $P$ postoji barem jedna ekstremna tačka i da za dati problem postoji optimalno rješenje. Tada postoji i optimalno rješenje koje je ekstremna tačka poliedra $P$.
\end{thm}

\begin{proof}
         Sa $O^* \not = \emptyset$ označimo skup svih optimalnih rješenja LP problema nad poliedrom $P= \{ x \in \mathbb{R}^n \mid A x \geq b \}$ te neka je $c^T x^* = v$, za sve $x^* \in O^*$. Vidimo da je 
         $O^* = \{ x \in \mathbb{R}^n \mid A x \geq b_i, c^T x = v  \}$ je takođe poliedar, $O^* \subset P$. Prethodna teorema nam kaže da poliedar $P$ ne sadrži pravac. Iz toga zaključujemo da ni $O^*$ nema pravac, odakle slijedi da $O^*$ ima barem jednu ekstremnu tačku (stavka 1 prethodne teoreme), označimo je sa $q^*$. Pokažimo da je to ujedno i ekstremna tačka od $P$.  Ako bismo pretpostavili da $q^*$ nije ekstremna tačka poliedra $P$, po definiciji slijedi da postoje $y, z \in P$ tako da $q^* = \lambda y + ( 1 - \lambda ) z $, $y \neq q^*, z \neq q^*, \lambda \in [0, 1]$. Kako je $q^* \in O^*$, imamo 
         $$ v = c^T q^* = c^T (  \lambda y + ( 1 - \lambda ) z ) = \lambda 
        \underbrace{ c^T y}_{ \geq v} + ( 1 - \lambda ) \underbrace{c^T z}_{\geq v} \geq \lambda v + (1 - \lambda) v = v,$$
        odakle imamo $c^T y = v$ i $c^T z = v$, dakle $y, z \in O^*$. Prema tome, $q^*$ nije ekstremna tačka od $O^*$. Dakle, imamo kontradikciju, odakle zaključujemo da $q^*$ mora biti  ekstremna tačka od  $P$.
\end{proof}
 
 Ova važna tvrđenja nam daju osnov za konstrukciju simpleks metoda koji je, kao što smo već pomenuli, jedna od najpoznatijih i najefikasnijih generalnih metoda za rješavanje problema LP.
 
% \begin{thm}
 \emph{Posljedica.} Ako  rješavamo problem minimizacije LP-a na poliedru $P$ koji ima barem jednu ekstremnu tačku, tada vrijedi tačno jedna od sljedeće dvije tvrdnje:
   \begin{enumerate}
       \item Funkcija cilja ima vrijednost $- \infty$ (funkcija cilja je neograničena).
       \item Postoji ekstremna tačka u kojoj funkcija cilja dostiže optimalno rješenje. 
   \end{enumerate}
% \end{thm}
Kako ćemo vidjeti u narednom poglavlju, upravo  ove tvrdnje opravdavaju ideju simpleks metode, koja je bazirana na iterativnim posjećivanju vrhova poliedra 
u cilju pronalaska optimalnog rješenja.

\section{Neke tehnike u modelovanju problema Linearnog Programiranja}

\emph{Apsolutna funkcija}.   Pretpostavimo da imamo model dat sa 
\begin{align*}
	&\min \sum_{j \in J} c_j |x_j| \\
	& \sum_{j\in J} a_{ij} x_j \leq b_i, \forall i\in I \\
	& x_i \in \mathbb{R}, \forall i \in I.
\end{align*} 

Kao što znamo, apsolutna vrijednost nije linearna funkcija, ali se ovaj model može transformisati u model linearnog programiranja na sljedeći način: 
svaku slobodnu varijablu ćemo zapisati kao razliku dvije pozitivne varijable, tj.  $x_i = x_i^+ - x_i^-$, a apsolutnu vrijednost kao zbir dvije pozitivne varijable, tj. $|x_i|= x_i^+ + x_i^-$. Prema tome, prethodni model se transformiše  u 
\begin{align*}
	&\min \sum_{j \in J} c_j  (x_i^+ + x_i^-) \\
	&\sum_{j\in J} a_{ij} (  x_i^+ - x_i^- ) \leq b_i, \forall i\in I \\
	&  x_i^+, x_i^- \geq 0, \forall i \in I.
\end{align*}
Ostavljamo čitaocu da pokaže da ova dva modela imaju jednaka optimalna rješenja.

\emph{Min-max problem}. Neka je dat sljedeći model: 
\begin{align*}
	&\min_{x} \max_{k \in K} \sum_{j \in J} c_{kj} x_j \\
	&\mbox{s.t.} \nonumber \\
	& \sum_{j \in J} a_{ij} x_j \leq b_i\  \forall i \in I \\
	& x_j \geq 0\ \forall j \in J.
\end{align*}
Ovaj  model se transformiše u model LP-a uvodeći varijablu $$z=\max_{k \in K} \sum_{j \in J} a_{kj}x_j$$ koja označava maksimalnu cijenu. Ograničenja koja treba da budu dodana u početni model poslije smjene da bi ograničili vrijednost varijable $z$ su:
\begin{eqnarray}
	\sum_{j \in J} a_{kj} x_j \leq z\ \forall k \in K.
\end{eqnarray}
Kada se $z$ minimizuje, ova ograničenja osiguravaju da je $z$ veće ili jednako  $\sum_{j \in J} c_{kj}x_j$, za sve $k$. Optimalna vrijednost $z$ neće biti veća od maksimuma svih $\sum_{j \in J} c_{kj}x_j$, jer  $z$ minimizujemo. Prema tome, optimalna vrijednost varijable $z$ će težiti da bude što manja moguća i jednaka maksimalnoj cijeni nad skupom $K$. Prema tome, početni model se transformiše u:
\begin{align*}
	&\max z \\
	&\sum_{j \in J} a_{ij} x_j \leq b_i\  \forall i \in I \\ 
	& 	 \sum_{j \in J} a_{kj} x_j \leq z\ \forall k \in K \\
	& x \geq 0.
\end{align*}

\emph{Frakciona funkcija cilja}. Neka je dat sljedeći model:
\begin{align*}
	& \min \frac{\sum_{j \in J} c_j x_j + \alpha}{ \sum_{j \in J} d_j x_j + \beta} \\
	& \sum_{j \in J} a_{ij} x_j \leq b_i,  \forall i \in I \\
	& x_j \geq 0, \forall j \in J.
\end{align*}
Ovdje je funkcija cilja data kao količnik dvije linearne funkcije. Potrebno je transformisati ovu funkciju u linearnu da bismo imali linearni program. Ovakvi modeli su česta pojava u modelovanju financijskog planiranja. Pretpostavimo da je $\sum_{j \in J}d_j x_j + \beta \neq 0$ za sve tačke iz dopustivog regiona. Glavni trik u transformaciji je uvođenje nove varijable $y_j$ i $t$ tako da je $y_j = t x_j$. U nastavku, pretpostavljamo da je nazivnik u funkciji cilja pozitivan (slično je izvođenje i sa negativnim nazivnikom, s tim da imamo znak ``-'' ispred, što će promijeniti znak nejednakosti u ograničenjima krajnjeg modela). Dakle, uvedemo $t = \frac{1}{\sum_{j \in J} d_j x_j + \beta }$. Time dobijamo model
\begin{align*}
	&\min \sum_{j \in J} c_j x_j t + \alpha t \\
	&\sum_{j \in J} a_{ij} x_j \leq b_i,  \forall i \in I \\
	& \sum_{j \in J} d_j x_j t + \beta t = 1 \\
	& t > 0 \\
	& x \geq 0.
\end{align*}
Množeći prvo ograničenje sa $t>0$ te uvodeći smjenu $y_j = t x_j$, dobijamo (ekvivalentan)  model:
\begin{align*}
	&\min \sum_{j \in J} c_j y_j + \alpha t \\
	& \sum_{j \in J} a_{ij} y_j \leq b_i t,  \forall i \in I \\
	& \sum_{j \in J} d_j y_j + \beta t = 1 \\
	& t > 0 \\
	& x \geq 0.
\end{align*}
Na kraju, potrebno je dozvoliti da $t \geq 0$, da bi dobili LP model. 
Za optimalnu vrijednost varijable $t$ na kraju se provjeri da li je $t>0$.   \\
\emph{Domenske granice u ograničenjima}. Neka nam je dat model
\begin{align*}
	&\min_{j \in J } c_j x_j \\
	& l_i \leq \sum_{j \in J} a_{ij} x_j \leq u_i, \forall i\in I \\
	& x_j \geq 0, \forall j \in J.
\end{align*} 
Direktnom transformacijom dobijamo sljedeći LP (konjunkcija ograničenja): 
\begin{align*}
	& \min_{j \in J } c_j x_j \\
	&  l_i \leq \sum_{j \in J} a_{ij} x_j, \forall i\in I \\
	&  \sum_{j \in J} a_{ij} x_j \leq u_i, \forall i\in I \\
	&  x_j \geq 0, \forall j \in J.
\end{align*}
Kako    se $\sum_{j \in J} a_{ij} x_j$ javlja u dva ograničenja (što utiče na performanse rješavača), prethodni model se dalje transformiše na (efikasniji) LP model:
\begin{align*}
	&s_i + \sum_{j \in J} a_{ij} x_j = u_i, \forall i \in I \\
	& 0 \leq s_i \leq  u_i - l_i, \forall i \in I.
\end{align*}
Dakle, ako je $s_i = 0$, onda je  $\sum_{j \in J} a_{ij} x_j = u_i$, dok ako je  $s_i = u_i - l_i$, imamo da je $\sum_{j \in J} a_{ij} x_j = l_i$, $i\in I$. 

Konačno, dobijamo ekvivalentan LP model
\begin{align*}
	&\min_{j \in J } c_j x_j \\
	& \mbox{s.t.} \nonumber \\
	&s_i + \sum_{j \in J} a_{ij} x_j = u_i, \forall i \in I \\ 
	&  0 \leq s_i \leq  u_i - l_i, \forall i \in I \\
	& x_j \geq 0, \forall j \in J.
\end{align*}

\textbf{\Large Zadaci.}
\begin{enumerate}
	\item  Kompanija Healthy Pet Food Company proizvodi dvije vrste hrane za pse: Meaties i Yummies. Svako pakovanje Meaties hrane sadrži 2 kilograma žitarica i 3 kilograma mesa; svako pakovanje Yummies -a sadrži 3 kilograma žitarica i 1,5 kilograma mesa. Healthy vjeruje da može prodati onoliko hrane za pse koliko može napraviti. Meaty se prodaje   2,80 \$ po paketu, a Yummies   2,00 \$ po paketu. Proizvodnja kompanije Healthy ograničena je na nekoliko načina. Prvo, Healthy može kupiti samo do 400.000 kg žitarica svakog mjeseca za 0,20 \$ po kg; može
	kupiti samo do 300.000 kg mesa mjesečno za 0,50 \$ po kg. Osim toga, za proizvodnju Meatiesa potrebna je posebna mašina, a proizvodni kapacitet ove mašine je 90.000 paketa mjesečno. Varijabilni troškovi miješanja i pakovanja hrane za pse iznose 0,25 \$ po pakovanju za Meaties i 0,20 \$ po paketu za Yummies.  
	Pretpostavimo da ste vođa odjela hrane za pse  ove kompanije. Na koji način bi trebali upravljati odjelom proizvodnje kako bi maksimizirali   profit? 
	\item  Kompanija proizvodi velike industrijske ključeve za cijevi u jednoj od svojih fabrika. Odjel za marketing procjenjuje potražnju za ovim proizvodom u sljedećih 6
	mjeseci dat tabelom
 \begin{center}
    \begin{tabular}{lc}\hline
		 Januar  & 370 \\
		 Februar & 430 \\
		 Mart    & 380 \\
		 April   & 450 \\
		 Maj     & 520 \\
		 Jun     & 440 \\
		 \hline
	\end{tabular}  
\end{center}	
	
	Sa trenutnom radnom snagom, firma vjeruje da može proizvesti približno 420 ključeva za cijevi mjesečno po cijeni od 40 \$ po ključu koristeći redovnu proizvodnju. Dodatnih 80 ključeva mjesečno može se izraditi prekovremenom proizvodnjom po cijeni od 45 \$ po ključu .
	Ključevi se mogu napraviti unaprijed i držati u zalihama za kasniju isporuku po cijeni od 3 \$ mjesečno po ključu. Mjesečna potražnja za ključevima mora biti zadovoljena svakog mjeseca. Pred kraj decembra (početak januara) firma ima 10 ključeva u inventaru. Ona 
	želi planirati svoju proizvodnju, uključujući prekovremeni rad i zalihe za sljedećih 6 mjeseci, kako bi povećala profit. Pod pretpostavkom da je prihod od ovih ključeva stalan, uprava proizvodnje  će povećati  profit minimiziranjem ukupnih troškova nastalih u proizvodnji i isporuci ključeva.
	\item %https://www.utc.fr/~dnace/dokuwiki/_media/fr/upt-cours-2012lp.pdf
	(Varijacija prethodnog problema.) Kompanija proizvodi prenosne računare. Predviđanja prodaje (u hiljadama jedinica) za narednih četiri mjeseci prikazana su u sljedećoj tabeli. 
\begin{center}
	\begin{tabular}{lc}\hline
		Januar  & 30 \\
		Februar & 15 \\
		Mart    & 15 \\
		April   & 25 \\
		\hline
	\end{tabular}  
\end{center}	
	
	Proizvodni kapacitet kompanije je 30000 mjesečno. Moguće je proizvesti više po višoj cijeni, ali se plaća 300 \$ po komadu umjesto 250 \$. Na lageru je 2000 laptopa. Troškovi skladištenja su 25 \$ po jedinici za ono što ostaje na zalihama na kraju mjeseca. Pretpostavljamo da su skladišni kapaciteti neograničeni. Počinjemo 1. januara. Kakav je plan proizvodnje za sljedećih četiri mjeseca tako da se zadovolje svi zahtjevi, a troškovi svedu na minimum. 
	%http://people.brunel.ac.uk/~mastjjb/jeb/or/lpmore.html
	\item Teretni avion ima tri odjeljka za skladištenje tereta: prednji, središnji i stražnji. Ovi odjeljci imaju sljedeća ograničenja po težini i po prostoru: 
\begin{table}[!ht]
	\centering
	\begin{tabular}{lcc}
	   Odjeljak   & Težinski kapacitet & Prostorni kapacitet \\ \hline
	   Prednji    & 10                 & 6800                 \\ 
	   Središnji  & 16                 & 8700                 \\
	   Stražnji   &  8                 & 5300                 \\ \hline
 	\end{tabular}
\end{table}
	
Osim toga, težina tereta u odgovarajućim pregradama moraju biti istog udjela  kapaciteta težina onog dijela da bi se održala ravnoteža aviona. Sljedeća četiri utovara su dostupna za isporuku na sljedeći let: 
	
\begin{table}[!ht]
	 \centering	
	\begin{tabular}{cccc}
	    Teret & Težina & Zapremina & Profit \\ \hline
	    $C_1$  & 18     & 480       & 310    \\
	    $C_2$  & 15     & 650       & 380    \\
	    $C_3$  & 23     & 580       & 350    \\
	    $C_4$  & 12     & 390       & 285    \\ \hline
	\end{tabular}
\end{table}
Bilo koji dio ovih tereta se može   prihvatiti. Cilj je utvrditi koliko (ako postoji i jedan) svakog tereta $C_1$, $C_2$, $C_3$ i $C_4$ treba prihvatiti i kako ga rasporediti po odjeljcima da bi ukupna dobit na letu bila maksimalna. \\
Uputstvo. Definisati varijable odluke $x_{i,j}$ kao broj (tona) tereta $i$   (za $C_i, i=1, \ldots,4$,  respektivno) koji je stavljen  u odjeljak $j$, $j=1,2,3$ (prednji, središnji, stražnji).  % http://people.brunel.ac.uk/~mastjjb/jeb/or/lpmore.html 
\item Kompanija proizvodi četiri proizvoda ($1,2,3,4$) na dvije mašine ($X$ i $Y$). Vrijeme (u minutama) za obradu jedinice svakog proizvoda na svakoj mašini prikazano je ispod: 
\begin{table}[!ht]
	\centering	
	\begin{tabular}{ccc}
		Proizvod   & Mašina $X$ & Mašina $Y$ \\ \hline
		1          & 10         & 27         \\
		2          & 12         & 19         \\
		3          & 13         & 33         \\
		4          & 8          & 23         \\ \hline
	\end{tabular}
\end{table}	\\
Profit po jedinici proizvoda za proizvod $i=1,2,3,4$, su 10, 12, 17 i 8 \$, respektivno. Proizvod 1 mora biti proizveden na obje mašine $X$ i $Y$ ali ostali proizvodi  mogu biti proizvedeni na bilo kojoj mašini. 

Tvornica je vrlo mala i to znači da je podni prostor vrlo ograničen. Proizvodnja na nivou sedmice se skladišti na $50 m^2$ podne površine pri čemu svaki proizvod zauzima 0.1, 0.15, 0.5 i 0.05 (kvadratnih metara) proizvoda $1, 2, 3$ i $4$,  respektivno. 

Zahtjevi kupaca su da količina proizvedenog proizvoda 3 treba biti povezana s količinom proizvedenog proizvoda 2. Preciznije, tokom sedmice trebalo bi se proizvesti približno dvostruko više jedinica proizvoda 2 nego proizvoda 3. Mašina $X$ je van pogona (zbog održavanja/zbog kvara) 5\% vremena, a za mašinu $Y$ je to 7\% vremena.
Pretpostavljajući radnu sedmicu dugu 35 sati, formulišite model proizvodnje ovih proizvoda kao linearni program da bi se maksimizovao profit. \\

Uputstvo. Varijable odluke se tiču količine proizvoda $i$ koje se proizvode na svakoj od mašina.  Dakle, 
varijabla $x_i$ označava broj proizvoda $i$ proizvedeni na sedmičnom nivou na mašini $X$, dok je $y_j$ --   broj proizvoda $j$ proizvedeni na sedmičnom nivou na mašini $Y$, $i \in \{1,2,3,4\}$, $j \in \{2,3,4\}$. Varijablu $y_1$ ne definišemo jer se proizvod 1 izvršava na obje mašine.  

	\item Grafičkom metodom riješiti sljedeći problem
	\begin{align*}
		&\max   x + 2 y \\
		& s.t. \\
		& x \leq 10 \\
		& 2 x + y\geq 0 \\
		& x,y \geq 0.
	\end{align*}
	\item Grafičkom metodom riješiti sljedeći problem 
	\begin{align*}
		& \max  8 x + y \\
		& s.t. \\
		&  x + y \leq 40 \\
		& 2x + y \leq 60 \\
		& x,y \geq 0.
	\end{align*}
\\

\item Neka je dat poliedar $P= \{ (x_1,x_2,x_3, x_4)^T \in \mathbb{R}^4 \mid x_2 - x_1 = 0, x_4 - x_3 = 0,  x_1 + x_2 +   x_3 + x_4 = 2, x_1,x_2,x_3, x_4 \geq 0 \}$.  Pronaći bazna dopustiva rješenja i odrediti jesu li ona degenerativna.  
  
\end{enumerate}



\newpage 
\chapter{Simpleks Metod}

Simpleks metoda je jedna od najpoznatijih metoda za rješavanje problema linearnog programiranja. Simpleks metoda traži rješenje LP-a posjećujući vrhove dopustivog regiona problema pretražujući njegove vrhove uvijek u smijeru smanjenja vrijednosti funkcije cilja (ako je dat zadatak minimizacije). Razvio ju je George Dantzig 1947. godine i spada među najznačajnije algoritme XX vijeka.

Neka je dat problem LP-a u kanonskom obliku:

\begin{align}
    &c^Tx \rightarrow \min \nonumber \\ 
    & A x = b \nonumber \\
     & x \geq 0, \label{eq:lp_equality_constraint}
\end{align}
gdje je $A \in \mathbb{R}^{m \times n}, b \in \mathbb{R}^m, c \in \mathbb{R}^n, x\in \mathbb{R}^n$ uz pretpostavku da je poliedar $P=\{ x \in \mathbb{R}^n \mid A x = b , x \geq 0 \}$ datog problema LP-a dopustiv.  U ovom poglavlju, osim ako drugačije nije naznačeno, strogo ćemo poštovati ovu notaciju. 

%\begin{definition}
%      Za matricu A kažemo da je regularna akko postoji matrica B td. AB = BA = I. 
%\end{definition}

\begin{definition}
      Za pravac $d\in \mathbb{R}^n$ kažemo da je dopustiv pravac u vektoru $x \in P$ akko postoji $\lambda > 0$ tako da $x + \lambda d \in P$.
\end{definition}

\section{Konstrukcija simpleks metode}

 Neka je $x = [x_1,\ldots, x_n]^T$ bazno dopustivo rješenje problema (\ref{eq:lp_equality_constraint}), gdje je $B$ matrica baze, $x_B$ bazni dio vektora $x$, a gdje su na mjesto nebaznih indeksa $N$ postavljene 0.  Ideja simpleks metode je  ``šetanje'' po vrhovima poliedra  dok ne nađemo optimalno rješenje. Krenimo pravcem $d$ u  početnom BDR $x$  pri čemu trebamo obratiti  pažnju na to da je zadovoljen
\begin{itemize}
    \item \emph{uslov optimalnosti}, tj. $c^T (x + \lambda d) \leq c^T x, \lambda>0$, što znači da idemo u pravcu smanjenja vrijednosti funkcije cilja;
    \item \emph{uslov dopustivosti}, treba da je pravac $d$ dopustiv u tački $x$, tj. $ (x + \lambda d) \in P$, za neko $\lambda>0$. Dakle, uvijek se krećemo samo tačkama dopustivog regiona. 
\end{itemize}
Birajmo neku nebaznu koordinatu u $x$; neka je to $x_j, j \in N$. Definišemo $d=(d_B,  d_N)$, gdje su koordinate od (nebaznog dijela) $d_N$ svugdje 0, osim na koordinati $j$ za koju je postavljena vrijednost 1.   Bazni dio vektora $d$, koji je označen sa $d_B$, izvešćemo iz uslova dopustivosti i pretpostavke da ``šetamo'' pravcem koji se poklapa sa granicom dopustivog regiona, tj. poliedra $P$: $Ax + \lambda Ad = b$, odakle je $Ad = 0$. Tada vrijedi
$$ Ad = \sum_{i=1}^n A_i d_i = \sum_{i=1}^m A_{p_i} d_i + A_j = B d_B + A_j = 0$$ za one koordinate $p_i$ koje pripadaju baznom dijelu, 
odakle je $d_B = -  B^{-1} \cdot A_j $.  Za ovako odabran $d$ imamo zadovoljen uslov dopustivosti za ograničenje $A( x + \lambda d )  =b$. Posmatrajmo sada ograničenje nenegativnosti, tj. da li je zadovoljeno $x + \lambda d \geq 0$:
\begin{itemize}
    \item Ako je $x$ nedegenerativno, onda je tačno $n-m$ komponenti jednako 0,       pa je za nebazni dio komponenti $x_i + \lambda d_i = 0$, za $i \in N \setminus \{j\}$, dok je $x_j + \lambda d_j = 0$, pa imamo ispunjen uslov nenegativnosti. Za bazne komponente imamo $x_{p_i} \cdot d_{p_i} > 0 $ ako je $d_{p_i}>0$. U protivnom, možemo odabrati  malu vrijednost  $\lambda>0$ (pogledati definiciju dopustivog pravca $x +\lambda d$) tako da $x_{p_i} \cdot d_{p_i} >0$, pa imam zadovoljen uslov nenegativnosti.
    \item Ako je $x$ degenerativno bazno dopustivo rješenje, slijedi da više od $n-m$ kompomenti od $x$ je jednako 0. Za nebazni slučaj kao i u prvom slučaju pokazujemo uslov nenegativnosti. Tada za bazne kompomenete vektora $x +\lambda d$  postoji bazni indeks $i$ za koji je $x_{p_i} = 0$, pa ako bi bilo $d_{p_i}< 0$, to bi slijedilo da ne postoji $\lambda>0$ tako da $x_{p_i} + \lambda d_{p_i} >0$  što stvara problem (dopustivost narušena). Pojava ovog slučaja se na sreću može zaobići primjenom određenih pravila izbora nove bazne koordinate (pokazaćemo to u nastavku ove sekcije). 
\end{itemize}
 Ostaje nam pitanje odabira nebazne varijable $x_j$. U pomoć pozivamo uslov optimalnosti $c^T ( x + \lambda d ) < c^T x $, odakle slijedi $c^T d < 0$.  Dakle, $$c^T d = c_B^T d_B + c_j = c^T ( - B^{-1} A_j ) + c_j < 0.$$
 Prema tome, odaberimo (nebazni) indeks $j$ pri čemu je zadovoljeno $ \overline{c_j} = c_j - c_B^T B^{-1}A_j < 0$. Vektor $\overline{c}=[\overline{c_1}, \ldots, \overline{c_n}]^T$ se naziva \emph{vektor doprinosa}, dok vrijednost $\overline{c_j}$ \emph{doprinos nebazne varijable} $x_j$. 
 
Iz sljedeće teoreme dobijamo uslove optimalnosti rješenja.

\begin{thm}
  Neka je x bazno dopustivo rješenje i neka je $B$ bazna matrica a $\overline{c}$ vektor doprinosa. Tada vrijedi sljedeće
  \begin{itemize}
      \item Ako je $\overline{c} >0$, onda je $x$ optimalno rješenje.
      \item Ako je x optimalno nedegenerativno rješenje, onda je $\overline{c} \geq 0$.
  \end{itemize}
\end{thm}

Ostalo nam je još odrediti dužinu   pravca $d$, tj. vrijednost $\lambda>0$. Ideja je da se krene nekim smjerom dok god se ne dođe do drugog vrha, tj. treba odrediti dužinu vektora $d$ koji je jednak $\max \{ \lambda \in \mathbb{R} \mid x + \lambda d \geq 0 \}$. Razlikujemo sljedeća dva slučaja:
\begin{itemize}
    \item Ako $d >0$, onda je $  x + \lambda d \geq 0$, za sve $\lambda > 0$, pa je $\lambda^* = \infty$, tj. ciljna funkcija je neograničena.
    \item Ako postoji $i$, td. $d_i < 0$, onda za dovoljno malo $\lambda>0$ tako da $x_i + \lambda d_i \geq 0$ dobijamo $\lambda \leq -\frac{x_i}{d_i}$. Prema tome 
    $$ \lambda^* = \min_{ \{i\in [m] \mid d_{p_i} < 0  \}} - \frac{x_{p_i}}{d_{p_i}} $$
\end{itemize}
Za indeks $l$ za koji se postiže ovaj minimum, vrijedi $x_{p_l} + \lambda^* d_{p_l}=0$.
Da je ovo upravo bazno dopustivo rješenje problema, govori nam sljedeća teorema. 
\begin{thm}
    Kolone $A_{p_i}, i\not = l$, $i=1,\ldots,m$ i $A_{j}$ su linearno nezavisne, pa je matrica 
    $[A_{p_1},\ldots, A_{p_{l-1}}, A_j, A_{p_{l+1}}, \ldots, A_{p_m}]$
    regularna. Vektor $x + \lambda^* d$ predstavlja bazno dopustivo rješenje. 
\end{thm}

Navedimo sada osnovne korake jedne iteracije simpleks metoda:
\begin{enumerate}
    \item Inicijalizacija: za bazne indekse $p_1,\ldots,p_m \in [n]$, riješiti sistem i dobiti bazno dopustivo rješenje $x$. 
    \item Izračunati doprinos za sve $\overline{c_j} = c_j - c_B^T B^{-1}A_j $
          $j \in N$. Ako za sve $j$, $\overline{c_j} \geq 0$, optimum je nađen, algoritam staje sa radom. Inače, odabrati neki $j$  td. $\overline{c_j}<0$.
    \item Izračunati $d = -B^{-1}A_j = -u$. Ako je svaki $d_i \geq  0$, funkcija cilja je $f = - \infty$, te algoritam staje. 
    \item Ako je za neki $i$, $d_i < 0$, onda računamo 
             $$ \lambda^* = \min_{ \{i\in [m] \mid d_{p_i} < 0  \}} - \frac{x_{p_i}}{d_{p_i}} =  \min_{ \{i\in [m] \mid u_{p_i} < 0  \}} \frac{x_{p_i}}{u_{p_i}} $$
    \item Neka je $\lambda^* = \frac{x_{p_i}}{u_{p_i}}$. Nova baza se formira tako da mjesto kolone $A_{p_l}$ stavimo kolonu $A_j$. Novo bazno rješenje 
    $y = x + \lambda^*d $ je dato: $y_j = \lambda$, $y_{p_i} = x_{p_i} + \lambda^* d_{p_i}$, za $i$ koji je bazni indeks, te $y_i = 0$, za $i \in N \setminus \{j\}$. 
\end{enumerate}

\begin{figure}[!ht]
	\centering
   \includegraphics[scale=1.5]{simpleks_move.eps}\vspace{-2cm}
    \caption{Iteracije simpleks metode (vizuelizacija).}
    \label{fig:simpleks-visuelisation}
\end{figure}

\section{Tabelarni oblik Simpleks Metode}

U osnovi, simpleks algoritam se sastoji od stalne izmjene jedne kolone baze $B$ sa nekim nebaznim vektorom u iterativnoj šemi u cilju smanjenja trenutne vrijednosti cilje funkcije, dok god je to moguće. 
U praktičnom računanju, rad sa tabelarnim prikazom koraka simpleks metoda je u mnogome lakše (kompaktnije i prirodnije) nego koristiti standardan oblik LP-a. 
Tabelarni simpleks prikaz se može vidjeti u Tabeli~\ref{tab:simplex_tabelau}. 

\begin{table}[!ht]
    \centering
    \begin{tabular}{c c c | c} \\ \hline
            $\mid$          &       $\mid$ &  $\mid$             &    $x_{p_1} = \overline{b_1}$         \\
          $B^{-1}A_1$       &    $\cdots$    &  $B^{-1}A_n$      &    $\cdots$          \\
            $\mid$          &       $\mid$ &  $\mid$             &   $ x_{p_m} = \overline{b_m}$         \\ \hline
          $\overline{c_1}$  &    $\cdots$    & $\overline{c_n}$  &  $-c^T_B x_B$         \\ \hline
    \end{tabular}
    \caption{Simpleks tabela}
    \label{tab:simplex_tabelau}
\end{table}

Na osnovu ovakve tabele, te koraka simpleks metode opisanih u prethodnoj sekciji, sljedeći koraci se izvršavaju u tabelarnoj simpleks formi:
\begin{itemize}
    \item Konstruisati inicijalnu simpleks tabelu sa početnom bazom $B$ i odgovarajuće bazno dopustivo rješenje $x$.
    \item Posmatrati koeficijente doprinosa $\overline{c_j}$ (posljednja vrsta tabele). Ako su svi $\overline{c_j} \geq 0$, rješenje se ne može dalje popraviti, pa je nađeno optimalno rješenje. U protivnom, odabrati neki indeks $j$ za koji je $\overline{c_j}<0$.
    \item Posmatrati vektor (kolonu) $u = B^{-1}A_j$. Ako su sve koordinate vektora $u$ negativne, rješenje LP-a je $-\infty$, algoritam se prekida.
    \item Za svaki $u_i > 0$, računati $x_{p_i}/u_i$, i neka je   omjer najmanji za indeks $l$. Kolona $A_{j}$ ulazi u bazu, dok kolona $A_{p_l}$ izlazi iz baze. 
    \item Svakom redu simpleks tabele dodati $l$--ti red (pivot red) kojeg množimo odgovarajućim
         skalarom da bi pivot element postao 1 na kraju, a svi ostali elementi u pivot koloni budu 0.
\end{itemize}

U ovom postupku  može se desiti situacija da postoji dva ili više redova koji su kandidati za ulazak u bazu. Ako se odabere nepovoljan kandidat, postupak može da proizvede degenerativno BDR ili čak da dođe do ciklusa. 
Da bi se to spriječilo, Robert Bland (1977. godine) je uveo pravilo za pivotiranje danas poznato pod
nazivom \emph{Blandovo pravilo} koje:
\begin{enumerate}
	\item   Među svim nebaznim varijablama koje su pogodne za ulazak u bazu odaberemo onu najmanjeg indeksa. 
    \item Među svim baznim varijablama koje su pogodne za izbacivanje iz baze odaberemo onu sa najmanjim indeksom.
\end{enumerate}
Može se pokazati da poštujući ovakva pravila, osigurava se da simpleks metoda  završava u konačno mnogo koraka. Blandovo pravilo nije jedino pravilo za izbjegavanje ciklusa, postoji i leksikografsko pravilo pivotiranja kojeg ne objašnjavamo ovdje.  

Obratimo pažnju da se problem minimizacije vrlo lako prevodi u problem maksimizacije sljedećom transformacijom
$$ \min_{ x \in P} f(x) = - \max_{x \in P}(-f(x)).$$ 
Prema tome, ako imamo problem LP-a gdje treba da maksimizujemo vrijednost funkcije cilja, pa onda primijenimo simpleks metod, koraci metoda ostaju isti, uz malu izmijenu u koraku 2, gdje se mijenja znak nejednakosti (jer se mijenja znak koeficijenata u funkciji cilja).  Takođe, posmatraju se doprinosi za koje je $\overline{c_j} > 0$.

\section{Primjena Simpleks Metode}
%Kako je standardni poliedar LP-a dat sa svim onim $x \in \mathbb{R}^n$ tako da $Ax \leq (\geq) b$, 
Prvo transformišimo standardni oblik problema LP
 
  \begin{align*}
    & c^T x \rightarrow \max \\
    & \mbox{s.t} \nonumber \\
    & Ax \leq b \\
    & x \geq 0\\
\end{align*}
 
na kanonski oblik pogodan simpleks metodi $(A {x} = b)$ dodavanjem ``izjednačavajućih'' varijabli $s$ na sljedeći način:
 
\begin{align}
    & c^T x \rightarrow \max \\
    & Ax + s =  b \\
    & x \geq 0, s \geq 0. \\
\end{align}
što u matričnom obliku odgovara 

\begin{align}
    & c^T x \rightarrow \max \\
    & (A | I) \cdot \left (\begin{array}{c}
         x  \\
         s 
    \end{array} \right ) =  b \\
    & (x, s) \geq 0. \\
\end{align} 

U primjeru kojeg rješavamo, neka je dat problem LP-a:
\begin{align*}
    &f= x_1 + x_2 \rightarrow \max \nonumber \\
    & x_1 + 3 x_2 \leq 9 \nonumber \\
    & 2x_1 + x_2 \leq 8  \nonumber \\
    & x_1, x_2 \geq 0. \nonumber \\
\end{align*}
 
 Pretvorimo ga u kanonski oblik dodavajući izjednačavajuće varijable $s = (s_1, s_2)>0$, pa dobijamo 

\begin{align*}
    & x_1    & + 3x_2  &+ s_1& &= 9 \\
    & 2 x_1 &   + x_2  & + s_2& &= 8 \\
    & x_1   &   + x_2  &\  & &= f - 0 \\
\end{align*}
 Ovaj problem odgovara simpleks tabeli \\
 \begin{table}[H]
     \centering
     \begin{tabular}{c c c c | c}
     	 $x_1$ & $x_2$ &  $s_1$ & $s_2$ & \\ \hline
         1 &  3  & 1 & 0 & 9 \\
         2 &  1  & 0 & 1 & 8 \\ \hline
         1 &  1  & 0  & 0 & 0 \\ \hline
     \end{tabular}
     \caption{Inicijalna simpleks tabela.}
     \label{tab:simpleks_tabela1}
 \end{table} 
 Na početku uzmemo za bazu vektore $s_1$ i $s_2$. Prema tome, bazno dopustivo rješenje je $x = (0, 0, 9, 8)$, za koji je $f =0$. Sada ažiriramo simpleks tabelu izvodeći pivotiranje. Izaberimo indeks $j$ td. $\overline{c_j}>0$. Neka je $j=1$, što odgovara varijabli $x_1$ čiji doprinos želimo da povećamo (jer maksimizujemo) u funkciji cilja. Izaberimo pivot vrstu tako što posmatramo odnos $\overline{b_i}/\overline{a}_{1,j}$, za sve $\overline{a}_{1,j} > 0$,  $B^{-1} A_1 = \overline{a}_{1,j}$
 i tražimo onaj indeks koji minimizuje datu vrijednost. Imamo dvije mogućnosti, $9/1$ i $8/2$, pa dobijamo da je $i = 2$ traženi indeks. Prema tome, pivot je dat elementom $\overline{a}_{1,2}=2$. Sada radimo standardne operacije pivotiranja oko ovog elementa,  tako da sve elemente u koloni 1 simpleks matrice načinimo nulama, dok element u drugoj vrsti postaje 1 (Gausove eliminacije u rješavanju sistema jednačina). Primjera radi, vrsti 1 se dodaje druga vrsta pomnožena sa -$\frac{1}{2}$. Druga vrsta se dijeli sa $\frac{1}{2}$. Dok trećoj vrsti se dodaje takođe druga vrsta pomnožena sa -$\frac{1}{2}$. 
 Primjenjujući ove transformacije, dobijamo simpleks tabelu:
 
  \begin{table}[!ht]
     \centering
     \begin{tabular}{c c c c | c}
         0 &  $\frac{5}{2}$  & 1 & -$\frac{1}{2} $& 5 \\
         1 &  $\frac{1}{2}$ & 0 & $\frac{1}{2}$ & 4 \\ \hline
         0 &  $\frac{1}{2}$ & 0 & -$\frac{1}{2}$ & -4 \\ \hline
     \end{tabular}
     \caption{Simpleks tabela: nakon transformacija.}
     \label{tab:simpleks_tabela2}
 \end{table}
Bazne varijable prepoznjemo jer odgovarajući vektori (kolone) zajedno čine jediničnu matricu. Prema tome, 
 nebazne varijable su $x_2$ i $s_2$, koje dobijaju vrijednost 0, dok ostale lako izračunavamo, odakle je $ x = (4, 0, 5, 0)$. Ponavljamo prethodne korake sa novom simpleks tabelom, nalazimo pivot, tj. poziciju  $(i,j)$. Lako je vidjeti da kolona 2 jedina odgovara nalasku odgovarajućeg pivot elementa. Dalje, za pogodnu vrstu $i$, imamo da je $5 / (5/2) < 4 / (1/2)$, prema tome $i =1$. Dakle, pivot je 
 $\overline{a}_{1,2} = \frac{5}{2}$. Radimo ponovo Gausove eliminacije oko prve vrste, pa se dobija simpleks tabela:
 
   \begin{table}[!ht]
     \centering
     \begin{tabular}{c c c c | c}
         0 &  $1$  & $\frac{2}{5}$             &  -$\frac{1}{5} $ & 2 \\
         1 &  0    &      -$\frac{1}{5}$    & $\frac{3}{5}$    & 3 \\ \hline
         0 &  0    &   -$\frac{1}{5}$       &   -$\frac{2}{5}$   & -5 \\ \hline
     \end{tabular}
     \caption{Simpleks tabela: korak 2.}
     \label{tab:simpleks_tabela3}
 \end{table}
 Kako su sve varijable doprinosa manje (ili jednakom) 0, zaključujemo da smo našli optimum koji je jednak $x = (3, 2, 0, 0)$, a optimalna vrijednost je $f = 5$.
 
 \begin{figure}[!ht]
     \centering
     \includegraphics[width=170pt, height=170pt]{simpleks-region-2.eps}
     \caption{Region (bazna rješenja označena).}
     \label{fig:simplex_region} 
 \end{figure}
 
 \emph{Komentari na zadatak}. Na Slici~\ref{fig:simplex_region}, tačke $A, B, C$, i $D$ su bazna dopustva rješenja (BDR). Tačke $E$ i $F$ su takođe bazna rješenja, ali nisu dopustiva. Simpleks algoritam prvo kreće od tačke $A$ prema tački $D$, te završava u tački $C$ (optimum).
 
 \emph{Komentari na simpleks tabelu}:
 \begin{itemize}
     \item Jedinična matrica $m \times m$   ugrađena u gornju lijevu podmatricu simpleks tabele (blok sa elementima $\overline{a}_{i,j}$) sadrži kolone koji čine vektore baznih varijabli.
     \item U odgovarajućim kolonama u posljednjoj vrsti (ciljna vrsta) se nalaze nule.
 \end{itemize}
 Prema tome, vektori $x_i$, koji su bazni vektori (kolone baze $B$), su napisani preko nebaznih vektora $x_i \in N$. Kako se stavljaju $x_i  = 0$, za sve $i \in N$, onda se  vrijednosti baznih vektora $x_i$, tj. kolona baze $B$, mogu trivijano dobiti.
 \vspace{1cm}\\
 \emph{\textbf{Primjer.}} Navedimo primjer jednog linearnog programa koji je neograničen, te ga riješimo simpleks metodom. 
  Neka je dat problem LP-a:
  \begin{align*}
  	  &\max -x + 3y \\
  	  & \mbox{s.t} \nonumber \\
  	  & -x + y \leq 3 \\
  	  & x - 2y \leq 2 
  \end{align*}
 Prevedimo problem na kanonski oblik, dodavanjem izjednačavajućih varijabli, pa imamo 
 \begin{align*}
      &\max -x + 3y \\
     & -x + y + s_1 = 3 \\
     & x - 2y + s_2 = 2  
 \end{align*}
Ovom programu odgovara simpleks tabela:
$$\begin{array}{cccc| c} 
	   -1 & 1  & 1 & 0 & 3 \\
	    1 & -2 & 0 & 1 & 2 \\ \hline
	   -1 & 3  & 0 & 0 & 0  
\end{array}$$
Kako minimizujemo,  kolona 2 je ona u kojoj tražimo pivota. Pivot je element 
$\overline{a}_{1, 2} = 1$, odakle pivotiranjem oko tog elementa dobijamo novu simpleks tabelu 

$$\begin{array}{cccc| c} 
		   -1 & 1  & 1  &  0 & 3 \\
		   -1 & 0  & 2  &  1 & 8 \\ \hline
		   2  & 0  & -3 &  0 & -9 \\
\end{array}$$
Kandidata za pivota tražimo u prvoj koloni, ali kako su svi negativni, to znači da se 
vrijednost  varijable $x$  može povećavati do te mjere da funkcija cilja nikad ne bude ograničena. 
Ovo se može vidjeti i na osnovu grafičke reprezentacije dopustivog regiona na Slici~\ref{fig:unbounded-example-solve} (koji je neograničen). 


\begin{figure}[!ht]
    \centering
    \includegraphics[width=170pt,height=170pt]{unbounded-example-solve.eps}
    \caption{Neograničen region.}
    \label{fig:unbounded-example-solve}
\end{figure}

\emph{\textbf{Primjer.}} U nastavku dajemo još jedan primjer kada pivotiranje u simpleks metodi generiše degenerativno rješenje. 
Posmatrajmo sljedeći linearni program:
\begin{align*}
    &\max 2x + 3y \\
    & s.t. \\
	& -x + y \leq 3 \\
	& x - 2y \leq 2 \\
	& x + 6y \leq 18
\end{align*}
Slično kao i u prethodnom primjeru, dodavanjem izjednačavajućih varijabli, dobijamo simpleks 
tabelu 
$$\begin{array}{ccccc|c}
     -1 & 1 & 1 & 0 & 0 & 3 \\
      1 &-2 & 0 & 1 & 0 & 2 \\
      1 & 6 & 0 & 0 & 1 & 18 \\ \hline
      2 & 3 & 0 & 0 & 0 & 0 \\
\end{array}$$
Recimo da iz nekog razloga biramo varijablu $y$ za baznu, tj. pivotiramo oko nekog od elemenata u koloni 2. za pivota odaberemo $\overline{a}_{1,2}=1$ element, te nakon pivotiranja dobijamo novu simpleks tabelu:
$$\begin{array}{ccccc|c}
	-1 & 1 & 1 & 0 & 0 & 3 \\
    -1 & 0 & 2 & 1 & 0 & 8 \\
    7 & 0 & -6 & 0 & 1 & 0 \\ \hline
    5 & 0 & -3 & 0 & 0 & -9 \\
\end{array}$$
Ovdje počinju problemi. Pivotiranje bi trebalo da ide sa elementima u koloni 1, ali tamo nema niti jedan element strogo veći od 0 (samo jedan koji je 0, a to je $\overline{a}_{3,1}$) i trebalo bi oko njega da pivotiramo. Kada se izvrši pivotiranje, varijable $\overline{b}$ ne mijenjaju svoje vrijednosti:
$$\begin{array}{ccccc|c}
     0 & 1 & \frac{1}{7}  & 0 & \frac{1}{7} & 3 \\
     0 & 0 & \frac{8}{7}  & 1 & \frac{1}{7} & 8 \\
     1 & 0 & -\frac{6}{7} & 0 & \frac{1}{7} & 0 \\ \hline
     0 & 0 & \frac{9}{7}  & 0 & -\frac{5}{7} & -9 \\
\end{array}$$
Razlog za to je jer se tri linije $x=0$, $-x+y=3$ i $x+6y=18$ susreću u tački $(0,3)$ (Slika~\ref{fig:deg-sol}). U prošlom koraku, kada su $x$ i $s_1$ bile nebazne varijable, tačka (0,3) je posmatrana kao presjek $x=0$ i $-x +y =3$. Nakon sljedećeg koraka $s_1$ i $s_3$ postaju nebazne, pa se pomjeramo u presjeku 
$-x+y=3$ i $x+6y=18$, što je opet ista tačka (i nema napretka vrijednosti funkcije cilja). 
 Ovo pivotiranje se naziva \emph{degenerativno pivotiranje}. u ovom primjeru, napustićemo vrh $(0,3)$ nakon sljedećeg pivotiranja. U komplikovanijim primjerima, kada se mnoga ograničenja mogu sresti u jednom vrhu, ostajanje u tom vrhu je velika opasnost. Ovo se može izbjeći poštovanjem 
 Bladovog pravila. Primijetimo da koristeći Bladovo pravilo u prvom koraku simpleks metode (uzimajući za pivota elemente iz kolone 1, a ne kolone 2), degenerativno pivotiranje se ne bi pojavilo.  


\begin{figure}[!ht]
	\centering
	\includegraphics[width=170pt,height=170pt]{deg-sol.eps}
	\caption{Tačka presjeka $(0,3)$ gdje se javlja degenerativno pivotiranje.}
	\label{fig:deg-sol}
\end{figure}

 \section{Dvofazni simpleks metod}
 Postoje dva pitanja koja se nameću u primjeni simpleks algoritma:
 \begin{itemize}
     \item Da li se uvijek može naći bazno dopustivo rješenje za inicijalni korak 
     simpleks algoritma?
     \item Da li se simpleks algoritam uvijek prekida sa nalaskom optimalnog rješenja ili je funkcija cilja neograničena?
 \end{itemize}
 
 Parcijalni odgovor na prvo pitanje je kada postoji jedinična podmatrica $I_m$ u gornjoj lijevoj blok matrici simpleks tabele,  onda je bazu jednostavno odrediti (kako smo to i vidjeli u prethodnoj sekciji). 
 Linearnom programu koji sadrži ograničenja $Ax \leq b, x\geq 0$ se dodaju izjednačavajuće varijable da bi uslovi nejednakosti u ograničenjima postali potrebne jednakosti. Na taj način se i formira ova jedinična matrica. Međutim, šta ako je linearan program direktno dat u kanonskom obliku, tj. sa ogarničenjima oblika $Ax = b, x \geq 0$? Bez smanjenja opštosti, pretpostavimo da je $b \geq 0$. Ako ne postoji očigledno bazno dopustivo rješenje ovog problema, onda uvodimo \emph{umjetne} varijable $\omega = (\omega_1,\ldots, \omega_m)$ nakon čega treba da riješimo sljedeći problem LP-a:
 \begin{align}
      &\sum_{i=1}^m \omega_i \rightarrow \min_{x,\omega} \nonumber \\
      &\mbox{ tako da } A x + \omega = b \nonumber \\
      & \hspace{1.5cm} x, \omega \geq 0. \label{eq:artificial_lp_simplex}
 \end{align}
Postoje dva moguća slučaja:
\begin{enumerate}
    \item Ako početni problem LP-a sa jednakosnim ulovima (\ref{eq:lp_equality_constraint}) 
          ima optimalno rješenje, onda   rješenje LP-a (\ref{eq:artificial_lp_simplex}) ima (optimalno) rješenje $\omega = 0$. 
    \item Ako  (\ref{eq:lp_equality_constraint}) nema dopustivo rješenje, onda je barem jedan $\omega_i > 0$.
\end{enumerate}
 Prema tome, rješimo prvo problem LP-a  (\ref{eq:artificial_lp_simplex}) simpleks metodom i zaključujemo:
 \begin{itemize}
      \item Ako se desi slučaj 2, odustanemo od daljeg rješavanja problema.
      \item Ako se desi slučaj 1, optimalno rješenje problema (\ref{eq:artificial_lp_simplex}) sa $\omega_i=0$ nam daje početno bazno dopustivo rješenje problema (\ref{eq:lp_equality_constraint}) u prvom simpleks koraku a prema tome i bazne vektore. 
 \end{itemize} 
 Ovaj korak nas vodi ka \emph{dvofaznoj simpleks metodi}. U nastavku dajemo primjer rješavanja jednog problema LP-a pomoću ove metode.      
      
 \section{Primjena dvofaznog simpleks metoda}     
 
 
 
Riješimo sljedeći problem LP-a:

\begin{align*}
	 &\min x_1 + x_2 - x_3 - x_4 \\
	 &\mbox{s.t.   } x_1 + 2x_2 + x_3 + x_4 = 7 \\
	 &\mbox{\ \ \ \ \ \ \ } 2x_1 - x_2 - x_3 - 3x_4 = -1 \\
	 &\mbox{\ \ \ \ \ \ \ }  x_1,x_2,x_3,x_4 \geq 0.
\end{align*}

Dodajmo umjetne varijable na početni problem (uz prethodno množenje uslova 2 sa (-1)), odakle dobijamo:

\begin{align*}
	&\min x_1 + x_2 - x_3 - x_4 \\
	&\mbox{s.t.   } x_1 + 2x_2 + x_3 + x_4 + \omega_1 = 7 \\
	&\mbox{\ \ \ \ \ \ \ } -2x_1 + x_2 + x_3 + 3x_4 + \omega_2 = -1 \\
	&\mbox{\ \ \ \ \ \ \ }  x_1,x_2,x_3,x_4, \omega_1, \omega_2\geq 0.
\end{align*}
Prva faza metoda je formirati metod 
\begin{align*}
	&\min \omega_1 + \omega_2 \\
		&\mbox{s.t.   } x_1 + 2x_2 + x_3 + x_4 + \omega_1 = 7 \\
	&\mbox{\ \ \ \ \ \ \ } -2x_1 + x_2 + x_3 + 3x_4 + \omega_2 = -1 \\
	&\mbox{\ \ \ \ \ \ \ }  x_1,x_2,x_3,x_4, \omega_1, \omega_2\geq 0.
\end{align*}


Formirajmo početnu simpleks tabelu:\\
$$\begin{array}{cccccc|c}
	1 & 2 & 1 & 1 & 1 &  0 & 7  \\
   -2 & 1 & 1 & 3 & 0 &  1 & 1  \\ \hline
    0 & 0 & 0 & 0 & 1 & 1 &  0  \\
\end{array}
$$
$$\begin{array}{cccccc|c}
	1 & 2 & 1 & 1 & 1 & 0 & 7 \\
	-2&1  & 1 & 3 & 0 & 1 & 1 \\ \hline
	1 & -3 & -2 & -4 & 0 & 0 & -8 \\ 
\end{array}
 $$
 Iz prethodne tabele, kako minimizujemo, tražimo varijablu 
 sa negativnim koeficijentom doprinosa, a prva takva je varijabla u koloni 2 u kojoj 
 i tražimo pivota.  Kako je $\frac{7}{2} > \frac{1}{1}$, slijedi da je 
 pivot $\overline{a}_{2,2} = 1$. Izvršimo transformacije, tako što napravimo sve nule u datoj koloni, odakle dobijamo tabelu:
 
$$ \begin{array}{cccccc|c}
 	 5 & 0 & -1 & -5 & 1 & -2 & 5 \\
	-2&1  & 1 & 3 & 0 & 1 & 1 \\ \hline
	 -5 & 0 & 1 & 5 & 0 & 3 & -5 \\
 \end{array}
 $$
 Jedini vektor sa negativnim doprinosom u prethodnoj simpleks tabeli je 
 onaj koji odgovara prvoj koloni, pa u njoj i tražimo pivota.  
 Kako se jedino u prvoj vrsti nalazi pozitivan element, koji odgovara vrijednosti pravca $\frac{5}{5}$, dakle pivot je $\overline{a}_{1,1}=5$. Izvršavajući elementarne transformacije oko ovog elementa, dobijamo tabelu 
 $$ \begin{array}{cccccc|c}
        1 & 0 & -\frac{1}{5}  & -1   &  \frac{1}{5}     & -\frac{2}{5}  & 1                    \\
        0 & 1 & \frac{3}{5}   &  1   &   \frac{2}{5}  & \frac{1}{5}      & 3                   \\ \hline
        0 & 0 & 0            &  0   &   1        & 1                     & 0                                 \\
    \end{array}
$$
Kako su koeficijenti doprinosa svi veći ili jednaki 0, našli smo minimum. 
Prema tome, bazno dopustivo rješenje je jednako $(x, \omega)= (1,3, 0, 0)$. Dakle, nastavljamo dalje sa algoritmom, tj. drugom fazom metoda.  Posljednja simpleks tabela prve faze dvofaznog simpleks metoda se lako transformiše za početni problem: 
\begin{itemize}
	\item posljednja vrsta dobija koeficijente originalne funkcije cilja razmatranog LP-a:
	\item kolone koje odgovaraju varijablama $\omega$ izbrišemo iz simpleks tabele;
	\item ostale elemente tabele ostavimo kakvi jesu.
\end{itemize}
Iz ovih koraka, dobijamo simpleks tabelu 

 $$ \begin{array}{cccc|c}
 	   1 & 0 & -\frac{1}{5}     & -1   & 1 \\
 	   0 & 1 & \frac{3}{5}      & 1    & 3 \\ \hline
       1 & 1 & -1               & -1   & 0 \\
    \end{array}
$$
Uradimo sada elementarne transformacije na ovoj tabeli; kandidata za pivota nađimo u 
koloni 3. Jedini element sa pozitivnom vrijednošću je $\overline{a}_{2,3} = \frac{3}{5}$, koji je onda i traženi pivot. 
Vršeći elementarne transformacije oko pivota, dobijamo tabelu 

$$ \begin{array}{cccc|c}
       1   & \frac{1}{3}       & 0             &   -\frac{4}{3}             &   2  \\
       0   & \frac{5}{3}       & 1	           & \frac{5}{3}                 &   5 \\ \hline
       1   & \frac{8}{3}       & 0             &  \frac{2}{3}               &   3  
   \end{array}
 $$
 iz koje vidimo pošto su doprinosi svi veći od 0, da smo našli optimalnu simpleks tabelu.  Optimalna rješenja su 
 $x_1=2, x_3=5$, pa je prema tome optimum jednak -3.
 
 \section{Geometrija i simpleks metod}
 
Sljedeći primjer demonstrira odgovarajuće geometrijske korake (``šetanje'') po dopustivom regionu shodno iteracijama simpleks metode koji se izvršavaju.   %pratiti https://faculty.math.illinois.edu/~mlavrov/docs/482-fall-2019/lecture5.pdf (strana 2 i 3) 
 Neka je dat problem:
 \begin{align*}
 	&\max 2x + 3y \\
 	& s.t. \\
 	& -x + y \leq 3 \\
 	& x - 2y \leq 2 \\
 	& 3x + 4y \leq 26 \\
 	& x, y \geq 0.
 \end{align*}
 Dodajmo izjednačavajuće varijable u početni LP, odakle dobijamo 
  \begin{align*}
 	&\max 2x + 3y \\
 	& s.t. \\
 	& -x + y + s_1 = 3 \\
 	& x - 2y + s_2 = 2 \\
 	& 3x + 4y + s_3 =  26 \\
 	& x, y, s_1, s_2, s_3 \geq 0.
 \end{align*}
Kao što smo pomenuli kod simpleks metode, 
izjednačavajuće varijable čine pogodne bazne varijable od kojih krećemo 
sa simpleks metodom (jedinična podmatrica u gornjoj blok matrici 
simpleks tabele). Bazno rješenje, prema tome, ima oblik 
$(x, y, s_1, s_2, s_3) = (0, 0, 3, 2, 26)$, koje je i dopustivo. Inicijalna simpleks 
tabela je data sa

$$\begin{array}{cccccc| c}
        & x & y & s_1 & s_2 & s_3 & \\ \hline
   s_1  & -1 & 1 & 1 & 0 & 0 & 3 \\
   s_2  & 1 & -2 & 0 & 1 & 0 & 2 \\
   s_3  & 3 & 4 & 0 & 0 & 1 & 26 \\ \hline
    -z  & 2 & 3 & 0 & 0 & 0 & 0 \\
\end{array}
$$ 
Ova situacija odgovara sljedećoj geometrijskoj interpretaciji na Slici~\ref{fig:step-1}, što znači da se nalazimo u tački $A=(0,0)$, koja je dopustiva, te je optimalna vrijednost za sada jednaka 0. 
\begin{figure}[H]
	\centering
	\includegraphics[width=170pt, height=170pt]{simpleks-primjer-2-sl1.eps}
	\caption{Korak 1}
	\label{fig:step-1}
\end{figure}

Izvršimo sada promjenu baznih vektora na osnovu simpleks koraka. Dakle, kako maksimizujemo, 
tražimo one koeficijente dopirnosa koji su veći od 0. Biramo prvu kolonu koja odgovara varijabli $x$, te nađimo 
pivot element: kandidati su $s_2$ i $s_3$. Kako je $\frac{26}{3} > \frac{2}{1}$, onda je  pivot $\overline{a}_{2, 1} = 1$. Pivotiramo oko ovog elementa i dobijemo tabelu:
$$\begin{array}{cccccc| c}
       & s_2  & y  & s_1  & s_2 & s_3 &    \\ \hline
   s_1 & 0    & -1  & 1  & 1 & 0  &  5     \\
   x   & 1    & -2  & 0  & 1 & 0  &  2     \\
   s_3 & 0    & 10   &  0  & -3 & 1 & 20   \\ \hline
   -z  & 0    &  7   & 0   & -2 & 0 & -4   \\ 
\end{array}
$$ 
Dakle, ova tablea odgovara Slici~\ref{fig:step-2}, tj. šetnji do baznog rješenja $(x,y, s_1, s_2, s_3)=(2, 0, 5, 0 ,20)$, tj. do tačke $E=(2, 0)$. 

\begin{figure}[!ht]
	\centering
	\includegraphics[width=170pt, height=170pt]{simpleks-primjer-2-sl2.eps}
	\caption{Korak 2}
	\label{fig:step-2}
\end{figure}
Dalje, narednog pivota nalazimo u koloni 2 (koja odgovara varijabli $y$). Jedini kandidat za pivota je element $\overline{a}_{3, 2}= 10$, pa nakon pivotiranja dobijamo tabelu 

$$\begin{array}{cccccc| c}
	& s_2  & s_3   & s_1  & s_2 & s_3 &     \\ \hline
s_1 & 0    &  0    & 1    &  \frac{7}{10}  & \frac{1}{10} &   7  \\  
x   & 1    &  0    & 0    &  \frac{2}{5}   & \frac{1}{5}  &   6  \\
y   & 0    &  1    & 0    & - \frac{3}{10}  & \frac{1}{10} &   2  \\ \hline
-z  & 0    &  0    & 0    &   \frac{1}{10} &-\frac{7}{10}  &  -18 \\ 
\end{array}
$$ 

\begin{figure}[H]
	\centering
	\includegraphics[width=170pt, height=170pt]{simpleks-primjer-2-sl3.eps}
	\caption{Korak 3}
	\label{fig:step-3}
\end{figure}

Ova tabela odgovara hodu od tačke $E=(2,0)$ do tačke $D=(6,2)$, kao što vidimo na Slici~\ref{fig:step-3}.
Zaključujemo da je jedina koordinata koja odgovara pozitivnom doprinosu kolona 
4 simpleks tabele. Pivotiranje radimo oko elementa $\overline{a}_{1,4} = \frac{7}{10}$, pa dobijamo simpleks tabelu 

$$\begin{array}{cccccc| c}
	& s_2  & s_3   & s_1  & s_2 & s_3 &     \\ \hline
s_2 &  0   &  0    & \frac{10}{7}    &  1   & \frac{1}{7}   & 10 \\
x   &  1   &  0    &  \frac{4}{7}    &  0   & \frac{1}{7}  & 2 \\
y   &  0   &  1    &  \frac{3}{7}    &  0   & \frac{1}{7}   & 5  \\ \hline
-z  &  0   &  0   &   -\frac{1}{10}  & 0    &  -\frac{5}{7} & -19 \\
\end{array}
$$ 

Kako ne postoje koordinate čiji su doprinosi pozitivni, našli smo optimum i on je jednak 
$C=(2,5)$. Prethodna simpleks tabela odgovara Slici~\ref{fig:step-4}, dok svi koraci u simpleks metodi odgovaraju 
hodu $A \rightarrow E \rightarrow D \rightarrow C$. 

\begin{figure}[H]
	\centering
	\includegraphics[width=170pt, height=170pt]{simpleks-primjer-2-sl4.eps}
	\caption{Korak 4}
	\label{fig:step-4}
\end{figure}


Primijetimo da ako bi u prvom koraku simpleks metode birali mjesto varijable $x$ ubacivanje varijable $y$ u bazu, došli bi do optimuma tako što bi se pomjerili   prvo u tačku $B$, pa potom u $C$, koja je optimum. Takođe, u ovom slučaju je potrebno generisati samo dvije simpleks tabele (a ne tri, kao što smo mi generisali u ovom primjeru).\vspace{1cm}
\\
\textbf{\Large Zadaci}.
\begin{enumerate}
 \item Uz pomoć Simpleks metoda, riješiti sljedeći problem LP-a:%http://www.phpsimplex.com/en/simplex_method_example.htm (PHP simpleks: http://www.phpsimplex.com/simplex/simplex.htm?l=en)
 \begin{align*}
 	 &\max  3x + 2y \\
 	 & s.t. \\
 	 & 2x + y \leq 18 \\
 	 & 2x + 3y \leq 42 \\
 	 & 3x + y \leq 24 \\
 	 & x,y \geq 0.
 \end{align*} 
Uporedite dobijeno rješenje sa rješenjem koje se dobije 
koristeći grafičku metodu.
\item %https://courses.lumenlearning.com/sanjacinto-finitemath1/chapter/reading-solving-standard-maximization-problems-using-the-simplex-method/
   Uz pomoć Simpleks metoda, riješiti sljedeći problem LP-a:
 \begin{align*}
 	  &\max z = 2x + 3y + z \\
 	  & s.t. \\
 	  & 3x + 5 y \leq 5 \\
 	  & 2x + y - z \leq 13 \\
 	  & z \leq 4 \\
 	  & x,y,z \geq 0.
 \end{align*}
\item Uz pomoć dvofaznog simpleks metoda, riješiti sljedeći problem LP-a:%http://sma.epfl.ch/~niemeier/opt09/opt09_ch06.pdf
   \begin{align*}
   	    &\min  x_1 + x_2 + x_3 \\
   	    & s.t. \\
   	    & x_1 + 2 x_2 + 3 x_3 = 3 \\
   	    & -x_1 + 2 x_2 + 6 x_3 = 2 \\
   	    & - 4x_2 - 9 x_3 = -5 \\
   	    & 3 x_3 + x_4 = 1 \\
   	    & x_1, x_2, x_3, x_4 \geq 0.
   \end{align*}
\item  Uz pomoć Simpleks metoda, riješiti sljedeći problem LP-a:%http://myweb.usf.edu/~molla/2016_spring_math482/two_phase_pres-3up.pdf
\begin{align*}
    & \min -x_1 - x_2 - x_3 \\
    & s.t. \\
    & 2 x_1 - x_2 + 2 x_3 + x_4 = 4 \\
    & 2x_1 - 3x_2 + x_3 + x_5 =  -5 \\
    & -x_1 + x_2 - 2x_3 + x_6 = -1 \\
    & x_1, x_2, x_3, x_4, x_5, x_6 \geq 0.	
\end{align*}
\item Uz pomoć Simpleks metoda, riješiti sljedeći problem LP-a:
 %https://personal.utdallas.edu/~scniu/OPRE-6201/documents/LP10-Special-Situations.pdf (Degeneracy in Simplex method):
\begin{align*}
	 &\max 2x_1 + x_2 \\
	 & s.t. \\
	 &4 x_1 + 3 x_2 \leq 12 \\
	 & 4 x_1 + x_2 \leq 8 \\
	 & 4 x_1 + 2 x_2 \leq 8 \\
	 & x_1, x_2 \geq 0.
\end{align*}
U ovom primjeru detektovati degenerativno bazno rješenje koje je nađeno simpleks metodom. Diskutovati zašto je ono degenerativno. 

\end{enumerate}


\begin{comment}
$$\begin{array}{ccccc}
     \max                & 3x_1     &          &   + x_3  &       \\           
     {s.t. }   & x_1      &+ 2x_2    &   + x_3  & = 30  \\
                         & x_1      &- 2x_2    &   + 2x_3 & = 18  \\
                         & x \geq 0 &          &       &          \\
\end{array}$$
Dodavanjem umjetnih varijabli, dobijamo problem
   
$$\begin{array}{ccccccc}
     \min                &          &          &            & \omega_1 & +\omega_2   &    \\           
     {s.t. }  & x_1      &+ 2x_2    &   + x_3    &+ \omega_1  &  &= 30  \\
                         & x_1      &- 2x_2    &   + 2x_3    & & \omega_2  &= 18  \\
                         & x \geq 0 &  \omega \geq 0        &       &    &  &     \\
\end{array}$$

Problem minimizacije se može prebaciti na problem maksimizacije, tj. prvi uslov u prethodnom problemu prevedemo na $\max - \omega_1 - \omega_2$, što onda odgovara simpleks tabeli 

$$\begin{array}{ccccc | c}
    1 & 2   & 1 & 1 & 0   & 30 \\
    1 & -2  & 2 & 0 & 1   & 18 \\ \hline
    0 & 0   & 0 & -1 & -1 & 0 \\
\end{array}$$
Prvo što trebamo da izrazimo funkciju cilja preko nebaznih varijabli tako da ulazi ispod jedinične matice budu svi 0. To dobijamo elementarnim transformacijama na simpleks tabeli (matrici): vrsti 3 dodamo vrstu 1 i 2, te dobijamo tabelu 

$$\begin{array}{ccccc | c}
    1 & 2   & 1 & 1 & 0   & 30 \\
    1 & -2  & 2 & 0 & 1   & 18 \\ \hline
    2 & 0   & 3 & 1 & 1   & 48 \\
\end{array}$$
Krenimo sa simpleks koracima, tj. nađimo pivota. Kandidat je $\overline{a}_{2,3}$, pa pivotirajmo oko tog elementa, čime dobijamo tabelu 

$$\begin{array}{ccccc | c}
    \frac{1}{2} & 3   & 0 &  1 &  -\frac{1}{2} & 21 \\
    \frac{1}{2} & -1  & 1 & 0 & \frac{1}{2}   & 9 \\ \hline
    \frac{1}{2} & 3   & 0 & 0 &  -\frac{3}{2}  & 21 \\
\end{array}$$
Dakle, sljedeći pivot je $\overline{a}_{1,2}$, gdje nakon pivotiranja dobijamo sljedeću tabelu 

$$\begin{array}{ccccc | c}  
    \frac{1}{6} & 1   & 0 &  \frac{1}{3} &  -\frac{1}{6} & 7 \\
    \frac{2}{3} & 0  & 1 & \frac{1}{3} & \frac{1}{3}   & 16 \\ \hline
    0 & 0   & 0 & -1 &  -1  & 0 \\
\end{array}$$
Prema tome, našli smo tačku tako da je $-\omega_1 - \omega_2 = 0$, dakle slijedi 
da je bazna dopustiva tačka početnog problema $x = (0, 7, 16)$. 

Sljedeći korak sadrži primjenu simpleks metoda na originalni problem.
Posljednja simpleks tabela prve faze dvofaznog simpleks metoda se lako transformiše za početni problem: 
\begin{itemize}
    \item posljednja vrsta dovija koeficijente originalne funkcije cilja razmatranog LP-a:
    \item kolone koje odgovaraju varijablama $\omega$ izbrišemo iz simpleks tabele;
    \item ostale elemente tabele ostavimo kakvi jesu.
\end{itemize}
Iz ovih koraka, dobijamo simpleks tabelu 
 $$
   \begin{array}{ccc|c}
       \frac{1}{6}       & 1   & 0  & 7   \\
       \frac{2}{3}       &  0   & 1  & 16  \\ \hline
       3                 & 0   & 1  & 0   \\
   \end{array}
 $$
Opet je potrebno ispod jedinične matrice u vrsti koja odgovara funkciji cilja napraviti nule. To uradimo primjenjujući elementarne transformacije na matrici, tj. vrsti 3 dodamo vrstu 2 koja je pomnožena sa -1. Tada dobijamo simpleks matricu 

$$
   \begin{array}{ccc|c}
       \frac{1}{6}       & 1   & 0  & 7   \\
       \frac{2}{3}       &  0   & 1  & 16  \\ \hline
       \frac{7}{3}                 & 0   & 0  & -16  \\
   \end{array}
 $$
Za pivota uzmemo $\overline{a}_{2, 1}$, izvršimo transformacije i dobijemo tabelu 
$$
   \begin{array}{ccc|c}
       0       & 1    & -\frac{1}{4}  & 3   \\
       1       &  0   & \frac{3}{2} & 24  \\ \hline
       0       &  0   & -\frac{7}{2}  & -72 \\
   \end{array}
$$
Kako su svi koeficijenti doprinosa ($\overline{c}$ varijable) manje od 0, simpleks metod staje nalazeći optimum koji se dostiže u tački $x = (24, 3, 0)$, i jednak je vrijednosti  $f = 72$.
\end{comment}
  \newpage
 \chapter{Dualnost \& Dopustivost}
 
 %Dualnost je pojam koji je vezan za dobijanje gornjih granica optimalne vrijednosti funkcije cilja. 
 Teorija dualnosti povezuje dva vezana problema linearnog programiranja -- jedan od njih je problem linearnog programiranja koji maksimizuje funkciju cilja, dok je drugi linearan program  koji minimizuje (ne obavezno istu) funkciju cilja. Svaki problem LP-a se može navesti u drugom, ekvivalentnom obliku na osnovu istih ulaznih podataka. Ponekad rješavanje LP-a na ovaj način može da bude puno lakše nego rješavanje početnog LP-a.  Dualnost implicira da svaki problem linearnog programiranja možemo analizirati na dva potpuno različita načina, ali sa ekvivalentnim (optimalnim) rješenjima. 
 
 
 
 Prije nego uvedemo pojam dualnog problema, objasnimo motivaciju koja stoji iza nastanka teorije dualnosti. Posmatrajmo jedan LP i probajmo naći što bolju gornju procjenu za optimalnu vrijednost ciljne funkcije na osnovu ograničenja u datom modelu.
 
$$ 
\begin{array}{lllll}
    \max                  &x_1 &+& x_2   &               \\
    \mbox{s.t.}  &4x_1 & +&3 x_2 & \leq 9        \\
                          &x_1 &+ &x_2   &  \leq 8       \\
                          &x \geq 0  &  &     &      
 \end{array}
$$
Iz uslova je jasno da $f(x) = x_1 + x_2 \leq 4 x_1 + 3 x_2 \leq 9$, kao i 
$f(x) \leq x_1 + x_2 \leq 8$. Prema tome:
$$f(x) = \frac{1}{5}(  4 x_1 + 3 x_2  ) + \frac{1}{5}(  4 x_1 + 3 x_2 ) \leq x_1 + \frac{4}{5}x_2 \leq \frac{17}{5},$$ kao jedna gornja granica optimalne vrijednosti ciljne funkcije. 
Uradimo sada slično izvođenje na generalniji način, tj. iskoristimo ograničenja data u modelu zajedno u kombinaciji sa koeficijentima funkcije cilja. Neka su $y_1, y_2 \geq 0$ koeficijenti sa kojima množimo ograničenja u početnom modelu, odakle dobijamo 
\begin{align*}
    &y_1 \cdot (4x_1 + 3x_2) \leq 9 y_1 \\
    &y_2 \cdot (x_1 + x_2 ) \leq 8 y_2 
\end{align*}
Sabirajući ove dvije nejednakosti i grupišući sabirke dobijamo 
\begin{equation}\label{eq:dual-1}
     x_1 ( 4 y_1 + y_2 ) + x_2 ( 3 y_1 + y_2 ) \leq 9 y_1 + 8 y_2 
\end{equation}
Posmatrajući funkciju cilja i koeficijente uz varijable u (\ref{eq:dual-1}), jasno je da treba vrijediti 
$4 y_1 + y_2 \geq 1$ i $3 y_1 + y_2 \geq 1$. Da bi ocjena gornje granice bila što bolja u (\ref{eq:dual-1}), dakle koeficijent na desnoj strani što veći, potrebno je minimizovati izraz $9y_1 + 8 y_2$, pod gore navedenim uslovima. Prema tome, početnom problemu, kojeg označavamo sa ($P$), odgovara dualni problem 
$$\begin{array}{cccc}
     \min                    &  9 y_1 &+& 8 y_2        \\
     {s.t. }     &  4 y_1 &+& y_2 \geq 1   \\
                             &  3 y_1 &+& y_2 \geq 1
\end{array}$$
Generalno posmatrajući, za problem LP-a~(\ref{eq:LP-o1})--(\ref{eq:LP-c2}) njegov dualni problem, označen sa ($D$), je dat sa 
\begin{align}
     & b^T y \rightarrow \max \\
     & \mbox{s.t.} \nonumber \\
     & A^T y \geq c \\
     & y \geq 0.
\end{align}

\section{Teoreme dualnosti}

\begin{thm}[Teorema o slaboj dualnosti]
  Ako je x dopustivo rješenje za problem ($P$) i y dopustivo rješenje za problem  ($D$), onda je 
  $$ c^T x \leq b^T y.$$
\end{thm}
\begin{proof}
         Kako je $x \geq 0$ i $A^T y \geq c $,  transponovanjem obje strane dobijemo 
         $y^T A \geq c^T$. Množenjem obje strane posljednje nejednakosti sa $x$, dobijamo 
         $$y^TAx \geq c^T x.$$ Kako je $Ax \leq b$ i $y \geq 0$,  tada dobijamo 
         $ y^T b = b^T y  \leq c^T x$
\end{proof}

\emph{Posljedica.} Ako je $y$ dopustivo rješenje problema  ($D$),  onda bilo koje dopustivo rješenje $x$ problema ($P$) je ograničeno odozgo sa $b^T y$. Prema tome, ako je problem ($D$) dopustiv, onda je ($P$) ograničen. Slično se može pokazati da ovo vrijedi kada problemi ($P$) i ($D$) zamijene uloge.

\begin{prop}  
    Ako je $x^*$ dopustivo rješenje za  ($P$), $y^*$ dopustivo rješenje za ($D$) i pri tome vrijedi 
    $c^T x^* = b^T y^*$, onda je $x^*$ optimalno rješenje za problem  ($P$), dok je $y^*$ optimalno rješenje za problem  ($D$).  
\end{prop}
\begin{proof}
         Iz teoreme o slaboj dualnosti imamo: $c^T x  \leq b^T y^* = c^T x^*$, za bilo koje dopustivo rješenje $x$ od  ($P$), pa je $x^*$ upravo optimalno rješenje problema  ($P$).
         Slično imamo da vrijedi za sva dopustiva rješenja od  ($D$): $b^T y^* = c^T x^* \geq b^T y$, odakle imamo da je $y^*$ optimalno rješenje za problem  ($D$). 
\end{proof}

\begin{thm}[Teorema o jakoj dualnosti]
     Ako problem ($P$) ima optimalno rješenje $x^*$, onda i problem ($D$) ima optimalno rješenje $y^*$ i pri tome je $c^T x^* = b^T y^*$.
\end{thm}
\begin{proof}
         Napišimo ograničenja probema ($P$) kao $Ax + \omega = b, x, \omega \geq 0$.
         Primijenimo simpleks metod, pa posmatrajmo posljednju (optimalnu) simpleks tabelu (iz koje je dobijeno rješenje $x^*$):
         
         $$\begin{array}{c |c | c}
         \overbrace{\ \ \ \ \ \hspace{1.5cm}}_{x \mbox{ varijable}}     &  \overbrace{\ \ \ \ \ \hspace{1.5cm}}_{\omega \mbox{ varijable}} &   \\
                                                           & &   \\
         \hline
             c_1^*\ c_2^* \ldots c_n^*            & -y_1^* -y_2^* \ldots -y_m^*  & -f^*
         \end{array}
         $$
   gdje je 
   \begin{enumerate}
       \item    $c^*_i \leq 0, i = 1,\ldots, n$ 
       \item    $-y_i^* \leq 0$, $i = 1,\ldots, m$
       \item  $c^T x - f^* = (c^*)^T x - (y^*)^T \omega$
    \end{enumerate}
    Prema tome, 
    \begin{align*}
           c^T x &=  f^* + (c^*)^T x - (y^*)^T \omega \\
                 &=  f^* + (c^*)^T x - (y^*)^T (b - Ax) \\
                 &= f^*  - (y^*)^T b +   ((c^*)^T + (y^*)^T A ) x
    \end{align*}
    koje vrijedi za sve $x$, pa dobijamo 
    
    \begin{equation}\label{eq:f_y_star}
        f^* = (y^*)^T b
    \end{equation}
     (posljedica kad uvrstimo $x = 0$) odakle posljedično slijedi 
    $ c = A^T y^* + c^*$. 
    Kako je $c^* \leq 0$, imamo  $A^T y^* \geq c$. Kako je $-y^* \leq 0$ pa je $y^*$ dopustivo rješenje za  ($D$).  Iz (\ref{eq:f_y_star}) je pokazano da je vrijednost ciljne funkcije u $y^*$ upravo $f^*$. Iz teoreme o slaboj dualnosti slijedi da je $y^*$ optimalno rješenje problema  ($D$). 
    
\end{proof} \\
Primijetimo da koeficijenti $y^*$ posljednje vrste završne simpleks tabele odgovaraju  ``izjednačavajućim''   varijablama i one nam daju rješenje problema  ($D$).  

\emph{\textbf{Primjer.}} Moguće je da i problem ($P$) i odgovarajući dual ($D$) nemaju dopustivo rješenje. Pogledajte sljedeći primjer:
$$\begin{array}{cc}
    \max                      & 2 x_1 - x_2 \\
     {s.t. }      & x_1 - x_1 \leq 1 \\
                              & -x_1 + x_2 \leq -2 \\
                             & x_1, x_2 \geq 0.
\end{array}$$
i pokažite da je to slučaj.\\

Pozabavimo se sada pojmom \emph{komplementarnosti} (eng. \emph{complementary slackness}). 
\begin{thm}[Teorema komplementarnosti]
      Neka su x i y dopustiva rješenja problema ($P$) i  ($D$), redom. Vektori x i y su optimalna rješenja akko vrijedi 
      \begin{equation}\label{eq:slackness-1}
           (A^Ty - c)_j x_j = 0, j=1,\ldots,m
      \end{equation} i
      \begin{equation}\label{eq:slackness-2}
           (Ax - b)_i y_i = 0, i=1,\ldots,n
      \end{equation}
\end{thm}
Uslovi (\ref{eq:slackness-1}) i (\ref{eq:slackness-2}) se nazivaju \emph{uslovi komplementarnosti}.

\begin{proof}
         Iz teoreme o slaboj dualnosti imamo: 
         \begin{equation}
             c^Tx \leq ( A^T y)^T x = y^T A x \leq b^T y. 
         \end{equation}
         Dalje, iz teoreme jake dualnosti imamo  
         \begin{align*}
             &x \mbox{ i } y \mbox{ su oba optimalna } \Longleftrightarrow c^T x = b^T y \Longleftrightarrow c^Tx = y^TA x = b^Ty \\
             &\Longleftrightarrow (y^T A - c^T) x = 0 \wedge y^T(Ax - b )  = 0\\
             & \Longleftrightarrow \sum_i (A^T y - c)_i x_i = 0 \wedge \sum_j (Ax - b)_j y_j = 0
         \end{align*}
         Kako je $A^Ty \geq c$, $\sum_i (A^T y - c)_i x_i$ je suma nenegativnih komponenti, odakle imamo ekvivalneciju da  da   $(A^T y - c)_i x_i= 0$ za sve $i$. Takođe slično vrijedi i za drugu sumu, jer $Ax - b \leq 0$, pa je svaki  $(Ax - b)_j y_j$ negativan, odakle imamo ekvivalenciju da je $(Ax - b)_j y_j = 0$ za sve $j$.
\end{proof}

\emph{Komentar}.  Nekada je lakse riješiti jedan od problema, ($P$)  ili  ($D$).  Recimo, lakše je riješiti dualni problem sa dvije varijable i 4 ograničenja (grafički metod), nego primalni  ($P$)  uslov sa 4 varijable i 2 ograničenja. 

\emph{\textbf{Primjer.}} Posmatrajmo problem  ($P$)  i  ($D$)  gdje su:
 
$$      A = \left(\begin{array}{ccc}
          1 &  4 & 0 \\
          3 & -1 & 1 \\
      \end{array} \right ), b = \left (\begin{array}{c}
           1 \\
           3
      \end{array}\right ), c =\left ( \begin{array}{c}
           4  \\
           1  \\
           3
      \end{array} \right )
 $$
Posmatrajmo jedno dopustivo rješenje problema  ($P$), $x = (0, \frac{1}{4}, \frac{13}{4})$. Da li je ono optimalno? Ako bi bilo optimalno, imali bi prema teoremi komplementarnosti sljedeće:

$$x_2 \geq 0 \Rightarrow  (A^T y)_2  = c_2, \mbox{ tj. } 4 \cdot y_1 - y_2 = 1$$
$$x_3 \geq 0 \Rightarrow  (A^T y)_3  = c_3, \mbox{ tj. } 0 \cdot y_1 + y_2 = 3$$
što nam daje  $y = (1, 3)$. Preostalo ograničenje $y_1 + 3 y_2 \geq 4$ takođe vrijedi za vektor $y$, odakle imamo da je $y$ dopustivo rješenje odgovarajućeg problema  ($D$).  Prema tome, zaključujemo da su $x$ i $y$ dopustiva rješenja koja zadovoljavaju svojstvo komplementarnosti, pa su to i optimalna rješenja. 

\begin{figure}[!ht]
    \centering
     \includegraphics[width=180pt, height=180pt]{fig5.eps}
    \caption{Dualni problem: dopustiv region}
    \label{fig:fig5}
\end{figure}
Optimalno rješenje je u presjeku $y_2 = 3$ i $4y_1 - y_2 = 1$, i ono odgovara $y = (1, 3)$. Ispitajmo na osnovu komplementarnosti šta je optimalno rješenje problema ($P$). Imamo 
$$y_1 > 0 \Rightarrow (Ax - b)_1 y_1 = 0 \Rightarrow x_1 + 4 x_2 = 4 $$
$$y_2 > 0 \Rightarrow (Ax - b)_2 y_2 = 0 \Rightarrow 3x_1 - x_2 + x_2 = 3 $$
i kako je $y_1 + 3 y_2 > 4$, onda $(A^Ty)_1 > c_1$ i prema tome $x_1 =0$, 
odakle $x =(0, \frac{1}{4}, \frac{13}{4})$. 

\emph{\textbf{Primjer.}} Posmatrajmo problem LP-a:
$$\begin{array}{llll}
   &\max                     &10 x_1 + 10 x_2 + 20 x_3 + 20 x_4  & \\
   &{s.t. }      &12 x_1 + 8 x_2  + 6 x_3  + 4 x_4   & \leq 210 \\
    &                        &3 x_1 + 6 x_2   + 12 x_3 + 24 x_4 & \leq 210 \\
     &                       & x_1,\ldots, x_4 \geq 0.                                 &
\end{array}
$$
Ovaj problem ima 4 varijable i 2 ograničenja. Prema tome, ima smisla razmatrati dualni problem  ($D$)  datog primala  ($P$)  jer u tom slučaju dobijamo linearni program od samo dvije varijable koji se može riješiti grafički.  Odgovarajući problem ($D$) je dat sa:

$$\begin{array}{lll}
    &\min                    &  210 y_1 + 210 y_2      \\
    &{s.t. }     &  12 y_1  + 3   y_2 \geq 10 \\
    &                        &  8  y_1 + 6    y_2 \geq 10 \\
    &                        &  6 y_1 + 12 y_2  \geq 20 \\
    &                        &  4 y_1 + 24 y_2  \geq 20 \\
    &                        &  y_1, y_2 \geq 0.
\end{array}$$
Dopustiv region dualnog problema je dat na Slici~ \ref{fig:fig6-dual-region}. %gdje je dopustiv region označen plavom bojom. 
Dalje, može se pokazati da je optimum duala u presjeku prave $12 y_1 + 3 y_2 = 10$ i prave $6y_1 + 12 y_2 = 20$. Na osnovu Slike \ref{fig:fig6-dual-region} takođe vidimo da se druga i četvrta prava ne dostižu u tački optimuma (vrijedi stroga nejednakost nakon uvrštavanja tačke optimuma u ograničenja). Dakle, iz uslova komplementarnosti slijedi da za optimum $x$ primala  ($P$)  vrijedi $x_2 = 0$ i $x_4 = 0$.  Kako je $y_1, y_2 > 0$, onda vrijedi 

\begin{align}
    &10 x_1 + 20 x_3 = 210 \nonumber \\
    & 3x_1 + 12 x_3  = 210 \nonumber
\end{align}
odakle dobijamo rješenje $x_1 = 10, x_3 = 15$, pa je optimalno rješenje $x = (10, 0, 15, 0)$.

\emph{Zadatak}. Vrijednost 210 u drugom ograničenju u prethodnom problemu  ($P$)  zamijenite sa 420 i diskutujte optimalna rješenja  ($P$)  i  ($D$)  na sličan način kako je izvedeno  u primjeru gore.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=170pt, height=170pt]{fig6.eps}
    \caption{Dopustiv region duala.}
    \label{fig:fig6-dual-region}
\end{figure}

Najlakše je opisati dualnost kao odnos između problema maksimizacije i problem minimizacije, bez obzira 
koji je od njih bio problem ($P$) a koji od njih  dual ($D$). 
U nastavku, kompletna lista mogućih odnosa između ograničenja
jedanog problema i varijabli u drugom problemu je data preko sljedeće tabele
\begin{table}[!ht]
	\centering
    \begin{tabular}{l|l}
      ($P$) & ($D$) \\ \hline
      ograničenja $\leq$  & varijable $\geq 0$ \\
      ograničenja $=$     & varijable (neograničene) \\
      ograničenja $\geq$  & varijable $\leq 0$ \\
      varijable $\geq 0$    & ograničenja $\geq$ \\
      varijable (neograničene) & ograničenja $=$ \\
      varijable $\leq 0$         & ograničenja $\leq$ \\ \hline
    \end{tabular}
\end{table}


\section{Metod Unutrašnje Tačke}

Simpleks metod ne garantuje   rješavanje proizvoljnog problema LP u polinomijalnom broju koraka u odnosu na veličinu ulaza. % V. Klee and G. Minty constructed an example LP: simplex method needs 2^n iterations to solve it 
%Dakle, iz njega se ne može zaključiti da je problem rješavanja generalnog LP problema   polinomijalno rješiv. 
\emph{Metod unutrašnje tačke} rješava bilo koji problem LP-a  u polinomijanom vremenu. U ovoj sekciji ćemo dati konstrukciju ovog metoda, koji pokazuje da rješavanje problema LP-a pripada klasi $\mathcal{P}$. Iako u praksi često ne postiže dobre  performanse kao i simpleks metod, te se uvijek prvo preporučuje korištenje simpleks metoda u rješavanju LP-a, ovaj metod je veoma važan sa teoretskog stanovišta.  \emph{Metod unutrašnje tačke} (eng. Interior point metod) je dizajniran 50-ih godina XX vijeka i sve do 80-ih godina nije bio smatran za algoritam koji se efikasno može primijeniti na probleme velikih dimenzija. Tek 1984.godine (N. Karmakar, inžinjer u IBM-u) je formalno dokazao da se ovaj algoritam izvršava u polinomijalnom broju koraka za probleme linearnog programiranja. U današnje vrijeme, usljed ekstremnog poboljšanja performansi mašina, pokazalo se da je \emph{metod unutrašnje tačke} kompetentan sa simpleks metodom kada je riječ o problemima LP-a  velikih dimenzija (sa matricom $A$ čiji je broj elemenata $10^9$ i više).

Za razliku od simpleks metoda, koji ``hoda'' po granicama poliedra (dopustivog regiona), \emph{metod unutrašnje tačke}, kako i samo ime kaže, se kreće po unutrašnjim tačkama poliedra  dok ne naiđe na optimalno rješenje problema. 

Postoji nekoliko metoda ove vrste, kao što su: metod centralne putanje, redukcija potencijala, afino skaliranje, itd. Mi ćemo u ovoj sekciji obratiti pažnju na metod centralne putanje. Da ponovimo, ova sekcija se bavi rješavanjem problema LP-a u obliku (\ref{eq:lp_equality_constraint}). 

Neka je par Primal-dual linearnih programa dat sa

$$ \begin{array}{lll}
	&\mbox{Primal}            & \mbox{Dual}     \\
	&\min  c^T x              & \max  b^T y \\
	& \mbox{s.t.} Ax = b      &   \mbox{s.t.} A^Ty + s = c \\
	& x \geq 0                &   s \geq 0
\end{array}
$$
\begin{definition}
Lagranžijan primal-dual linearnih programa definišemo sa 
\begin{equation}
	L(x,y) = c^Tx - y^T(Ax - b) - s^T x.
\end{equation}
\end{definition}

Vrijedi niz teorema koje obezbjeđuju dovoljne optimalne uslove za LP-a. U nastavku navodimo najvažnije od njih. 
%http://www.optimization-online.org/DB_FILE/2008/06/2024.pdf
\begin{thm}
	 Pretpostavimo da postoje $y \in \mathbb{R}^m, s \in \mathbb{R}^n$ tako da je 
	 \begin{align*}
	 	    &A^Ty + s = c \\
	 	    & s \geq 0.
	 \end{align*}
 Tada, ako je $x$ dopustivo rješenje za Primal, vrijedi 
 $$ c^T x - b^T y = s^T x \geq 0 .$$
\end{thm}
\begin{proof}
	 Pretpostavimo da je $x$ dopustivo za Primal (P). Tada vrijedi
	 $$ c^Tx = (A^Ty + s)^Tx = s^Tx + y^Tb \geq b^T y.$$
	 Dakle, pokazali smo tvrdnju. Štaviše, vrijednost $b^Ty$ je donja granica na optimalnu vrijednost Primala. Takođe, ako je $s^T x = 0$ donja granica je dostignuta, i $x$ je optimalno rješenje Primala.
\end{proof}
\begin{thm}
	Pretpostavimo da Primal ima barem jedno optimalno rješenje. Vektor $x \in \mathbb{R}^n$ je optimalno rješenje za Primal akko postoje $y \in \mathbb{R}^m, s\in \mathbb{R}^n$ tako da 
	\begin{align}
		  &A x= b \label{eq:oc1}\\
		  & x \geq 0 \label{eq:oc2}\\
		  & A^T y + s = 0 \label{eq:oc3}\\
		  & s \geq 0 \label{eq:oc4}\\
		  & s^T x = 0. \label{eq:oc5} 
	\end{align}
Optimalna vrijednost je data sa $b^T y$.
\end{thm}
\begin{proof}
 Za potrebne uslove, neka je $\tilde{x}$ optimalno rješenje za Primal. Zbog uslova dopustivosti za Primal, treba da vrijedi (\ref{eq:oc1}) i (\ref{eq:oc2}). Iz prethodne teoreme je pokazano da je optimalna vrijednost Primala  jednaka $b^Ty$ te dodatno da je $\tilde{x}$ optimalno samo ako je $s^T \tilde{x}=0$, pa vrijedi i (\ref{eq:oc5}).
 
 	Dovoljni uslovi se mogu pokazati na osnovu koraka konstrukcije simpleks metode  i teoreme o komplementarnosti. Dakle, ako postoje $x, y, s$ koji zadovoljavaju uslove optimalnosti, onda je $x$ optimalno rješenje.
\end{proof}

Drugi način da se dođe do uslova optimalnosti je preko Lagranžijana para Primal-Dual, tj. nalazak stacionarne tačke za $L$, odakle nalazimo optimalno rješenje (oba problema).  Uslovi za nalazak stacionarne tačke se mogu izvesti iz sistema
\begin{align}
	&\triangledown_x L(x,y) = 0\\
	&\triangledown_y L(x,y) = 0,
\end{align} 
što nas (uz uslov komplementarnosti za $x$ i $y$) ponovo dovodi do sistema:
\begin{align}
	&Ax = b \\
	&A^T y + s = c \\
	&XS\mathbf{1} = 0 \ (x_j \cdot s_j =0 , \forall j) \\
	&  (x, s ) \geq 0,
\end{align}
gdje je $X = diag (x_1, \ldots, x_n)$, $S= diag(s_1,\ldots s_m)$, $\mathbf{1}=(1,\ldots, 1)$. Ovaj sistem nazivamo \emph{uslov optimalnosti prvog reda za primal-dual par}. 

U nastavku navodimo pojam barijernog problema preko koga razvijamo metod unutrašnje tačke. Zamijenimo ograničenja nenegativnosti u primalnom problemu sa $-ln x_j$, $j=1,\ldots,n$.   
Primijetite da vrijedi 
$$\min e^{-\sum_{j=1}^n ln x_j} \Leftrightarrow \max \prod_{j} x_j $$
Dakle, minimizacija izraza $-\sum_{j=1}^n x_j$ je ekvivalentna maksimizaciji proizvoda udaljenosti od svih hiperravnima koje definišu prvi ortant. Dakle, ovakav optimizacioni problem (na prvom ortantu) nas sprečava da se vrijednost neke od varijabli $x_j$ približi nuli (uprkos nenegativnim ograničenjima).  Na osnovu ovih činjenica, definišimo sljedeći optimizacioni problem. 

\begin{definition}
	Barijerni program  primala je dat u obliku 
	\begin{align*}
		&\min c^T x - \mu \sum_{j=1}^n ln(x_j) \\
		&{s.t. } A x = b \\
		& x \geq 0
	\end{align*}
\end{definition}
za neki $\mu >0$. Lagranžijan barijernog problema je dat sa 
$$  L(x, y, \mu) = c^T x - \mu \sum_{j=1}^n ln(x_j)  - y^T(Ax - b) $$
Sljedeću teoremu iz teorije optimizacije  za skalarne funkcije sa uslovnim ekstremima, koja je od bitne važnosti u daljem razmatranju, navodimo   bez dokaza. 
\begin{thm}
	Neka je data skalarna funkcija  $f:\mathbb{R}^n \mapsto \mathbb{R}$ na skupu $g_1(x)=g_2(x)= \cdots = g_m(x) =0$ koja ima minimum u $x^*$. Onda vrijedi 
	$$ \triangledown f (x^*) = \sum_{i=1}^m y_i \triangledown g_i(x^*),$$
	gdje se $y_i$ nazivaju Lagranžovi množitelji. 
\end{thm}

Primijetimo da u barijarnom problemu imamo sljedeće:
\begin{itemize}
	\item $f(x) = \min c^T x - \mu \sum_{j=1}^n ln(x_j) $;
	\item $g_i(x) = a_i x - b_i$.
\end{itemize}
Izračunajmo Lagranžove množitelje ovih funkcija. Vrijedi:

$$c + \mu (\frac{1}{x_1}, \frac{1}{x_2}, \ldots, \frac{1}{x_n}) = \triangledown f (x) =\sum_{i=1}^m y_i \triangledown g_i(x) = \sum_{i} y_i a_i = A^T y.$$ 

Uvedimo nenegativni vektor $s =\mu \cdot (\frac{1}{x_1}, \frac{1}{x_2}, \ldots, \frac{1}{x_n})$, pa imamo da bilo koje optimalno rješenje početnog problema treba da zadovoljava \emph{uslove optimalnosti prvog reda za barijerni problem}:
\begin{align}
	&A x = b \nonumber \\
	&A^T y + s = c  \nonumber \\
	& (s_1 x_1, \ldots, s_m x_m) = (\mu, \ldots, \mu) \label{eq:primal-dual-central-path-problem} \\
	& x, s \geq 0. \nonumber
\end{align}
Primijetimo da ovaj uslov aproksimira iste uslove za primal-dual par.  
interesantno je da parametar $\mu$ kontroliše udaljenost od optimalnosti, tj. 
$$ c^T x - b^T y = c^T x - x^T A y = x^T(c- A^Ty ) = x^T s = n \mu.$$
 Uslovi~(\ref{eq:primal-dual-central-path-problem}) ne daju linearni sistem, jer treće ograničenje  nije linearno.

\begin{definition}
	Primal-dual centralni put $\{(x(\mu), y(\mu), s(\mu)) \in \mathbb{R}^{2n + m} \mid \mu > 0, x(\mu) >0, s(\mu)>0 \}$ je (jedinstveno) rješenje koje zadovoljava uslove (\ref{eq:primal-dual-central-path-problem}) parametrizovano sa $\mu$. 
\end{definition}

Primijetimo sljedeće, ako se u problemu (\ref{eq:primal-dual-central-path-problem}) stavi $\mu = 0$, onda imamo 
\begin{align*}
	&(s_1 x_1, \ldots, s_m x_m) = (0, \ldots, 0) \\
	&\Longleftrightarrow s^T x = 0  \Longleftrightarrow (A^T y - c)^T x = 0 \\
	&\Longleftrightarrow y^T A x - c^T x = 0 \Longleftrightarrow y^T b = c^Tx
\end{align*}
jer je $Ax = b$. Takođe, primijetimo da   vrijednost (optimalnih) dualnih promjenjivih $y$ upravo odgovara vrijednosti Lagranžovih množitelja. Takođe, kako $\mu$ teži ka nuli,   (\ref{eq:primal-dual-central-path-problem}) sve preciznije aproksimira rješenja početnog problema (\ref{eq:lp_equality_constraint}). 

Da bi došli do koraka samog algoritma, uvedimo notaciju 
$$ F(x, y, s) = \left (\begin{array}{c}
	Ax - b           \\
	A^T y + s - c     \\
	X S \textbf{1}                   
\end{array} \right ),$$
gdje je  $X = diag (x_1, \ldots, x_n ), S = diag(s_1,\ldots, s_n)$ i 
$\textbf{1} = diag (1,\ldots, 1)$. Primijetimo da je $X S \textbf{1}=\sum_{i} s_i x_i$. 
Potrebno je riješiti $F(x, y, s ) = 0, x,s \geq 0$. Korjen ove (nelinearne) jednačine ćemo naći uz pomoć \emph{Njutnovog metoda}, tj. riješimo (\ref{eq:primal-dual-central-path-problem}) uz pomoć ovog metoda. 

U nastavku u sažetom obliku izlažemo ideju Njutnovog metoda, jednog od najefikasnijih metoda za rješavanje ovakvih (nelinearnih sistema) jednačina. Neka je data diferencijalna funkcija $f: \mathbb{R}^n \mapsto \mathbb{R}$.   Tangentna linija 
$$z - f(x^k) = \triangledown f(x^k) (x - x^k) $$
je lokalna aproksimacija grafa funkcije $f(x)$ oko dte tačke. Mijenjajući $z=0$, definiše se nova tačka 
\begin{equation} \label{eq:newton-step}
	x^{k+1} = x^k - (\triangledown f(x^k))^{-1} f(x^k).
\end{equation}
Pokazuje se da niz $\{x^k\}_{k \in \mathbb{N}}$ definisan uz pomoć (\ref{eq:newton-step}) konvergira ka stacionarnoj tački funkcije $f(x)$. Simulacija koraka Njutnovog metoda je data na Slici~\ref{fig:newton}. 

\begin{figure}[!ht]
	%    \centering
	\begin{tikzpicture}[thick,yscale=0.6,xscale=0.8]
		
		% Axes
		\draw[-latex,name path=xaxis] (-1,0) -- (12,0) node[above]{\large $x$};
		\draw[-latex] (0,-2) -- (0,8)node[right]{\large $y$};;
		
		% Function plot
		\draw[ultra thick, orange,name path=function]  plot[smooth,domain=1:9.5] (\x, {0.1*\x^2-1.5}) node[left]{$f(x)$};
		
		% plot tangent line
		\node[violet,right=0.2cm] at (8,4.9) { tangenta};
		
		\draw[gray,thin,dotted] (8,0) -- (8,4.9) node[circle,fill,inner sep=2pt]{};
		\draw[dashed, violet,name path=Tfunction]  plot[smooth,domain=4.25:9.5] (\x, {1.6*\x-7.9});
		
		% x-axis labels
		\draw (8,0.1) -- (8,-0.1) node[below] {$x^{k}$};
		\draw [name intersections={of=Tfunction and xaxis}] ($(intersection-1)+(0,0.1)$) -- ++(0,-0.2) node[below,fill=white] {$x^{k+1}$} ;
	\end{tikzpicture}
	\caption{Njutnova metoda u ravni.}
	\label{fig:newton}
\end{figure}
%\begin{figure}[!ht]
%    \centering
%    \includegraphics[width=170pt,height=170pt]{newton.jpg}
%    \caption{Demonstracija njutnovog metoda u ravni.}
%    \label{fig:newton}
%\end{figure}
Rješavanje nelinearnih sistema se može generalizovati na funkcije više promjenjivih, za  više informacija pogledati na \url{http://www.ohiouniversityfaculty.com/youngt/IntNumMeth/lecture13.pdf}. 


Primijenimo ovu metodu na nalaženje nule funkcije $F(x,y,s)$. Tada imamo
$$ \triangledown F =\left ( \begin{array}{ccc}
	A   & 0      &  0      \\
	0   & A^T    &  I      \\
	S   & 0      & X       \\
\end{array} \right ) 
$$
Prema tome, u fiksnoj tački $(x,y,s)$, Njutnov pravac (pomjeraj)
$
\begin{pmatrix}
	\bigtriangleup  x  \\
	\bigtriangleup  y  \\
	\bigtriangleup  s  \\
\end{pmatrix}
$
%$\bigtriangleup x = x^{k+1} - x^{k}, \bigtriangleup y = y^{k+1} - y^{k}, \bigtriangleup s = s^{k+1} - s^{k}$
se izračunava rješavajući sistem linearnih jednačina:

\begin{equation}
	\begin{pmatrix}
		A   & 0      &  0      \\
		0   & A^T    &  I      \\
		S   & 0      & X       \\
	\end{pmatrix}  
	\begin{pmatrix} 
		\bigtriangleup  x  \\
		\bigtriangleup  y  \\
		\bigtriangleup  s  \\
	\end{pmatrix} 
	= 
	\begin{pmatrix} 
		b - Ax             \\
		c - A^T y - s      \\
		- X S \textbf{1}  \\                   
	\end{pmatrix} 
\end{equation}
iz koga se potom računaju tačke naredne  iteracije. 
Njutnov metod će u nekoj iteracija obično narušiti uslove $x,s \geq 0$, ali to se može izbjeći (biće prikazano u nastavku).  
Prethodno izloženo se može lako proširiti i na slučaj kada ne vrijedi $s_ix_i = 0$, tj. kada je $\frac{1}{n}s_ix_i = \mu, \mu > 0$, $i=1,\ldots,n$. Na sličan način računamo Njutnov pravac u smijeru $s_i x_i \approx \mu \theta$, za  $\theta >0$, iz sistema 

\begin{equation} \label{eq:newton-interior-system-k}    
	\begin{pmatrix}
		A   & 0      &  0      \\
		0   & A^T    &  I      \\
		S   & 0      & X       \\
	\end{pmatrix} 
	\cdot 
	\begin{pmatrix}
		\bigtriangleup  x  \\
		\bigtriangleup  y  \\
		\bigtriangleup  s  \\
	\end{pmatrix} 
	=
	\begin{pmatrix}
		b - Ax           \\
		c - A^T y - s      \\
		\theta \mu \mathbf{1} - X S \textbf{1}                      
	\end{pmatrix}
\end{equation}

%https://www.youtube.com/watch?v=Zf_bn3jJFKY&list=WL&index=9&t=647s
\emph{Algoritam unutrašnje tačke} se sastoji od sljedećih koraka:
\begin{enumerate}
	\item Inicijalizujemo $k=0$, te proizvoljno  $(x^k, y^k, s^k), x^k, s^k \geq 0$, $x^k,s^k \in \mathbb{R}^n, y^k \in \mathbb{R}^m$.
	\item Izaberimo $ \theta^k \in [0, 1)$ te riješimo sistem (\ref{eq:newton-interior-system-k}) za $(x^k,y^k,s^k)$ i odabran $\theta = \theta_k$ te $\mu = \mu^k = (y^k)^T s^k $,  odakle   dobijamo
	$  
	\begin{pmatrix}
		\bigtriangleup x^k      \\
		\bigtriangleup y^k       \\
		\bigtriangleup s^k       \\
	\end{pmatrix}    
	$
	
	\item $ 
	\begin{pmatrix}
		x^{k+1}  \\
		y^{k+1}   \\
		s^{k+1}   \\
	\end{pmatrix} \approx
	\begin{pmatrix}
		x^k  \\
		y^k  \\
		s^k  \\
	\end{pmatrix} +   
	\alpha_k 
	\begin{pmatrix}
		\bigtriangleup x^k       \\
		\bigtriangleup y^k       \\
		\bigtriangleup s^k       \\
	\end{pmatrix}  
	$, gdje je $\alpha_k$ izabran na taj način da $(x^{k+1}, s^{k+1}) > 0$, tj. da bi se očuvala dopustivost rješenja. 
	\item Ažurirajmo $k = k + 1$, te se vratimo na korak 2.
\end{enumerate}
Primijetimo da $\mu \rightarrow 0$, kako $k \rightarrow \infty$. U praksi se često stavlja $\theta^k = 1 - \frac{\beta}{n}$, za $\beta \in (0,1)$, a najčešće $\beta= 0.1$.  Parametar $\beta$ upravlja brzinom progresa prema optimalnom rješenju.  


Može se pokazati sljedeća teorema koja karakteriše \emph{metod unutrašnje tačke}.

\begin{thm}
	\begin{itemize}
		\item Algoritam unutrašnje tačke konvergira ka optimalnom rješenju problema (\ref{eq:lp_equality_constraint}). %Dualna granica se smanjuje $1 - \frac{\beta}{n}$ pri svakom koraku.
		\item U svim iteracijama, algoritam generiše dopustive tačke.
		\item Kompleksnost algoritma je $O(\sqrt{n})$. %Dakle,  broj iteracija  proporcionalan $\sqrt{n}$ je neophodan  algoritmu unutrašnje tačke riješi problem. 
	\end{itemize}
\end{thm}

Da bi se uvidjele sličnosti i razlike između simpleks metode i Metode unutrašnje tačke, pogledajte Slike \ref{fig:optimality-approaching-simplex} i  \ref{fig:optimality-approaching-interior}. U njima možete vidjeti kako metod pristupa pretrazi optimalnih rješenja. 

\begin{figure}
	 	\begin{subfigure}{.45\textwidth}
	 	\centering
	 	% include first image
	 	\includegraphics[width=.9\linewidth]{interior-1}  
	 \end{subfigure}
 	 	\begin{subfigure}{.45\textwidth}
 	\centering
 	% include first image
 	\includegraphics[width=.9\linewidth]{interior-2}  
 \end{subfigure}
  \caption{Prilazak optimalnosti kod Simpleks metode.}
   \label{fig:optimality-approaching-simplex}
\end{figure}


\begin{figure}
	\begin{subfigure}{.45\textwidth}
	\centering
	% include first image
	\includegraphics[width=.9\linewidth]{interior-3}  
\end{subfigure}
\begin{subfigure}{.45\textwidth}
	\centering
	% include first image
	\includegraphics[width=.9\linewidth]{interior-4}  
\end{subfigure}
  \caption{Prilazak optimalnosti kod Metode unutrašnje tačke.}
   \label{fig:optimality-approaching-interior}
\end{figure}
Paralelizovani objektno orjentisani optimizacioni siftver baziran na metodi unutrašnje tačke se može naći na 
\url{https://www.maths.ed.ac.uk/~gondzio/parallel/solver.html}.  \\

%https://optimization.cbe.cornell.edu/index.php?title=Interior-point_method_for_LP
\begin{comment}

\emph{\textbf{Primjer.}} Riješimo sljedeći primjer LP-a pomoću metoda unutrašnje tačke:
\begin{align*}
	&\max 3 x_1 + 3 x_2 \\
	&\mbox{s.t.} \\
	& x_1 + x_2 \leq 4 \\
	& x_1, x_2 \geq 0.
\end{align*}

\emph{Rješenje.}  Formirajmo Lagranžovu funkciju početnog problema koristeći ciljnu funkciju barijernog problema sa:  
\begin{align*}
   L(x, y, \mu) = 	  3 x_1 + 3 x_2 -\mu ln x_1 - \mu ln x_2 + y_1(4- x_1 - x_2 - s_1).  
\end{align*}
Barijerna funkcija je uvijek konkavna, a kako maksimizujemo,  tako da posjeduje tačno rješenje.  Sada nađimo maksimum date funkcije što radimo derivirajući funkciju $L$ (nalaženje parcijalnih derivacija):
\begin{align*}
	 &\triangledown_{x_1} L   =  3 - \frac{\mu}{x_1}  - y_1 = 0 \\
	 &\triangledown_{x_2} L   =  3 - \frac{\mu}{x_2} - y_1 = 0 \\
	 &\triangledown_{y} L   = {4-x_1-x_2 - s_1} = 0 \\
	 &\triangledown_{s} L   = { y_1} = 0 
\end{align*}
Odakle imamo zbog simetrije prve i druge jednakosti, da je  $x_1 = x_2$, dok je $y(\mu) = 0$. pa prema tome je 
%$$  3 - \frac{\mu}{x_1}  = 0$$
%što je ekvivalentno   sa:
%\begin{align} \label{eq:example-interior-point}
%   3x_1 - \mu = 0 \Rightarrow x_1 = x_2 = \frac{\mu}{3}.
%\end{align} 
Iz trečeg uslova   $x_1(\mu)=x_2(\mu)=2$, što je i optimum. Primijetimo da ovdje nije bilo potrebe za iterativnim postupkom i računanja Njutnovog koraka (koji je konstantan u svim iteracijama). 
%Kako je ovo kvadratna jednačina, koja je može eksplicitno riješiti, ne treba primjenjivati Njutnov iteracioni postupak (iako bi rješavanje ovakve jednačine takođe bilo moguće pomoću takvog metoda). Dakle, rješenje jednačine (\ref{eq:example-interior-point}) je:
%\begin{align}
%	x_1 = \frac{3(4-\mu) \pm \sqrt{9(4-\mu)^2 - 96 \mu}} { 12} = x_2
%\end{align}
% dualni simpleks metod ==> 4.7 PRIMAL-DUAL ALGORITHMS
% Ako bi uzeli $\mu = 1$, rješenje koje se dobije je 
 \end{comment}
\section{Farkašova lema}
Još jedna primjena teorije dualnosti u LP-u se ogleda u dokazivanju sljedeće teoreme alternativnosti.

\begin{thm}
	Neka je $A\in \mathbb{R}^{m \times n}$ matica i $c\in \mathrm{R}^n$. Onda jedna i samo jedna od dva sljedeća sistema ima rješenje:
	\begin{enumerate}
		\item  $Ax \geq 0$  i $c^T x < 0$; \label{case:1}
		\item $A^T y = c$ i $y \geq 0$. \label{case:2}
	\end{enumerate}
\end{thm}
\begin{proof}
	  Pogledajmo prvi sistem. Uočimo sličnosti sa Primalnom problemu. Posmatrajmo sljedeći LP:
	  \begin{align*}
	  	 &\min c^T x \\
	  	 &s.t. \\
	  	 & A x \geq 0.
	  \end{align*}
  Šta se može reći o ovom LP-u? Ako pogledamo desnu stranu ograničenja, vidimo da je vektor $x = 0$ 
  dopustivo rješenje problema, tako da problem ima barem jedno dopustivo rješenje. Zaključujemo da naš LP može da bude ili optimalan ili neograničen. Posmatrajmo njegov dual   dat sa 
  \begin{align*}
  	   &\max 0 \\
  	   &s.t. \\
  	   & A^T y  = c \\
  	   & y \geq 0.
  \end{align*}
  Primijetimo da ako postoji barem jedno dopustivo rješenje za prethodni dual, optimalno rješenje je 0. Ako ne postoji niti jedno dopustivo rješenje, problem nije dopustiv. 
  
  Ono što zaključujemo iz odnosa definisanog primala i njegovog duala je:
  \begin{itemize}
  	\item primal je optimalan akko je dual optimalan; 
  	\item primal je neograničen  akko je njegov dual nije dopustiv.  
  \end{itemize}
  Odgovorimo sada na pitanje Kada je primal optimalan. Ono što vidimo je da ako bi $x$ bio dopustiv tako da je $c^Tx < 0$ to bi onda i bilo koje $kx$, za proizvoljno $k>0$ bilo takođe dopustivo. Iz toga bi slijedilo da vrijednost funkcije cilja nije ograničena odozdo, tj. teži ka -$\infty$. Dakle, u tom slučaju je problem neograničen. Zaključujemo, kad god je primal optimalan, ta vrijednost mora biti 0, i dostiže se za $x =0$; inače je problem neograničen. Dalje, ako je primal optimalan, to  je ekvivalentno da tim da je sistem iz slučaja (\ref{case:1}) nedopustiv (nema rješenja).  Ako sistem iz slučaja (\ref{case:1}) ima rješenje, primal je neograničen (vrijedi i obrnut smijer). Ako pogledamo   dualni problem, dual je optimalan akko sistem iz  slučaja (\ref{case:2}) ima rješenje. Slično, dual nije dopustiv akko je sistem iz  slučaja (\ref{case:2}) nedopustiv (nema rješenje). Iz niza prethodnih ekvivalencija, zaključujemo da vrijedi: 
  \begin{itemize}
  	  \item Sistem iz  slučaja (\ref{case:1}) nema rješenja akko sistem iz  slučaja (\ref{case:2}) ima rješenje. 
  	  \item Sistem iz  slučaja (\ref{case:1}) ima rješenja akko sistem iz  slučaja (\ref{case:2}) nema rješenje. 
   \end{itemize}
\end{proof}\\

\emph{Geometrijska interpretacija Farkašove leme.}
Neka je dat sistem:
\begin{align*}
	&x_1 + 4 x_2  < 0: c^T x\\ \hline
	& 2 x_1 + 3 x_2 \geq 0 \\
	& 3 x_1 + 2 x_2 \geq 0 \\
	& 4 x_1 + x_2 \geq 0 \\
	& -x_1 + 3 x_2 \geq 0: Ax \geq 0.
\end{align*}

Pogledajmo kako izgleda sistem iz slučaja (\ref{case:2}). On je dat sa:
\begin{align*}
	&2 y_1 + 3 y_2 + 4 y_3 - y_4 = 1\\
	&3y_1 + 2 y_2 + y_3 + 3 y_4 = 4 \\
	& y_1, y_2, y_3, y_4 \geq 0. 
\end{align*}
\begin{figure}[!ht]
	\centering
	\includegraphics[width=320pt, height=250pt]{farkas-geometry.eps}
	\vspace{-1cm}
	\caption{Geometrijska interpretacija Farkašove leme.}
	\label{fig:farkas-slika}
\end{figure}
U osnovi geometrijska interpretacija nam kaže da se vektor $c =(1,4)^T$ može predstaviti kao linearna kombinacija vekotora vrsta matrice $A$, kao što vidimo na slici~\ref{fig:farkas-slika} jer se nalazi unutar prostora upregnutog sa vektorima $a_1, \ldots, a_n$.  To implicira da početni sistem nema rješenje. 
Kada bi postavili $c=(5,0)^T$, dobili bi da se on ne može izraziti preko vektora vrste matrice $A$ (jer je van prostora upregnutog sa vektrima vrste), pa prema tome početni problem za ovu konfiguraciju ima rješenje.  

%Fourier–Motzkin elimination ==> Problem dopustivosti...
\section{Fourier–Motzkin-ova Eliminacija}
%https://faculty.math.illinois.edu/~mlavrov/docs/482-fall-2019/lecture19.pdf
Vezano pitanje za problem  LP-a koji se rješava  je sljedeće:
\emph{Neka su date matrica $A$ i vektor $b$, da li je skup $P = \{x: A x \leq b\}$ neprazan?} Dakle, da li postoji dopustivo rješenje linearnog programa? 

Problem dopustivosti može da služi i da odgovorimo sljedeće pitanje: 
\emph{Da li je optimalna vrijednost funkcije cilja problema LP-a veća od neke unaprijed zadate  vrijednosti k?}.
 Na ovo pitanje možemo odgovoriti pomoću Fourier–Motzkin-ove eliminacije, koja je potpuno drugačija od simpleks metode te je zbog toga i navedena u ovoj knjizi. Ideja algoritma se sastoji od procedure koja će redukovati problem sa $n$ varijabli na ekvivalentan problem sa $n-1$ varijabli. Ekvivalentnost se podrazumijeva u pogledu da početi problem ima riješenje akko ima i redukovani problem. Ova procedura se iterativno izvršava, smanjujući broj varijabli u problemu u svakom koraku. Na kraju ćemo eventualno ostati sa sitemom od jedne varijable za koji se lako može provjeriti da li postoji barem jedna tačka između najveće gornje granice i najmanje donje granice koja zadovoljava uslove. 
 
 Glavni korak ovog metoda je redukcija problema na ekvivalentan problem sa manjim brojem varijabli. Pretpostavimo da imamo varijable $x_1,\ldots, x_n$ i da želimo da eliminišemo varijablu $x_n$. za svaku od ograničenja
 \begin{equation}\label{eq:inequality_i}
      a_{i,1} x_1 + \cdots + a_{i,n} x_n \leq b_i
 \end{equation}
 vrijedi jedna od sljedećih alternativa 
 \begin{itemize}
 	 \item  $x_n \geq \frac{b_i - a_{i,1}x_1- \cdots - a_{i, n-1} x_{n-1} }{a_{i,n}}=U_i$ ili 
 	 \item   $x_n \leq \frac{b_i - a_{i,1}x_1- \cdots - a_{i, n-1} x_{n-1} }{a_{i,n}}=L_i$
 \end{itemize}
 $i=1,\ldots, m$, zavisno od toga da li je $a_{i,n} >0$ ili $a_{i,n} <0$. U slučaju da je $a_{i,n} = 0$,  ostavljamo  ogranjičenje (\ref{eq:inequality_i}) kakvo i jeste (jer $x_n$ ne učestvuje u datoj nejednakosti). Na ovaj način ćemo dobiti $m$ gornjih i donjih granica za $x_n$ koje se dobijaju preko $n-1$ varijabli, tj. 
 $$  x_n \geq L_1, \ldots, x_n\geq L_k \mbox{ te }  x_n \leq U_1, \ldots, x_n \leq U_l.$$
  
 Moguće je izabrati $x_n$ koje zadovoljava ovih $k \cdot l$ ograničenja akko 
 \begin{equation}\label{eq:min_max_xi}
     \max\{L_1,\ldots, L_k \} \leq x_n \leq \min \{ U_1, \ldots, U_l \},
   \end{equation}
   
 jer bi moralo da postoji nešto između najveće donje granice za vrijednost varijable $x_n$ te njegove najmanje gornje granice. Međutim, kako su sve donje i gornje granice izražene preko nepoznatih $x_1, \ldots, x_{n-1}$,  u (\ref{eq:min_max_xi}) jednakost se ne može samo tako napisati, pa napišemo sljedeće nejednakosti 
 $$\begin{array}{cccc}
       L_1 \leq U_1 & L_1 \leq U_2   &  \cdots   & L_1 \leq U_l \\
       L_2 \leq U_1 & L_2  \leq U_2  &  \cdots   & L_2 \leq U_l \\
       \vdots       &     \vdots     &   \ddots  & \vdots       \\
       L_k \leq U_m &  L_k \leq U_2  &   \cdots  & L_k \leq U_l \\
 \end{array}$$ 
Ako postoji neka vrijednost  $x_n$ koja zadovoljava sva ograničenja, onda je za sve $i,j$, 
$L_i \leq x_n \leq U_j$. Obrnuto, ako svi ovih $k \cdot l$ nejednakosti vrijede, onda vrijedi i (\ref{eq:min_max_xi}), pa se može izabrati neki $x_n$ između ove dvije ($\max$ i $\min$) vrijednosti. 

Prema tome, početni problem je redukovan na sistem od $n-1$ varijabli sa dodatnih  $k \cdot l$ nejednakosti gore opisanih uz originalna ograničenja koja ne uključuju $x_n$ u sebi. Ovaj proces nastavimo iterativno dok ne dobijemo samo jednu promjenjivu, te potom (trivijalno) riješimo sistem. 

\emph{\textbf{Primjer.}} Pretpostavimo da nam je dat sistem nejednačina:
\begin{align*}
	 &x - y \geq 1 \\
	 &-x + 2y \geq 1 \\
	 & 3x + 5y \geq 1 \\
	 & x,y \geq 0.
\end{align*}
Eliminišimo varijablu $y$ iz sistema. Kako je $x-y \leq 1 \Rightarrow y \leq x -1 $, 
$-x + 2y \geq 1 \Rightarrow y \geq \frac{x+1}{2}$, te $ 3x - 5y \geq 1 \Rightarrow y \leq \frac{3x-1}{5}$, uparimo gornje i donje granice te dobijamo 
 $$
 \begin{cases}
 	&\frac{x+1}{2} \leq x-1 \\
 	& 0 \leq x-1 \\
 	& \frac{x+1}{2} \leq \frac{3x-1}{5} \\
 	& 0 \leq \frac{3x-1}{5} \\
 	& x \geq 0, y \geq 0.  	
 \end{cases}
 $$
Ove nejednakosti se mogu pojednostaviti u donje i gornje granice za $x$, dato sa:
$$
\begin{cases}
    &x \geq 3 \\
    & x \geq 1 \\
    & x \geq 7 \\
    & x \geq \frac{1}{3} \\
    & x \geq 0.	
\end{cases}
$$
Sve ove nejednakosti su donje granice. Prema tome, ako $x=7$, vidimo da će ta vrijednost proći. 
Tada, donje i gornje granice za $y$ postaju uslovi (pogledati gore): $y \leq 6, y \geq 4, y \leq 4$ te $y \geq 0$. Prema tome, možemo staviti $y=4$ i naći dopustivo rješenje. 

%kompleksnost i Farkasova lema...
%  dualna simpleks metoda ? https://www.youtube.com/watch?v=lyNHVnT9zVk&list=PLY9yf2-4yyeT0Jh80w5yuevm0o9lAAUJg&index=40
\vspace{1.5cm}
\textbf{\large Zadaci}
\begin{enumerate}
	\item %http://www.nitjsr.ac.in/course_assignment/CA02CA3103%20RMTLPP:%20Duality.pdf
	Napišite odgovarajući dual linearnog programa:
	\begin{align*}
		 &\max x_1 - x_2 + 3 x_3 \\
		 & s.t. \\
		 & x_1 + x_2 + x_3 \leq 10 \\
		 & 2x_1 - x_2 - x_3 \leq 2 \\
		 & 2x_1 - 2x_2 - 3 x_3 \leq 6 \\
		 & x_1, x_2, x_3 \geq 0.
	\end{align*}
 \item    	Napišite odgovarajući dual linearnog programa:
      \begin{align*}
      	  &\min 3 x_1 - 2 x_2 + 4 x_3 \\
      	  & s.t. \\
      	  & 3x_1 + 5 x_2 + 4 x_3 \geq 7 \\
      	  & 6 x_1 + x_2 + 3 x_3 \geq 4 \\
      	  & 7 x_1 - 2 x_2 - x_3 \leq 10 \\
      	  & x_1 - 2 x_2 + 5 x_3 \geq 3 \\
      	  & 4 x_1 + 7 x_2 - 2 x_3 \geq 2 \\
      	  & x_1, x_2, x_3 \geq 0.
      \end{align*}
  \item Napišite dual sljedećeg linearnog programa:
  \begin{align*}
        &\min x_1 - 3 x_2 - 2 x_3 \\
        & s.t. \\
        & 3 x_1 - x_2 + 2 x_3 \leq 7 \\
        & 2 x_1 - 4 x_2 \geq 12 \\
        & -4x_1 + 3x_2 + 8 x_3 = 10 \\
        & x_1, x_1 \geq 0 \\
        & x_3 \in \mathbb{R}. 
  \end{align*}
\item %http://www.nitjsr.ac.in/course_assignment/CA02CA3103%20RMTLPP:%20Duality.pdf
Pokazati da je dual dualnog problema ponovo primalni problem (P).
\item Ako je primalni problem (P) neograničen (ima neograničenu funkciju cilja), njegov dual nije dopustiv.
\item Istražiti verziju simpleks metoda zvanu \emph{Dualni simpleks metod}.
\item Koristeći Farkaš-ovu lemu, pokazati sljedeći rezultat. 
 
	Tačno jedan od sljedećih sistema ima rješenje:%https://web.stanford.edu/class/msande310/hw2sol.pdf
	\begin{enumerate}
		\item $Ax > 0$; 
		\item $y^T A = 0, y \geq 0, y \neq 0.$
	\end{enumerate}
 \item Koristeći Farkaš-ovu lemu, pokazati sljedeći rezultat. 	Tačno jedan od sljedećih sistema ima rješenje:%https://web.stanford.edu/class/msande310/hw2sol.pdf
 \begin{enumerate}
 	\item $Ax \leq b$; 
 	\item $y^T A = 0, y^T b < 0, y \geq 0.$
 \end{enumerate}
 \item  %https://www.cs.cmu.edu/~odonnell/toolkit13/lecture13-anonymous.pdf
 Koristeći Furijer-Motzkin-ovu eliminaciju, pokazati da postoji rješenje za sljedeći sistem nejednačina:
 \begin{align*} 
 	&x - 5y + 2 z \geq 7 \\
 	&3x - 2y - 6 z \geq -12 \\
 	& -2x + 5y - 4z \geq -10 \\
 	& -3x + 6y - 3z \geq -9 \\
 	& -10 y + z \geq -15 \\  
 \end{align*}
\item Pomoću Furijer-Motzkin-ovu eliminacije, pokazati sa je sistem 
\begin{align*}
	&x_1 \geq 0 \\
	&x_2 \geq 0 \\
	& x_1 + x_2 \leq -2
\end{align*}
nedopustiv.%https://people.inf.ethz.ch/fukudak/lect/opt2011/aopt11note4.pdf

\item Neka su $x^0$ i $y^0$ dopustive tačke za polazni (kanonski) LP i njegov dual. Dokazati da su te dvije tačke optimalne ako i samo ako važi 

$$\langle Ax^0-b,y^0\rangle=\langle A^Ty^0-c,x^0\rangle=0$$

\item Formirati dualan LP za problem
$$\min -x_1+2x_2+3x_3$$
pri uslovima
\begin{align}
	& x_1-x_2+2x_3=1\\
	& 2x_1+x_2\leqslant 3 \\
	& x \geq 0 \\
	& x_1\leqslant 0,\ x_2\geqslant 0, x_3\geqslant 0
\end{align}
pa riješiti oba problema.

\item Koristeći teoriju dualnosti, riješiti zadatak linearnog programiranja

$$\min x_1+x_2+\cdots nx_n$$

pri uslovima
$$
\begin{aligned}
	& x_1\geqslant 1\\
	& x_1+x_2\geqslant 2 \\
	& \cdots\\
	& x_1+x_2+\cdots+x_n\geqslant n\\
	&x_1\geqslant 0,\ x_2\geqslant 0,\cdots,x_n\geqslant 0,
\end{aligned}$$
\end{enumerate}
\newpage
\chapter{Cjelobrojno Programiranje}

%https://www.google.com/url?sa=t&source=web&rct=j&url=https://web.mit.edu/15.053/www/AMP-Chapter-09.pdf&ved=2ahUKEwiN0cef_f7xAhU0CRAIHWLqCw0QFjAfegQILBAC&usg=AOvVaw1cQCbZJQbc55Z0VLPue2ul
Nije realno očekivati da varijable odluke mogu da dobiju neprekidne vrijednosti u svim problemima. Recimo, ograničenja u problemu rasporeda ljudskih resursa po smjenama koje se tiču minimalnog broja osoblja potrebnog u svakoj od smjenama zahtjevaju varijable koje su diskretnog tipa. U slučaju da su sve varijable odluke u modelu problema cjelobrojne, riječ je o problemu cjelobrojnog programiranja (eng. \emph{Integer programming}). 
U ovom odjeljku ćemo se pozabaviti   \emph{cjelobrojnim linearnim programiranjem} (ILP) gdje se još pored integralnosti (cjelobrojnosti) varijabli zahtijeva da funkcija cilja kao i ograničenja u modelu budu linearni u svojim varijablama. Prema tome, ILP ima opšti oblik:
\begin{align}
    & \max c^T x \nonumber\\
    & A x \leq b \nonumber \\
    & x \geq 0 \nonumber\\
    & x_i \in \mathbb{Z}, \mbox{ za sve } i. \label{ilp-formulation}
\end{align}
U nastavku modelujmo nekoliko poznatih problema uz pomoć paradigme ILP-a. 

\section{Modelovanje nekih problema}

\emph{Problem ruksaka.} Neka je dato $n$ proizvoda i neka je težina $i$-tog proizvoda jednaka $w_i$, dok je vrijednost svakog od njih jednaka $c_i$, $i=1,\ldots,n$. Koje proizvode treba da stavimo u ruksak kapaciteta $C$ tako da je vrijednost proizvoda u ruksaku maksimalna. \\
\emph{Rješenje}. Definišimo varijable $x_i$ koje dobijaju vrijednost 1 ako odaberemo $i$-ti proizvod kojeg stavimo u ruksak, u protivnom 0, $i=1,\ldots,n$. Kapacitet ruksaka se modeluje ograničenjem $\sum_{i=1}^n w_i x_i \leq C$, dok je funkcija cilja ona koja maksimizuje profit odabranih proizvoda, dakle modeluje se uz pomoć linearne kombinacije $f(x) = \sum_{i=1}^n c_i x_i$. Time je problem modelovan.


\emph{Problem rasporeda}. Uprava bolnice želi da napravi raspored dežurstva po sedmičnim noćnim smjenama za svoje medicinske sestre. Potrebno je da broj medicinskih sestara za noćnu smjenu na $j$--ti dan bude barem (cio broj) $d_j, j = 1,\ldots 7$. Svaka
medicinska sestra radi pet dana zaredom u noćnoj smjeni. 

\emph{Zadatak: Pronaći minimalan broj medicinskih sestara koje bolnica treba zaposliti da bi se mogle napraviti takve smjene.}

\emph{Rješenje}. Označimo sa $x_i$ broj medicinskih sestara koje radnu smjenu započinju na $i$-ti dan. Potrebno je minimizovati funkciju 
$f = \sum_{i=1}^7 x_i$ pod uslovima da su ispunjeni zahtjevi za brojem medicinskih sestara, što je modelovano sa:
\begin{itemize}
	\item $x_1 + x_2 + x_3 + x_4 + x_5 \geq d_5 $
	\item $x_2 + x_3 + x_4 + x_5 + x_6 \geq d_6$
	\item $x_3 + x_4 + x_5 + x_6 + x_7 \geq d_7$
	\item $x_4 + x_5 + x_6 + x_7 + x_1 \geq d_1 $
	\item $x_5 + x_6 + x_7 + x_1 + x_2 + x_3 \geq d_2$
	\item $x_6 + x_7 + x_1 + x_2 + x_3 + x_4 \geq d_3$
	\item $x_6 + x_7 + x_1 + x_2 + x_3 + x_4 \geq d_4$
\end{itemize}
uz nenegativne uslove 
\begin{itemize}
	\item $x_i \geq 0, x_i \in \mathbb{Z}$, $j=1,\ldots,7.$
\end{itemize}
Primijetimo da su u ovom problemu varijable  cjelobrojne. Ovaj model pripada paradigmi cjelobrojnog linearnog programiranja.

\emph{Problem oglašavanja}. Kompanija želi da se oglašava u medijima. Postoji nekoliko alternativa oglašavanja:  televizijsko, novinsko i radio oglašavanje. Cijena svakog medija sa pokrivenošću publike navedena je u sljedećoj tabeli.

\begin{table}[!ht]
	\centering
	\begin{tabular}{l|c|c|c} \hline
		\                  & Televizija & Novine & Radio  \\ \hline
		Cijena po oglašavanju      & 2000       & 600    & 300    \\
		Broj gledalaca/slušalaca/čitalaca      & 1000      & 4000  & 1800 \\ \hline
	\end{tabular}
	\caption{Cijene reklama sa brojem gledalaca/slušalaca/čitalaca.}
	\label{tab:tab_model_advertising}
\end{table}

Novine ograničavaju broj oglasa za kompaniju na deset (po sedmici). Štaviše, kako bi se uravnotežilo oglašavanje između sve tri vrste medija, na radiju se ne smije pojaviti više od polovine ukupnog broja oglasa za kompaniju. Najmanje 10\% od svih oglasa bi se trebalo pojaviti na televiziji. Sedmični budžet za oglašavanje iznosi 18.200. 

\emph{Zadatak: Koliko oglasa treba zakupiti u svakoj od tri vrste medija u cilju povećavanja ukupnog broja gledalaca kompanije?}

\emph{Rješenje}.   Označimo sa $x_1$ broj oglasa na televiziji, sa $x_2$ broj oglasa u novinama i $x_3$ broj oglasa na radiju. Potrebno je maksimizovati   uspješnost oglašavanja, tj. funkciju 
$f(x) = 10 x_1 + 4 x_2 + 1.8 x_3.$ Uslovi pod kojima tražimo rješenja su modelovani na sljedeći način:
\begin{itemize}
	\item $2000 x_1 + 600 x_2 + 300 x_3 \leq 18.200$ (uslov za cijenu);
	\item  $ x_2 \leq 10$ (limit na broj reklama u novinama)
	\item $x_1 + x_2 \geq x_3$ (uslov za maksimalno polovinu oglašavanja na radiju) 
	\item ${x_1}\geq 0.1\cdot (x_1 + x_2 + x_3)$ (uslov za broj reklama na televiziji)
	\item $x_i \geq 0, x_i \in \mathbb{Z}, i=1,2,3$.
\end{itemize}

U ovom problemu možemo još primijetiti da u funkciji cilja   
nisu korišteni egzaktni koeficijenti (za broj gledalaca) već brojevi koji su proporcionalni nekoj vrijednosti (1000). Takve transformacije su invarijantne i ne utiču na potragu za optimalnim rješenjem  problema, a doprinose čitljivosti modela.


%https://www.math.unipd.it/~luigi/courses/metmodoc1819/m01.modelli.00.en.pdf
\emph{Problem pokrivanja}. Telefonska kompanija želi da instalira antene na neka mjesta kako bi pokrila šest oblasti. Postoji pet mjesta za antene. Nakon nekih simulacija, za svaku oblast utvrđen je intenzitet signala koji antena šalje, postavljena na određenom mjestu. Tabela~\ref{tab:tb-3} daje   primjer jedne instance problema sa nivoima intenziteta signala.

\begin{table}[!ht]
	\centering
	\begin{tabular}{c|cccccc} \hline
		\              & oblast1 & oblast 2 & oblast 3 & oblast 4 & oblast 5 & oblast 6 \\ \hline
		Mjesto $A$     & 10  & 20 & 16 & 25 & 0   & 10   \\
		Mjesto $B$     & 0   & 12 & 18 &  23 & 11 & 6   \\
		Mjesto $C$     & 21  &  8 & 5  &  6 & 23  &  19 \\
		Mjesto $D$    &  16 &  15 & 15 &  8 & 14 & 18   \\
		Mjesto $E $    &  21 & 13 & 13 & 17 & 18  & 22    \\ \hline
	\end{tabular}
	\caption{Intenziteti signala.}
	\label{tab:tb-3}
\end{table}

Prijemnici prepoznaju samo signale čija je udaljenost najmanje   $d$. Nadalje, nije moguće imati više od jednog signala koji dostiže udaljenost $d$ u istoj oblasti, inače bi to moglo da prouzrokuje smetnje. %Na kraju, antena se može postaviti na mjesto $E$ samo ako je antena instalirana i na mjestu $D$ (ova antena bi služila kao most). 
Kompanija želi da odredi gdje treba postaviti antene kako bi se pokrio maksimalanan broj oblasti sa signalom. 

%https://www.math.unipd.it/~luigi/courses/metmodoc1920/m01.modelli.00.en.beamer.pdf
\emph{Rješenje}. Posmatrajmo ovaj problem malo opštije i definišimo: 
\begin{itemize}
	\item $I$: skup mjesta;
	\item $J$: skup oblasti;
	\item $\sigma_{ij}$ : indikator nivoa signala antene   smještene u mjestu $i \in I$ u oblasti $j \in J$;
	\item $d$: parametar koji označava minimalni nivo signala koji je neophodan;
	\item $N$: parametar koji označava maksimalni broj signala iznad granice koju prijemnik može da prepozna (u našoj instanci imamo da je $N=1$);
	\item $x_i$: binarna varijabla koja uzima vrijednost 1 ako je antena smještena u mjestu $i\in I$, 0 inače;
	\item  $z_j$ : binarna varijabla koja uzima vrijednost 1 ako je oblast $j \in J$ pokrivena signalom, 0 inače;
	\item $M_j$: dovoljno veliki parametar, npr. za svako mjesto $j \in J$, $M_j= card(\{ i \in I \mid \sigma_{ij} \geq d\})$.
\end{itemize}
Formulišimo sada (cjelobrojni) linearni program ovog problema. 
Funkcija cilja je data sa:
$$ f(x) = \sum_{j \in J} z_j \rightarrow \min $$
pod sljedećim uslovima 
\begin{itemize}
	\item  $ \sum_{\{i \in I \mid \sigma_{ij} \geq d \}} x_i \geq z_i, \forall j \in J $ (barem jedna antena treba da bude uključena da bi se oblast pokrila signalom)
	\item $ \sum_{\{i \in I \mid \sigma_{ij} \geq d \}} x_i  \leq N + M_j( 1 - z_j), \forall j \in J $ (maksimalan broj signala koje prijemnici mogu obraditi)  
	\item $x_i, z_j \in\{0, 1\}, \forall i \in I, \forall j \in J$
\end{itemize}
%\printbibliography[heading=subbibliography,notkeyword=this]

\emph{Problem lokacija}. Problemi s lokacijom često se postavljaju na sljedeći način: pretpostavimo da postoji $n$ postrojenja (prodavnica)  i  $m$ kupaca. Dva pitanja treba da budu riješena:
\begin{enumerate}
	\item koji od $n$ postrojenja otvoriti i
	\item koje  postrojenje koristiti za opsluživanje kojeg od kupaca, kako bi se zadovoljila fiksna potražnja svakog od kupaca uz minimalni trošak otvaranja postrojenja.
\end{enumerate}
Uvedimo sljedeću notaciju.
\begin{itemize}
	\item  $f_{i}$: označava (fiksni) trošak otvaranja postrojenja $i$, za  $ i = 1,  \ldots, n$;
	\item $c_{ij}$: označava troškove zadovoljenja potražnje  kupca $j$ od strane postrojenja $j$ (cijena dostave, cijena proizvoda itd.), $i = 1, \ldots, n$, $j = 1,  \ldots, m$;
	\item $d_{j}$: označava potražnju kupca $j$ za $j = 1, \ldots, m$;
	\item $u_{i}$: označava maksimalnu količinu proizvoda koji se mogu proizvesti u postrojenju $i$, tj. $u_{i}$ označava kapacitet objekta $i$.
\end{itemize}

\emph{Rješenje}. Funkcija cilja ima sljedeći oblik:
$$ f(x) = \sum_{i=1}^n f_i x_i  + \sum_{i,j} c_{ij} y_{ij} d_j,$$
gdje je
\begin{itemize}
	\item $x_i$: binarna varijabla koja ozačava da li je (1) ili nije (0) otvoreno postrojenje $i$;
	\item $y_{ij} \in \mathbb{R}^+$ realna varijabla, koja označava dio potražnje $d_j$ kupca $j$ ostvarena iz prodavnice $i$.
\end{itemize}
Ograničenja ovog modela su sljedeća:
\begin{itemize}
	\item $\sum_{i} y_{ij} = 1, \forall j\in\{1,\ldots,m\}$ (zahtjevi kupaca treba da budu ispunjeni)
	\item $\sum_{j} d_j y_{ij} \leq u_i x_i, \forall i \in \{1,\ldots,n\}$
\end{itemize}
Ovaj model pripada modelu \emph{mješovitnog linearnog programiranja}, gdje postoje varijable koje su cjelobrojne i neprekidne za isti model.

\emph{Problem postrojenja sa neograničenim kapacitetom.}
Čest slučaj gornjeg problema lokacija je slučaj kada je  $ u_{i} = + \infty,i=1\ldots,m$. U ovom slučaju je optimalna strategija zadovoljiti svu (ne parcijalnu) potražnju kupca $j$ iz najbližeg otvorenog objekta. Zbog toga neprekidne varijable  $y_{ij}$ možemo zamijeniti binarnim varijablama $z_{ij}$, $i=1,\ldots,n, j=1,\ldots,m$ pri čemu varijabla dobija vrijednost 1 ako je kupac $j$ snabdjeven od strane postrojenja $i$. Prema tome, model izgleda ovako:

\begin{align*}
	&\sum_{i=1}^n f_i x_i  + \sum_{i,j} c_{ij} z_{ij} d_j \rightarrow \min\\
	& s.t. \nonumber \\
	& \sum_{i} z_{ij} = 1, \forall j\in\{1,\ldots,m\} \\
	& \sum_{i,j} d_j z_{ij} \leq M x_i, \forall i \in \{1,\ldots,n\} \\
	& x_i, z_{ij} \in \{0,1\} \mbox{ za } i = 1, \ldots, n, j = 1,  \ldots, m.
\end{align*}
Vrijednost $M$ je konstanta koja uzima neku veliku vrijednost (zbir količine potražnji svih kupaca). Međutim, u praksi se često izbjegava upotreba $M$-konstante, te se tako ovo ograničenje zamjenjuje sa $ z_{ij} \leq x_i$ 
za $ i = 1, \ldots, n, j = 1,  \ldots, m$ koje osigurava bolje performanse jer se generišu preciznije linearne relaksacije o kojima će biti riječi u narednim sekcijama. Prethodni model spada u modele \emph{binarnog linearnog programiranja}. 

\emph{Problem rasporeda}. Čitava klasa problema koja se naziva sekvenciranje, raspoređivanje i usmjeravanje u osnovi su predstavljeni modelima cjelobrojnog programiranja. Kao primjer, recimo da je potrebno rasporediti studenate u  učionicu na takav način
da je minimizovan broj učenika koji ne mogu pohađati nastavu koja je njihov prvi izbor među svim ostalim izborima. Postoje ograničenja u pogledu broja i kapaciteta učionica dostupnih u bilo kom trenutku, dostupnosti predavača na fakultetu u određeno vrijeme i preferencijama studenata za određene rasporede. Jasno je da imamo varijablu $X_{i,j,n}$ za   $i$-tog studenta 
koji pohađa $j$-to predavanje tokom $n$-tog vremenskog perioda (recimo, vrijeme je diskretizovano po 45 min/čas) -- koja je jednaka 1 ako se student uklapa u takav raspored, inače 0. 

Posmatrajmo ipak malo specifičniji problem u odnosu na ovaj generalni (koji je dosta težak i za modeovanje, a kamoli za rješavanje). 
Razmotrimo raspoređivanje osoblja zaduženog za upravljanje letom aviona. 
Avionska kompanija mora rasporediti svoje osoblje na rutama koje pokrivaju sve letove. Treba paziti, na primjer, da jedna posada treba da upravlja letom iz  Beograda u Zagreb (u 10:00), a zatim letom iz Zagreba u Cirih (u 14:00). Dakle, jedna posada bi trebalo da je uključena u rutu na kojoj upravlja različitim letovima. Prema tome, raspoređujemo posadu na rutu $j$, modelovana uz pomoć binarne varijable 
$$x_j = \begin{cases}
    &1, \mbox{ ako je barem jedna posada prodružena ruti } j \\
    &0, \mbox{ inače}. 
\end{cases}
$$
Dalje, definišimo 
$$a_{ij}= \begin{cases}
             1,& \mbox{ ako je let } i \mbox{ pridružen ruti } j \\
             0,& \mbox{ inače}.
        \end{cases}
$$
Neka je $c_j$ cijena dodjeljivanja neke posade ruti $j$. Ovdje $a_{ij}$ definišu prihvatljive kombinacije letova sa rutama, uzimajući u obzir  karakteristike kao što su redoslijed krakova za uspostavljanje veza između letova sa uključenim vremenom  održavanja letova (iskrcavanje, istovaranje kofera, utovaranje novih kofera, ukrcavanje itd.) na istoj ruti leta posade.   

Model ovakvog problema je dat sa 
\begin{align}
    &\min \sum_{i=1}^n c_j x_j \nonumber\\
    & \sum_{j=1}^n a_{ij} x_j \geq 1, \forall i \in \{1,\ldots, n\} \label{ineq:set_cover} \\
    %&   a_{ij} \geq  x_j, \forall j \in \{1,\ldots, m\}  \\
    & x_i \in \{0, 1 \}, \forall i \in \{1, \ldots, n\} \\
    & a_{ij} \in \{0, 1\}, \forall i \in \{1, \ldots, n\}, j \in\{1,\ldots, m\} \nonumber
\end{align}
Ograničenje (\ref{ineq:set_cover}) je poznato ograničenje koje se javlja u pokrivanju problema skupa (eng. \emph{set covering problem}).

\emph{Problem trgovačkog putnika}. Problem je formulisan na slejdeći način. Krenuvši od svog mjesta, putnik želi da posjeti ostalih ($n-1$) gradova pod minimalnim troškovima i da se na kraju vrati na isto mjesto. U suštini, ovo je problem grafovske prirode gdje je ulaz (bez smanjenja opštosti) kompletan težinski graf, a potrebno je naći hamiltonovu konturu minimalne težine u datom grafu. Pod težinom konture se podrazumijeva zbir težina njenih grana. 

\emph{Rješenje}. Označimo težinu grane od grada $i$ do grada $j$ sa $c_{ij}$.  Definišimo (binarne) varijable 
$$x_{ij} = \begin{cases}
                1, \mbox{ ako putnik u svojoj ruti iz grada } i \mbox{ posjeti grad } j \\
                0, \mbox{ inače}. 
          \end{cases}$$ 
Potrebno je nametnuti sljedeća ograničenja -- svaki grad se treba naći u ruti,  što možemo postići sa 
$$  \sum_{i=1}^n x_{ij} = 1, \forall j =1,\ldots, n,$$ 
što znači da se iz tačno jednog grada dolazi u svaki grad $j$, dok sličnim jednakostima nametnemo da se iz grada $j$ odlazi u tačno jedan drugi grad sa:

$$  \sum_{j=1}^n x_{ij} = 1, \forall i =1,\ldots, n$$ 
 uz uslove $x_{ij}\geq 0$. Primijetimo sljedeće, ovakvi uslovi ne sprečavaju pojavu rješenja koja predstavljaju uniju disjunktnih podruta, što nije dopustivo u ovom slučaju. Ako pretpostavimo da je rješenje dato u obliku podruta $R_1, \ldots, R_k$, gdje je $R_i = \{ v_{i_1}, \ldots, v_{i_k} \}$, onda se može izbjeći pojava podruta dodavanjem dodatnih ograničenja u početni model problema, te ga takvog sukcesivno riješavati dodavanjem ograničenja dok god en dobijemo rješenje koje nije sastavljeno od više od jedne rute. Recimo, eliminacija pojave podrute $R_2$ (u odnosu na podrutu $R_1$) se vrši dodavanjem ograničenja:
 $$ \sum_{l=1}^{1_k}\sum_{t=1}^{2_k} x_{1_l, 2_t} \geq 1.$$
 U najgorem slučaju, potrebno je dodati $2^n-1$ ovakvih ograničenja da bi se dobilo dopustivo rješenje. 
 Generalno ograničenje koje služi za eliminaciju podtura u modelu TSP-a se može dodati sa:
 \begin{align}
 	  \sum_{i \in S} \sum_{i \notin S} x_{ij} \geq 2, \forall S \subset [n].
 \end{align}
  %Postoje i druga ograničenja koja mogu da se dodaju za eliminaciju podruta, bez gore pomenutog iterativnog procesa, ali o njima će biti riječi u narednim sekcijama. 
 
 \section{Neke tehnike u konstrukciji modela Cjelobrojnog Programiranja}
 
 \emph{Binarne varijable.} Pretpostavimo da je potrebno uključiti sljedeće aktivnosti: ($i$) izgraditi novo postrojenje ili
($ii$) poduzeti reklamnu kampanju ili ($iii$) razviti novi proizvod. Jasno je da su ove odluke korespondiraju ka logičkim odlukama da ili ne, pa ih, prema tome, modelujemo   uvodeći  (binarne) varijable $x_i \in \{0, 1 \}$, $i=1,2,3$. Često se nameće uslov da se najviše jedna od ovih odluka izvrši, što se modeluje sa $\sum_{i=1}^3 x_1 \leq 1$. Ovo ograničenje se obično naziva \emph{ograničenjem sa višestrukim izborom} (eng. \emph{multiple choice constraint}), jer se njime ograničava izbor odluka na najviše jednu od, u ovom slučaju, tri dostupne alternative. 


Pretpostavimo da proizvođač lijekova treba da odluči hoće li koristiti spremnik za fermentaciju u proizvodnji. Ako koristi spremnik, tehnologija obrade zahtijeva da se napravi $K$ jedinica ljekova. Dakle, količina proizvodnja $y$ dobija vrijednosti 0 ili $K$, a problem se može modelovati binarnom varijablom $x_j \in \{ 0, 1\}$, pa zamjenom $Kx_j$ za $y_i$. 

\emph{Logička ograničenja}. Jedno od najprostijih logičkih pitanja u matematičkom programiranju je da li dati izbor varijabli odluka zadovoljava ograničenje

\begin{equation}\label{eq:constr-ex-1-ilp}
   f(x_1,\ldots, x_n )\leq b
\end{equation}
 ili   ograničenje vrijedi u generalnom slučaju.
 
 Uvedimo binarnu varijablu $y$ na sljedeći način:
 
$$y =\begin{cases}
1, \mbox{ ako je poznato da je ograničenje zadovoljeno}, \\
0, \mbox{ inače}
\end{cases}$$
te napišimo 
\begin{equation}\label{eq:constr-ex-1-ilp-big-B}
   f(x) - M y \leq b,
\end{equation}

gdje je $M$ (dovoljno velika) konstanta tako da je 
ograničenje zadovoljeno za sve $x$ ako je $y =1$. Kad god je $y=0$ i ako je uslov (\ref{eq:constr-ex-1-ilp}) zadovoljen, onda je i ograničenje (\ref{eq:constr-ex-1-ilp-big-B}) zadovoljeno. U praksi   određivanje konstante $M$ često slijedi iz samog problema. Inače, veoma je bitno da uzmemo što manju vrijednost za $M$ da bismo izbjegli potencijalne numeričke probleme prilikom računanja. 

\emph{Alternativna ograničenja}. Pogledajmo sljedeću situaciju sa alternativnim ograničenjima:
\begin{align}
     &f_1(x) \leq b_1 \vee \nonumber\\
     &f_2(x) \leq b_2.\label{ineq:f_leq_b2}
\end{align}
gdje je u modelu traženo da se zadovolji barem jedno od ograničenja. 
Ovo ograničenje se može dobiti kombinovanjem logičkih ograničenja te ograničenja sa višestrukim izborom. Dakle, imamo 
\begin{align*}
      &f_1(x) - M_1 y_1  \leq b_1 \\
      &f_2(x) - M_2 y_2  \leq b_2 \\
      & y_1 + y_2 \leq 1 \\
      & y_1, y_2 \in \{0, 1\}.
\end{align*}
Konstante $M_1$ i $M_2$ se odabiru da oba ograničenja u (\ref{ineq:f_leq_b2})  budu (trivijano) zadovoljena, te time postanu invarijante kad je $y=1$.

Ograničenje $y_1 + y_2 \leq 1$ implicira da barem jedna od $y$--varijabli mora da bude 0, tj. barem jedno ograničenje mora da bude zadovoljeno. 

Pojednostavimo ovu formulaciju koristeći ograničenje $y_1 + y_2 = 1$ mjesto ograničenja sa nejednakosti (jer ovo povlači da ili $y_1$ ili $y_2$ je jednako 0), tj. uvrštanjem $y_2 =  1-y_1$, odakle dobijamo 
\begin{align*}
      & f_1(x) - M_1 y_1       \leq b_1 \\
      & f_2(x) - M_2 (1-y_1)   \leq b_2  \\
      & y_1 \in \{0,1 \}.
\end{align*}

\emph{Uslovna ograničenja}. 
Pretpostavimo da želimo modelovati sljedeći scenario sa ograničenjima 
\begin{align*}
    f(x) > b_1 \Rightarrow f(x) \leq b_2 
\end{align*}
Kako je implikacija $p \Rightarrow q$ ekvivalentna sa $\neg p \wedge q$, pa prema tome imamo da je ovaj scenario  ekvivalentan sa
\begin{align*}
    f(x) \leq b_1 \vee f(x) \leq b_2 
\end{align*}
odakle slijedi da koristeći alternativna ograničenja možemo da modelujemo ovakav tip ograničenja.

\emph{K-alternative}. Pokušajmo da modelujemo scenario da od $m$ ograničenja
$$f_j(x) \leq  b_j, j=1,\ldots,m,$$
barem $k$ od njih treba da budu zadovoljena. Modelovanje ovakvog scenarija vršimo na način da prvo odredimo konstante koje će ignorisati ograničenja, nazovimo ih $M_1, \ldots, M_m$, redom. Generalni problem u tom slučaju može biti definisan na sljedeći način:
\begin{align}
     &f_j(x) + (1-y_j) M_j \leq b_j, j=1,\ldots,m\\
     & \sum_{i=1}^m y_i \geq k \\
     & y_j \in \{0,1\}, j=1,\ldots,m.
\end{align}
Primijetimo da ako je $y_j = 1$, tada je $j$-to ograničenje zadovoljeno (za dato $x$). Dakle, barem $k$ ograničenja treba da budu zadovoljena da bi $x$ bilo dopustivo rješenje. 

\emph{Složene alternative}. Pretpostavimo da se dopustiv region problema LP sastoji od tri disjunktna regiona kao na Slici~\ref{fig:compound_regions}. Ovakav scenario se može modelovati uz pomoć konstante veliko $M$, te  ograničenjem sa višestrukim izborom, odakle dobijamo:
\begin{align*}
    &f_1(x) - M_1 y_1 \leq b_1 \\
    &f_2(x) - M_2 y_1 \leq b_2\ (\mbox{ region 1}) \\ \hline
    & f_3(x) - M_3 y_2 \leq b_3 \\ 
    & f_4(x) - M_4 y_2 \leq b_4\ (\mbox{ region 2})\\  \hline 
    & f_5(x) - M_5 y_3 \leq b_5 \\
    & f_6(x) - M_6 y_3 \leq b_6 \\
    & f_7(x) - M_7 y_3 \leq b_7\ (\mbox{ region 3}) \\ \hline
    & y_1 + y_2 + y_3 \leq 2 \\
    & x_1, x_2 \geq 0 \\
    & y_1, y_2, y_3 \geq 0.
\end{align*}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=200pt, height=200pt]{compound.eps}
    \caption{Dopustiv region sa više disjunktnih regiona.}
    \label{fig:compound_regions}
\end{figure}
Uslov $y_1 + y_2 + y_3 \leq 2$ nam upravo ograničava da rješenje $(x_1, x_2)$ pripada tačno jednom od (disjunktnih) dopustivih regiona. 

\emph{Reporezentovanje nelinearnih funkcija}. ($i$) \underline{Fiksne cijene}. Ciljna funkcija problema minimizacije može da sadrži i neke fiksne troškove (fiksni troškovi ulaganja, fiksni troškovi postavljanja opreme itd.). Na primjer, trošak proizvodnje $x$ jedinica određenog proizvoda može da se sastoji od fiksnih troškova postavljanja opreme i promjenjivih troškova koji se tiču proizvedene robe na opremi (mašinama). Pretpostavimo da oprema ima kapacitet proizvodnje od $B$ jedinica. Neka je $y$ binarna varijabla koja pokazuje kada nastaje fiksni trošak, pri čemu  je $y=1$ ako je $x >0$, dok je $y=0$ ako je $x=0$. Tada doprinos cijeni proizvodnje od $x$ jedinica proizvoda se može predstaviti sa
$$ yB + c x $$ pod uslovima:
\begin{align}
     &x \leq By \\
     & x \geq 0 \\
     & y \in \{0, 1\}.
\end{align}
Primijetimo da je ovaj model pripada modelima \emph{Mješovitog-cjelobrojnog programiranja} (gdje postoje obje vrste varijabli, neprekidne i cjelobrojne). O ovoj paradigmi će biti više riječi u narednim sekcijama. \\
($ii$) \underline{{Po dijelovima linearna funkcija}}. Druga vrsta nelinearne funkcije koja se može predstaviti cjelobrojnim varijablama je po-dijelovima-linearna funkcija. Radi jednostavnosti, posmatramo takve funkcije u ravni. To znači da funkcija sama po sebi nije linearna, ali kada joj se domen rastavi na komade (intervale), ona postaje linearna na svakom od tih komada. Recimo da se ova funkcija sastoji od tri po dijelovima (nezavisne) linearne funkcije, tj. 
$$f(x) = \begin{cases}
          c_1 x, \mbox{ za } x \in I_1 = [\delta^1_1, \delta^1_2] \\
          c_2 x, \mbox{ za } x \in I_2 = [\delta^1_2 = \delta^2_1, \delta^2_2] \\
          c_3 x, \mbox{ za } x \in I_3 = [\delta^2_2 = \delta^3_1, \delta^3_2].
      \end{cases}
$$
gdje su $I_1, I_2$ i $I_3$ disjunktni intervali na $\mathbb{R}$.

Da bi se modelovala ovakva funkciju cilja u modelu, varijablu $x$ izrazimo preko tri nove varijable 
$$x = \beta_1 + \beta_2 + \beta_3$$
pod uslovima 
\begin{align}
     &0   \leq \beta_1 \leq \delta^1_2 - \delta^1_1 = b_1 \nonumber \\
     &0  \leq \beta_2 \leq \delta^2_2 - \delta^2_1 = b_2 \nonumber \\
     &0  \leq \beta_3 \leq \delta^3_2- \delta^3_1 = b_3, \label{eq: piecewise-constraints}
\end{align}
dakle slijedi da je funkcija cilja   jednaka 
$$ C = c_1 \beta_1 + c_2 \beta_2 + c_3 \beta_3.$$ 
Primijetimo da imamo problema na graničnim uslovima intervala, dakle u tačkama $I_1 \cap I_2 =\{\delta^1_2\}$ i $I_2 \cap I_3 =\{\delta^2_2\}$. Trebalo bi da vrijedi da $\beta_1 =  \delta^1_2 - \delta^1_1$ kad god je $\beta_2  > 0$ kao i $\beta_2 =  \delta^2_2 - \delta^2_1$ kad god je $\beta_3  > 0$.  S obzirom da su ovo uslovna ograničenja, ona se modeluju uvođenjem dodatnih binarnih varijabli 
$$ \omega_1 = \begin{cases}
                   1, \mbox{ ako } \beta_1 \mbox{ dostiže svoju gornju granicu} \\
                   0, \mbox{ inače},
              \end{cases}$$
te 
$$ \omega_2 = \begin{cases}
                   1, \mbox{ ako } \beta_2 \mbox{ dostiže svoju gornju granicu} \\
                   0, \mbox{ inače}, 
              \end{cases}$$
pa se ograničenja u (\ref{eq: piecewise-constraints}) mogu napisati u obliku

\begin{align}
     & b_1 \omega_1 \leq \beta_1 \leq b_1   \nonumber \\
     & b_2 \omega_2 \leq \beta_2 \leq \omega_1 b_2 \nonumber \\
     & 0 \leq \beta_3  \omega_2 \leq b_3\nonumber \\
     & \omega_1, \omega_2 \geq 0. \label{eq: piecewise-constraints-equivalent}
\end{align}
      Primijetimo da ako $\omega_1 = 0$, onda je $\omega_2= 0$ kako bi se održala dopustivost za ograničenja nametnuta  od strane $\beta_2$, pri čemu se uslovi u (\ref{eq: piecewise-constraints-equivalent}) prevode u
      $$ 0 \leq \beta_1 \leq b_1, \beta_2 =0, \beta_3 =0.$$
      Ako je $\omega_1 = 1, \omega_2 = 0$, onda se uslovi u (\ref{eq: piecewise-constraints-equivalent}) prevode u
            $$   \beta_1 = b_1, 0 \leq \beta_2 \leq b_2, \beta_3 =0.$$
    Ako je $\omega_1 = \omega_2 = 1$, onda se  uslovi u (\ref{eq: piecewise-constraints-equivalent}) prevode u
    $$ \beta_1 = b_1, \beta_2 = b_2, 0 \leq \beta_3 \leq b_3.$$
    Prema tome, postoje tri dopustive kombinacije parametara $\omega_1$ i $\omega_2$:
    \begin{itemize}
             \item  $\omega_1 = 0, \omega_2= 0:$ koje odgovara $x \in I_1$ jer $\beta_2=\beta_3=0$;  
             \item $\omega_1 = 1, \omega_2 = 0$: koje odgovara $x\in I_2$, jer je $\beta_1=b_1, \beta_3=0$;
              \item $\omega_1 = 1, \omega_2 = 1$: koje odgovara $x\in I_3$, jer je $\beta_1=b_1, \beta_2=b_2$.
    \end{itemize}
 %https://download.aimms.com/aimms/download/manuals/AIMMS3OM_LinearProgrammingTricks.pdf
 %https://download.aimms.com/aimms/download/manuals/AIMMS3OM_IntegerProgrammingTricks.pdf
 \emph{Eliminacija proizvoda varijabli}. Generalno, proizvod dvije varijable se može zamijeniti sa jednom varijablom sa dodatnim ograničenjima. Metod prezentovan ovdje se na isti način može proširiti na roizvod više od dvije varijable. Razlikujemo nekoliko slučajeva:
 \begin{itemize}
 	\item $x_1$ i $x_2$ su binarne varijable. Uvedemo smjenu $y=x_1 x_2$. Sljedeći uslovi primoravaju da $y$ primi vrijednost proizvoda:
 	  \begin{align*}
 		      &y \leq x_1 \\
 		      &y \leq x_2 \\
 		      & y \geq x_1 + x_2 - 1 \\
 		      & y \in \{0, 1\}.
 	  \end{align*}
   \item $x_1$ je binarna, $x_2$ je realna (pozitivna) varijabla, $0 \leq x_2 \leq u$. opet uvodimo istu smjenu $y= x_1 x_2$ koja je neprekidna, te dodamo sljedeća ograničenja da primoramo $y$ da primi vrijednost proizvoda:
    \begin{align*}
    	 &y \leq u x_1 \\
    	 &y \leq x_2 \\
    	 & y \geq x_2 + u(1-x_1) \\
    	 & y \geq 0.
    \end{align*}
  \item $x_1, x_2$ u obje neprekidne varijable, $0 \leq x_1 \leq u_1$, $0 \leq x_2 \leq u_2$. Uvedemo varijable $y_1 = \frac{1}{2}( x_1 + x_2) $ i  $y_2 =\frac{1}{2}(x_1 - x_2)$. Tada se izraz $x_1x_2$ može predstaviti u separabilnoj formi $y_1^2 - y_2^2$ koja se zatim može aproksimirati po-dijelovima-linearnim funkcijama. Granice za vrijednosti novih varijabli su 
  $$ \frac{1}{2}(l_1 + l_2) \leq y_1 \leq \frac{1}{2}(u_1 + u_2)$$ i 
  $$ \frac{1}{2}(l_1 - u_2) \leq y_1 \leq \frac{1}{2}(u_1 - l_2) $$
  
 \end{itemize} 

\emph{Aproksimacija nelinearnih funkcija}. Kako smo pomenuli u prethodnoj stavci, ako je funkcija cilja neprekidna i nelinearna, ona se može aproksimirati uz pomoću niza po-dijelovima-linearnih funkcija. Na tu aproksimaciju potom primjenimo transformaciju ograničenja  data u stavci o po-dijelovima-linearnim funkcijama. 

Da bi primijenili veći broj gore navedenih transformacija ograničenja u praksi, posmatrajmo sljedeći primjer kojeg modelujemo. 


\emph{Primjer}. Pretpostavimo da je stanovništvo koncentrirano u $I$ okruga  unutar grada i da u okrugu $i\in [I]$ stanuje $p_i$ ljudi. Preliminarna analiza (premjeri zemljišta, politika, socijalna situacija, itd.) ograničila je potencijalne lokacije vatrogasnih domova na $J$ lokacija. Neka $d_{ij} \geq 0$ predstavlja udaljenost   središta okruga (dijela grada) $i$  do lokacije $j$. 

Zadatak: \emph{Potrebno je odabrati lokacija gdje će se podići vatrogasni domovi za svaki od okruga. O funkciji cilja i dodatnim ograničenjima ćemo diskutovati u toku modelovanja samog problema.}

Definišimo binarne varijable 
$$y_j = \begin{cases}
              1, \mbox{ ako je lokacija } j \mbox{ odabrana za izgradnju doma} \\
              0, \mbox{ inače}
        \end{cases}$$
i 
$$
x_{ij}= \begin{cases}
             1, \mbox{ ako je lokacija za vatrogasni dom } j \mbox{ pridružena opskrbljivanju okruga } i \\
             0, \mbox{ inače}. 
        \end{cases}
$$
Svaki okrug treba da bude pridružen tačno jednom vatrogasnom domu, pa je to ograničenje modelovano sa
\begin{equation}\label{eq:ex-constr-1}
      \sum_{j \in J} x_{ij} = 1, \forall i \in I
\end{equation}
Takođe, ne postoji okrug koji je pridružen nekorištenoj lokaciji (za vatrogasni dom) $j$, tj. ako je $y_j = 0$, onda $ \sum_{i \in I} x_{ij} = 0$. Ovo je uslovno ograničenje, koje se modeluje sa
\begin{equation}\label{eq:ex-constr-2}
    \sum_{i \in I} x_{ij} \leq y_j |I|.
 \end{equation}
%gdje je $|I|$ broj mijesta. 

Udaljenost okruga $i$ ka pridruženom vatrogasnom domu je jednaka $d_i = \sum_{j \in J} d_{ij}x_{ij} $. Dalje, veličina populacije (broj ljudi) koja će biti opskrbljivana od strane doma na lokaciji $j$ je jednaka 
\begin{equation}\label{eq:ex-constr-3}
    s_j = \sum_{i \in I} p_i x_{ij}. 
\end{equation}
Pretpostavimo da je središnji okrug posebno osjetljiv na požar i da lokacije za dom  1 i 2 ili lokacije 3 i 4 mogu biti iskorištena da zaštite okrug. Ovakva situacija se modeluje sa
\begin{equation*} 
    y_1 + y_2 \geq 2 \mbox{ ili } y_3 + y_4 \geq 2
\end{equation*}
što je ekvivalentno ograničenjima 
\begin{align}
    &y_1 + y_2 \geq 2 y \nonumber \\
    &y_1 + y_2 \geq 2 (1-y) \nonumber \\
    & y \in \{0, 1 \}.\label{eq:ex-constr-4}
\end{align}
Pretpostavimo da cijena izgradnje vatrogasnog doma na mjestu $j$ koje može voditi brigu o $s_j$ ljudi košta $f_j(s_j)$. Pretpostavimo takođe da je budžet kojim raspolažemo jednak $B$. Prema tome, vrijedi ograničenje
\begin{equation}\label{eq:ex-constr-5}
     \sum_{j \in J} f_j(s_j) \leq B.
\end{equation}
 Funkcija cilja koja bi se mogla optimizovati u ovoj varaijnti problema je minimizacija udaljenosti 
 okruga koja se nalazi najdalje od svog pridruženog vatrogasnog doma ($d_i$):
      $$\min D $$
 gdje je $D= \max d_i$. Ekvivalentno se ova funkcija cilja može napisati kao:
 \begin{align*}
      &\min D \\
      & D \geq d_i,  \forall i \in I \\
      &  {s.t. } \\ 
      &(\ref{eq:ex-constr-1})-(\ref{eq:ex-constr-5}).
 \end{align*}
 Još je ostalo zamijeniti svaku funkciju $f_j (s_j)$ aproksimacijom cjelobrojnog programiranja kako bismo izvršili cjelokupno modeliranje. Detalje ostavljamo citaocu kao zadatak. Ako bi funkcija $f_j (s_j)$ sadržala fiksne troškove, tada se ne bi trebale uvoditi nove varijable fiksnih troškova -- u tu svrhu služi već uvedena varijabla $y_j$. 
 % jos neki trikovi u modelovanju: https://download.aimms.com/aimms/download/manuals/AIMMS3OM_LinearProgrammingTricks.pdf
 
 \section{Kompleksnost Cjelobrojnog Programiranja}
   Što se tiče rješivosti problema cjelobrojnog programiranja, ona spada u NP--teške probleme, za razliku od LP-a koji je, kako smo pokazali, polinomijalno rješiv. U nastavku ove sekcije dajemo dokaz da je rješivost ILP-a zaista NP--težak problem.  Ideja je da  svedemo problem 3--SAT na ILP.\\ 
     %https://mediaspace.msu.edu/media/Proving+that+Integer+Programming+is+NP-Complete/1_0j1vkmvw
   Iako je 3--SAT problem trebao biti poznat onome ko je slušao kurs iz osnova teorije algoritama, radi lakše čitljivosti ćemo ga ovdje definisati. 
   
   Neka su dati literali $x_1, \ldots, x_n$. Svaki literal može da bude pozitivan ($x_1$) ili negativan  ($\neg x_1$). Kažemo da je formula napisana u \emph{konjunktivnoj normalnoj formi} (CNF) akko je napisana kao konjunkcija klauzula (ili literala). Pod klauzulom podrazumijevamo formulu koja je sastavljena od literala povezanih disjunkcijama. Npr. formula $\phi(x_1, x_2, x_3)= (x_1 \vee  \neg x_2) \wedge (x_1 \vee x_3)$ je napisana u CNF; u njoj postoje dvije klauzule. CNF formula $\phi(x)$ je zadovoljiva akko postoji dodjela $\overline{x}$ literalima ($\overline{x}_i \in \{TRUE, FALSE\}$) tako da je $\phi(\overline{x})$ tačna (prema zakonima bulove algebre).  
   
   Kažemo da je konjunktivna formula $\phi(x)$  napisana u 3--CNF  akko se u svakoj klauzuli nalazi najviše 3 različita literala. Napomenimo da se bilo koja formula može redukovati u 3--CNF, u smislu rješivosti. Dakle, svaka klauzula 
   $l_1 \vee l_2 \vee \cdots \vee l_n$ se prevodi u 3--CNF na sljedeći način:
   \begin{align*}
       &(l_1 \vee l_2 \vee x_2) \wedge ( \neg x_2 \vee l_3 \vee x_3) \wedge ( \neg x_3 \vee l_4 \vee x_4 ) \wedge \cdots \wedge (\neg x_{n-3} \vee l_{n-3} \\
       &\vee x_{n-2} ) \wedge ( \neg x_{n-2} \vee l_{n-1} \vee l_n ).  
    \end{align*}    
      Imajte na umu da ove formule nisu logički ekvivalentne ali su ekvivalentne u smislu zadovoljenja. 
    Pokazano je da je problem 3--SAT, gdje je ulaz 3--CNF formula,  u opštem slučaju NP-kompletan problem.  
    
   \begin{thm}
   	  Rješivost ILP-a je NP-težak problem.
   \end{thm}
   \begin{proof}
   	   Izvedimo redukciju sa 3-SAT problema. Neka je dat 3--SAT izraz sa literalima  
   	   $x_1,\ldots, x_n$.  Konstruišimo ILP instancu sa varijablama $z_1, \ldots, z_n$ gdje imamo:
   	   \begin{itemize}
   	   	   \item Svaka klauzula $\phi_i(x)$ je konvertovana u nejednakost gdje
   	   	      $z_i = x_i$, ako je $x_i$ pozitivan literal u klauzuli $\phi$, odnosno $z_i = 1 - x_i$ ako je $x_i$ negativan literal u klauzuli $\phi$ (negacija ispred). Primjera radi, ako je data instanca problema 3-SAT sa 
   	   	      $\phi(x) = (x_1 \vee \neg x_2 \vee \neg x_3) \wedge ( x_2 \vee \neg x_4 \vee x_5 )$, transformišemo je (u polinomijalnom vremenu) na instancu ILP-a
   	   	      \begin{align*}
   	   	         	 &z_1 + (1- z_2) + (1 - z_3 ) \geq 1 \\
   	   	         	 &z_2 + (1-z_4)  + z_5 \geq 1 \\
   	   	         	 & z_i \in \{0,1\}, i=1,\ldots,5.
   	   	      \end{align*} 
   	   \end{itemize}
   	   Dakle, iz gornje redukcije, nalazak rješenja ILP instance odgovara nalasku dodjele $\overline{x}$ literalima tako da je formula $\phi$ zadovoljena. Dakle, treba da se provjeri da li je ILP instanca dopustiva. Takođe, lako je vidjeti da je ova redukcija polinomna. Prema tome, ILP je NP-težak, s obzirom da je 3--SAT problem NP-kompletan. 
   \end{proof} \\
 Može se pokazati i sljedeća teorema.
 \begin{thm} Neka je $k\in \mathbb{Z}$.
 	 Problem odlučivanja da li postoji cjelobrojno rješenje u ILP-u (pod uslovom da minimizujemo) koje je manje od $k$ je NP--kompletno. 
 \end{thm}
 
\textbf{\large Zadaci}
\begin{enumerate}
	
	\item Preduzeće za prikupljanje reciklažnog otpada raspolaže sa dvije deponije, koje su označene sa A i B. Dnevni troškovi održavanja deponije A su 300KM dnevno, a deponije B 45KM dnevno.  U deponiji A se dnevno prikupi 250 flaša i 100 limenki, dok se u deponiji B prikupi 160 flaša i 350 limenki. Da bi se isplatio rad deponija mjesečno treba prikupiti barem 5200 flaša i 4000 limenki.
	Koliko bi dana mjesečno trebale raditi obje deponije da budu isplative i da troškovi budu minimalni?
	
	\item Fabrika proizvodi artikle A i B te ih prodaje po cijeni 30 KM, odnosno 50 KM, po komadu. Za
	proizvodnju fabrika koristi samo jednu mašinu, pri čemu je za proizvodnju artikla A potrebno 19
	minuta, a proizvoda B 26 minuta. Tokom dana aparat može da radi najviše 8 sati. Odredi koliko treba
	proizvesti proizvoda A, a koliko B, da bi zarada bila najveća.
	
	\item Marko se sprema na planinarenje. Na raspolaganju ima samo jedan ruksak i pet namirnica, po jedan
	komad svake od njih. Ruksak je kapaciteta 2.5 L i ne smije biti teži od 2 kg. U tabeli su
	prikazani podaci o namirnicama
	\begin{table}
		\begin{tabular}{|c|c|c|c|}
			\hline
			Namirnica & Masa (g) & Zapremina (L) & Kalorijska vrijednost (kcal) \\
			\hline
			Čokolada & 300 & 0,5 & 1500 \\
			\hline
			Kokos & 500 & 1,4 & 1300 \\
			\hline
			Mlijeko& 1000 & 1 & 660 \\
			\hline
			Pasulj u konzervi& 400 & 0,8 & 650 \\
			\hline
			Keks& 500 & 0,9 & 1800 \\
			\hline
		\end{tabular}
	\end{table}
	Kako treba napuniti tako da ukupna kalorijska vrijednost ponesenih namirnica bude maksimalna?
	
	\item Riješiti prethodni zadatak ako Marko na raspolaganju ima dovoljno veliki broj svih pojedinačnih namirnica.
	
	
	\item Preduzeće  razmatra izvođenje 5 trogodišnjih projekata, ali u svakoj godini može u to uložiti najviše
	25 000 KM. Procjena troškova za svaki projekat u tri godine dana je tabelom (u hiljadama maraka), kao i
	očekivana dobit od projekta (čista dobit – troškovi su oduzeti):
	
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		Projekat & 1. godina & 2. godina & 3. godina & Dobit \\
		\hline
		1 & 5 & 1 & 8 & 20 \\
		\hline
		2 & 4 & 7 & 10 & 40 \\
		\hline
		3 & 3 & 9 & 2 & 20 \\
		\hline
		4 & 7 & 4 & 1 & 15 \\
		\hline
		5 & 8 & 6 & 10 & 30 \\
		\hline
	\end{tabular}  \\
	Odrediti koje od projekata treba realizovati da se maksimizuje ukupna dobit.
	
	\item Zadat je skup $S$ koji se sastoji od $n$ brojeva. Koristeći tehnike cjelobrojnog linearnog programiranja, podijeliti skup $S$ na dva podskupa, tako da se zbirovi elemenata u prvom i drugom podskupu što manje razlikuju.
	
	\item Riješiti prethodni zadatak uz dodatni uslov da nijedan podskup ne smije da sadrži više od $\frac {2n}3$ elemenata.
	

	
	%https://www.utc.fr/~dnace/dokuwiki/_media/fr/upt-cours-2012lp.pdf
	\item Problem totalnog pokrivanja. %Neka je dato $n$ mijesta, te $m$ zahtjeva koji treba da budu ispunjeni ($d_1,\ldots, d_m$).  
	Sa $D_c$ označimo maksimalnu daljinu koja se može pokriti instalacijom (skladišta, antene). Pod ``pokrivanjem'' podrazumijevamo ispunjavanje zahtjeva klijenata (koji žive u nekom mjestu). Sa $c_i$ označimo cijenu instalacije (antene, skladišta isl.) na mjesto $i$. Sa $d_{ij}$ označimo udaljenost između mjesta $i$ i $j$. Zadatak ovog problema je koja mjesta odabrati (za instaliranje antene, skladišta isl.) tako da su sva mjesta pokrivena, ali da pri tome minimizujemo troškove instalacija. Sa jednog odabranog mjesta se pokrivaju sva susjedna koja su u njegovom radijusu od $D_c$. 
	\item Problem maksimalnog pokrivanja (eng. \emph{maximum coverage problem}). Neka je u ulazu data kolekcija skupova  $S=\{ S_1, \ldots, S_m\}$ te broj $k \in \mathbb{N}$. Potrebno je naći podskup $S' \subseteq S$, tako da je $|S'|\leq k$, a broj pokrivenih elemenata $|\bigcup_{s' \in S'} s'|$ je maksimizovan. \\
	Uputstvo. sa $x_j \in \{0, 1\}$ označimo varijablu koja dobija vrijednost 1 ako je $S_i$ selektovan u rješenje $S'$, inače 0. Dodatno, sa $y_j \in \{0, 1 \}$ definišemo varijablu koja dobija vrijednost 1 ako je   element $e_j$ pokriven rješenjem.  
%http://courses.ieor.berkeley.edu/ieor151/lecture_notes/ieor151_lec14.pdf
	\item $P$-center problem čvorova (eng. \emph{vertex p-center problem}). Formulacija problema je  predstavljena neusmjerenim grafom $G = (I, J, E)$, gdje su čvorovi potražnje predstavljeni skupom vrhova $i\in I$, a moguće lokacije objekata date su drugim skupom vrhova $j \in J$ , a grane $e_{i,j} \in E$ postoje samo između čvorova $i \in  I$ i čvorova $j \in J$. Nadalje, čvorovima $d_{i,j}\geq 0$ dodjeljujemo pozitivne težine, što predstavlja udaljenost između čvorova $i$ i $j$. Imajte na umu da je moguće imati i udaljenost 0 između čvora potražnje i moguće lokacije objekta. Za svaki čvor $i \in I$ pridružena je težina (zahtjeva) $h_i>0$, koja predstavlja količinu zahtjeva tog čvora. 
	
	U ovom problemu želimo postaviti $p$ objekata kako bismo smanjili maksimalnu udaljenost između bilo kojeg čvora potražnje i	njegovog servisnog objekta. 
	\item %https://personal.utdallas.edu/~metin/Or6302/Notes/integer.pdf
	 Pretpostavimo da se selimo u novi stan i da imamo samo dva kofera u koje možemo spakovati svoje stvari. Prvi kofer može da spakuje 22 kg, a drugi 28 kg. Težina i vrijednosti stvari
	su dati sa \\
 \begin{table}[!ht]
 	\centering
	\begin{tabular}{l|cccccccc}
		Stavka & A & B & C & D & E & F & G & H \\ \hline
		Težina & 10 & 9 & 15 & 3 & 11 & 6 & 3 & 4 \\
		Vrijednost & 5 & 2 & 7 & 6 & 1 & 6 & 8 & 6 \\ \hline
	\end{tabular} 
    
 \end{table}
Konstruišite model koji maksimizuje vrijednost  predmeta koji će biti ubačeni u ova dva kofera. 
\item Višedimenzionalni više-direkcioni problem particionisanja brojeva (eng. \emph{multidimensional multi-way number partitioning problem}). Neka je dat skup vektora $S$. Inače, vektori mogu da budu iz proizvoljneg prostora $\mathbb{R}^m, m \in \mathbb{N}$.   Zadatak je podijeliti skup $S$ na $p \geq 1$ particija tako da su sume vrijednosti  elemenata  po koordinatama za sve particije podjednake. 

\item Problem maksimalnog nezavisnog skupa (eng. \emph{independent set problem}). U ulazu je dat graf $G = (V, E)$. Potrebno je naći podskup $V' \subseteq V$ maksimalne kardinalnosti u grafu $G$ tako da niti jedan od čvorova iz $V'$ nisu susjedni. 
\item Problem maksimalne klike (eng. \emph{maximum clique problem}).   U ulazu je dat graf $G = (V, E)$. Potrebno je naći podskup $V' \subseteq V$ maksimalne kardinalnosti tako da je indukovani podgraf 
$G[V']$ grafa $G$ kompletan graf (postoji grana između bilo koja dva čvora iz $V'$). 
\item % http://people.brunel.ac.uk/~mastjjb/jeb/or/moreip.html
Proizvođač igračaka planira proizvodnju novih igračaka. Troškovi pripreme proizvodnih pogona i jedinični profit za svaku igračku dati su u nastavku: 
 \begin{table}[H]
	\centering
	\begin{tabular}{l|cc}
	  Igračka &  Troškovi pripreme    & Profit \\ \hline
	  1       &  45000     &  12     \\
	  2       &  76000     &  16     \\	\hline
	\end{tabular} 
\end{table}
 Kompanija ima dvije tvornice koje mogu proizvoditi ove igračke. Kako bi se izbjeglo udvostručenje troškova pripreme za proizvodnju,  samo jedna tvornica se može koristiti u datom momentu. 
 
 
 Stope proizvodnje svake igračke date su u nastavku (u jedinicama/satu): 
  \begin{table}[H]
 	\centering
 	\begin{tabular}{l|cc}
 		         &  Igračka 1 & Igračka 2 \\ \hline
 	Tvornica 1   &  52     &  38     \\
    Tvornica 2   &  42     &  23     \\	\hline
 	\end{tabular} 
 \end{table}
 Fabrika 1 i 2, imaju 480 i 720 sati radnog vremena za proizvodnju ovih igračaka, redom. Proizvođač želi znati koju će od novih igračaka proizvesti, gdje i koliko svake (ako uopšte) treba proizvesti kako bi se povećala ukupna zarada. 
 \item %http://people.brunel.ac.uk/~mastjjb/jeb/or/moreip.html
 Hrana se proizvodi rafiniranjem sirovih ulja i njihovim miješanjem. Sirova ulja dolaze u dvije kategorije: 
 \begin{itemize}
 	\item vegansko ulje:
 	\begin{enumerate}
 		\item VEG1
 		\item VEG2 
 	\end{enumerate}
   \item obično ulje:
   \begin{enumerate}
   	\item Ulje1
   	\item Ulje2 
   	\item Ulje3
   \end{enumerate}
 \end{itemize}
Cijene za kupovinu svakog ulja date su u nastavku (u \$/toni)
\begin{table}[H]
 	\centering
 	\begin{tabular}{ccccc}
            VEG1 & VEG2 & Ulje1 & Ulje2 & Ulje3 \\ \hline
            115  & 128  & 132   & 109   & 114 \\ 		
    \end{tabular} 
\end{table}
Finalni proizvod prodaje se po 180 funti po toni. Biljna ulja i ne-biljna ulja zahtijevaju različite proizvodne linije za rafinisanje. Nije moguće rafinisati više od 210 t biljnih ulja i više od 260 t ne-biljnih ulja. Pretpostavimo da u procesu rafinisanja nema gubitka težine, a troškovi prerade mogu se zanemariti. 

Postoji tehničko ograničenje koje se odnosi na tvrdoću konačnog proizvoda. U jedinicama u kojima se mjeri tvrdoća, dopušteno je da ona bude izmešđu 3.5 i 6.2. Pretpostavlja se da se tvrdoća odnosi linearno sa miješanjem vrsti ulja. Tvrdoća sirovog ulja je data sljedećom tabelom: 
\begin{table}[H]
	\centering
	\begin{tabular}{ccccc}
		    VEG1 & VEG2 & Ulje1 & Ulje2 & Ulje3 \\ \hline
		    8.8  & 6.2  & 1.9   & 4.3   & 5.1   \\
    \end{tabular} 
\end{table}

Potrebno je odrediti šta kupiti i kako miješati sirova ulja tako da kompanija maksimizira svoj profit. 

U osnovni model uključiti i sljedeća ograničenja:
\begin{itemize}
	\item Hrana nikad ne smije biti napravljena od više od 3 vrste ulja. 
	\item Ako je ulje korišteno, onda se mora iskoristiti barem 30 t ulja.
	\item Ako su ili VEG1 ili VEG2 ulja korištena, onda i Ulje2 mora biti korišteno.  
\end{itemize}

\end{enumerate}                                                       


 \chapter{Tehnike u rješavanju Cjelobrojnog programiranja}
 
 Dok je simpleks metoda učinkovita za rješavanje  problema LP-a, ne postoji jedinstvena tehnika za rješavanje problema Cjelobrojnog programiranja. Umjesto toga, razvijeni su mnogi metodi i njihova efikasnost
 uvelike zavisi od karakteristika samog problema. Dosadašnje metode se generalno mogu klasifikovati na sljedeći način:
 \begin{enumerate}
     \item Enumerativne tehnike -- Dinamičko programiranje, metoda otkidanja i ograničavanja (eng. \emph{branch-and-bound}), koju ćemo kratko nazvati B\&B;
     \item Tehnike otkidajućih ravni.
     %\item Grupne-teoretske tehnike. 
 \end{enumerate}

Mi ćemo izložiti   obje vrste metoda. Za model ILP-a (\ref{ilp-formulation}), zanemarujući uslov da varijable treba da budu cjelobrojne (već da uzimaju realne, pozitivne vrijednosti), dobijamo tzv. odgovarajuću LP \emph{relaksaciju} ILP-a (\ref{ilp-formulation}). LP relaksacija se može vrlo lako riješiti uz pomoć simpleks metoda pri čemu dobijemo rješenje $x^*$. Posmatrajući vektor $\overline{x}$ koje se dobije zaokružujući svaku od vrijednosti koordinata vektora $x^*$ na njenu najbližu cjelobrojnu, dobijamo cjelobrojni vektor. Međutim, iako je uslov o cjelobrojnosti (kakav je u odgovarajućem ILP-u potreban) ispunjen, može se desiti da ovakvo rješenje izvedeno iz LP relaksacije problema (\ref{ilp-formulation}) ne mora da bude dopustivo. U osnovi, skaliranjem desnih strana ILP-a kao i koeficijenata funkcije cilja na odgovarajući način, moguće je konstruisati probem čije je optimalno cjelobrojno rješenje proizvoljno udaljeno od zaokruženog rješenja LP relaksacije. Ove postupke ćemo se izložiti u nastavku. 

\section{Metoda grananja i ograničavanja (B\&B)}
B\&B tehnika programiranja je zasnovana na principu ``zavadi pa vladaj'' gdje se problem rastavlja na manje dijelove, i tako rekurzivno po potrebi. Kasnije se (optimalna rješenja) manjih problema kombinuju za dobijanje optimalnog rješenja početnog problema.  U B\&B strategiji dodatak je da se 
problem ne rastavlja na manje potprobleme ako se uspostavi da je rješenje podoptimalno (lošije od trenutno najboljeg dopustivog rješenja). U rješavanju ILP-a, dopustiv skup se dijeli na manje skupove, i tako rekurzivno (ako je potrebno) dok se ne dobiju potproblemi čije relaksacije obezbjeđuju cjelobrojno rješenje ili se zaključi da nisu dopustivi. Svi ovakvi B\&B pristupi se razlikuju u načinu podjele dopustivog skupa i zbog toga   postoji nekoliko različitih B\&B procedura u literaturi. 

\subsection{Bazni B\&B za rješavanje problema ILP-a}

Navedimo sljedeće bitne činjenice u rješavanju problema  ILP-a:
\begin{itemize}
    \item  U LP relaksaciji u problemu 
           maksimizacije, optimalna vrijednost funkcije cilja 
           uvijek će biti gornja granica (UB) posmatranog ILP-a. 
    \item  Bilo koja cjelobrojna tačka LP relaksacije na nekom podskupu  
           dopustivog skupa uvijek je  donja granica (LB) optimalne vrijednosti početnog ILP-a. 
\end{itemize}
%Definišimo $LB = - \infty$. 
Na bazi ove dvije činjenice, uvedimo sada sistematičnu podjelu dopustivog regiona na niz podregiona:
\begin{enumerate}
    \item U korjenom čvoru rješavamo LP relaksaciju početnog problema     (simpleks metodom), i dobijamo rješenje $x^*=(x^*_1, \ldots, x^*_n)$.   Postavimo $f(x^*)$ = LB.
    \item Za sve koordinate $i$ za koje je $x^*_i \not \in \mathbb{Z}$ znamo da  mora biti ili $z_i \geq \lfloor x^*_i \rfloor + 1$ ili $z_i \leq \lfloor x^*_i \rfloor$ i to je upravo mjesto podjele dopustivog regiona. Ako ima više takvih koordinata, biramo onu koordinatu $i$ gdje je decimalni dio najveći.  Recimo da je to koordinata $k$.
    \item Sada dijelimo region problema na dva podregiona (lijevi i desni) dodavajući 
          ograničenja $x_k \geq \lfloor x^*_k \rfloor + 1$ ili $x_k \leq \lfloor x^*_k \rfloor$, redom.
    \item Rješavamo relaksaciju oba (pot)problema. 
    \begin{itemize}
    	\item  Ako je neko od rješenja cjelobrojno, popravljamo LB (ako smo dobili bolje dopustivo rješenje) i odgovarajući potproblem (njegov region) se dalje ne dijeli. 
    	\item Ako rješenje $x$ nije cjelobrojno, i pri tome je vrijednost optimuma manja od $LB$, taj potproblem se dalje više ne dijeli (\emph{bound} procedura). 
    	\item Dalje, ako je potproblem nedopustiv, problem se ne dijeli (i ne razmatra se više). 
    	\item Inače, idemo na korak 2 dijeljeći podregion ovog potproblema na nove (manje) podregione.    
    \end{itemize}

\end{enumerate}

Primijetimo da ovom metodom formiramo drvo enumeracije koje nam garantuje nalazak optimalnog rješenja početnog ILP-a. Takođe, primijetimo da ovo drvo raste eksponencijalno u odnosu na veličinu ulaznog problema. 

  Ovo je samo okvirna shema B\&B procedure. Ono što je ostalo nerazjašnjeno je koji od neriješenih potproblema prvo rješavati. Kažemo da se čvorovi čiji je odgovarajući problem podijeljen na podregione naziva \emph{neaktivan}, a inače \emph{aktivan}. Generalni B\&B metod za rješavanje problema ILP-a je dat   pseudokodom~(\ref{bnb_algorithm_ilp}).  Neki od kriterijuma su sljedeći:
  \begin{itemize}
  	\item Izabrati one aktivne čvorove koji su najdublje u drvetu da bi što prije stigli do listova i potencijalnih dopustivih rješenja.
  	\item Odabrati aktivne čvorove nivo po nivo. Dakle, sve aktivne čvorove (tj. odgovarajuće potprobleme) jednog nivoa   rješavati, pa onda preći na čvorove idućeg nivoa. 
  	\item Koristiti heurističku funkciju u odlući koji aktivni čvor (tj. odgovarajući potproblem) prvo rješavati. 
  \end{itemize}

Na Slici~\ref{fig:bnb_ilp} je prikazano B\&B drvo sljedećeg ILP-a:
\begin{align*}
    &\max 5 x_1 + 8 x_2 \\
    &x_1 + x_2 \leq 6 \\
    & 5 x_1 + 9 x_2 \leq 45 \\
    & x_1, x_2 \geq 0\\
    & x_1,x_2 \in \mathbb{Z}.
\end{align*}

%\begin{figure}
%    \centering
%    \includegraphics[width=200pt, height=200pt]{bnb_ilp.eps}
%    \caption{B\&B stablo ILP problema.}
%    \label{fig:bnb_ilp}
%\end{figure}

\begin{figure}[!ht]
	\centering
	\begin{tikzpicture}
		\node[parent node,rectangle split parts=1](A){\textA};
		%\node[parent node,below =of A](B){\textB};
		\node[parent node,below left =of A](B){\textC};
		\node[parent node,below right =of A](C){\textD};
		\node[parent node,node distance=1 and 0.3,below left =of B](D){\textE};
		\node[parent node,node distance=1 and 0.3,below right =of B](E){\textF};
		\node[parent node,node distance=1 and 0.3,below left=of E](G){\textG};
		\node[parent node,node distance=1 and 0.3,below right=of E](H){\textH};
		%\draw[->](A.south)--(B)node[midway,right]{\scriptsize solve as continous problem};
		\draw[->](A.south)--+(0,-0.5)-|(B)node[right,near end]{\scriptsize $x_2\geq 4$};
		\draw[->](A.south)--+(0,-0.5)-|(C)node[left,near end]{\scriptsize $x_2\leq 3$};
		\draw[->](B.south)--+(0,-0.5)-|(D)node[left,near end]{\scriptsize $x_1 \geq 2$};
		\draw[->](B.south)--+(0,-0.5)-|(E)node[right,near end]{\scriptsize $x_1 \leq 1$};
		\draw[->](E.south)--+(0,-0.5)-|(G)node[left,midway]{\scriptsize $x_2\leq 4$};
	    \draw[->](E.south)--+(0,-0.5)-|(H)node[left,midway]{\scriptsize $x_2 \geq 5$};
	\end{tikzpicture}
	\caption{Primjer Branch and Bound  Metoda za ILP.}
	\label{fig:bnb_ilp}
\end{figure}


\begin{algorithm}[!ht] 
	\begin{algorithmic}[1] 
		\STATE $LB \gets$ $-\infty$
		\WHILE{postoji neki aktivni čvor}
		\STATE  $v_j \gets$ Odabrati neki od aktivnih čvorova; // strategija
		\STATE  Označiti $v_j$ kao neaktivan;
		\STATE  $x^j \gets$ Riješiti potproblem koji odgovara čvoru $v_j$
		\STATE $z^*_j \gets f(x^j)$;
		\IF{ $z^*_j  \leq LB$} 
		\STATE Čvor $j$ nije relevantan za dalje razmaranje; 
		\ENDIF
		\IF{$z^*_j  > LB$}
		\IF{$x^j$ je dopustivo}
		\STATE $LB \gets z^*_j$;
		\STATE $x^* \gets x^j$;
		\ENDIF
		\ENDIF
		\IF{$z^*_j  > LB$}
		\IF{$x^j$ nije dopustivo}
		\STATE $v_j^{'}, v_j^{''},\ldots, v_j^{(')^k}  \gets$ Generisati potprobleme (čvorove) problema koji odgovara problemu čvora $v_j$ (branch procedura);
		\STATE Označi aktivnim nove čvorove; 
		\ENDIF
		\ENDIF
		\ENDWHILE
	\end{algorithmic}
	\caption{Generalni B\&B za rješavanje ILP-a.}\label{bnb_algorithm_ilp}
\end{algorithm}

\emph{Napomene.} Da bi se granice čak i poboljšale, imajmo na umu sljedeće činjenice:
\begin{itemize}
	\item Ako su koeficijenti ciljne funkcije cjelobrojni, onda $z^* \leq \lfloor z^* \rfloor$;
	\item Dodavanjem važećih ograničenja u sam model (fokus sljedećeg poglavlja). 
\end{itemize}



\section{Implicitna Enumeracija}
Posmatrajmo sada specijalnu B\&B proceduru koja se može primijeniti na problem Binarnog cjelobrojnog programiranja, gdje    sve diskretne varijable u suštini modeluju logičke odlukame. Ovaj algoritam ne zahtjeva da se posmatraju rješenja LP-relaksacija, već radi se sa enumeracijom. Dakle, izlistaju se sve moguće kombinacije vrijednosti koje varijable mogu da prime, pa se izabere ona koja je dopustiva i daje najveću vrijednost za ciljnu funkciju. Ovaj pristup radi dobro na problemima malih dimenzija gdje postoji svega nekoliko binarnih varijabli u modelu. Primijetimo da u problemu sa $n$ binarnih varijabli,  broj kombinacija za varijable odluke je jednak $2^n$ (dakle, raste eksponencijalnom brzinom u odnosu na veličinu ulaza). 

Prisjetimo se da u standardnoj B\&B proceduri, podjela na manje probleme je izvedena dodavanjem dodatnih ograničenja i izbacujući ograničenja za integralnost (cjelobrojnost). U implicitnoj enumeraciji se primjenjuje suprotna taktika, zadržavajući 0-1 restrikcije, ali ignorišući linearne nejednakosti. 
Ideja implicitne enumeracije je uključiti B\&B proces tako što se fiksiraju neke od varijabli na 0 ili 1. Varijable koje ostaju neodređene se nazivaju \emph{slobodne varijable}.  B\&B kreće od slučaja da ne postoje varijable koje nisu slobodne. U svakom koraku fiksiramo jednu od varijabli i rješavamo problem bez razmatranja ograničenja sa nejednakostima. Potom provjeravamo da li je to rješenje dopustovo (zadovoljava ograničenja sa nejednakostima). U narednim podjelama (fiksiranjima) prethodne (ne-slobodne) varijable ostaju fiksirane. 
%, dobijajući dva nova potproblema koja treba da budu riješena te implicitno određivanje da li su neophodna dalja fiksiranja.  
Pretpostavimo da je u pitanju problem makismizacije. Proces implicitne enumeracije se sastoji od sljedećih koraka. 

Fiksiramo $i=1$ i $LB=-\infty$. 

\begin{enumerate}
    \item U početnom problemu  stavimo $x_j=0$ za sve $j$ (kažemo da je svaka varijabla \emph{slobodna}) za koje je $c_j > 0$, a inače 0. Ako je dobijeno rješenje dopustivo, ažuriramo vrijednost za $LB$.
    \item Fiksiramo sada $x_i=0$ za jedan potproblem, te $x_i=1$, za drugi potproblem koji treba da se riješe.
    
    \item  Provjerimo za oba potproblema da li je rješenje (sa fiksnim dijelom) koje maksimizuje rješenje potproblema (kao u koraku 1) dopustivo. U slučaju da jeste,   ovaj protproblem se više ne dijeli; po mogućnosti ažuriramo LB, ako je nađeno novo najbolje rješenje.   %Inače, idemo na korak 4. Primijetimo da  potproblem sa fiksnim $x_i=0$ ne mora da provjeravamo, jer je on isti kao i korjeni (korjeni) problem.
    \item Ažuriramo $i = i+1$ i idemo na korak 3 sa potproblemima koji mogu dalje da se dijele, dok god je $i \leq n$. Inače, izlazimo iz petlje sa optimalnim rješenjem (LB). 
\end{enumerate}
 Primijetimo da i u ovom slučaju dobijamo drvo odluke (binarno drvo) gdje su na granama koje spajaju čvor na dubini $i$ sa čvorom na dubini $i+1$  ugrađene odluke da li je varijabla $x_i$ fiksirana na 0 ili 1.

Na Slici~\ref{fig:bnb_binary} je dato drvo odlučivanja za problem 
\begin{align*}
   &\max -8 x_1 - 2x_2 - 4x_3 - 7x_4 -5x_5 + 10 \\
   & s.t. \\
   & -3 x_1 - 3 x_2 + x_3 + 2 x_4 + 3 x_5 \leq -2 \\
   & -5 x_1 - 3 x_2 - 2 x_3 - x_4 + x_5 \leq -4 \\
   & x_i \in \{0, 1\}, \mbox{ za } i=1,\ldots,5.
\end{align*}

%\begin{figure}
%    \centering
%    \includegraphics[width=200pt,height=200pt]{bnb_binary.eps}
%    \caption{Drvo odluke za rješavanje problema binarnog programiranja.}
%    \label{fig:bnb_binary1}
%\end{figure}

\begin{figure}
	\centering
\begin{tikzpicture}[
	node/.style={%
		draw,
		circle,
	},
	]
	% nacrtaj cvorove:
	\node [node, label={[blue]right:$z^* \leq 10$}] (A) { 0 };
	\path (A) ++(-135:\nodeDist) node [node, label={[blue]right:$z^* \geq 2$}] (B) {1};
	\path (A) ++(-45:\nodeDist) node [node] (C) {2};
	\path (C) ++(-135:\nodeDist) node [node] (D) {3};
	\path (C) ++(-45:\nodeDist) node [node, label={[blue]right:(Nema dopustivog rješenja)}] (E) {4};
	
	\path (D) ++(-135:\nodeDist) node [node, label={[blue]left:$z^* \geq 4$}] (F) {5};
	\path (D) ++(-45:\nodeDist) node [node] (G) {6};
	
	\path (G) ++(-135:\nodeDist) node [node, label={[blue]right:$z < 4$}] (H) {7};
	\path (G) ++(-45:\nodeDist) node [node] (I) {8};
	
	\path (I) ++(-135:\nodeDist) node [node, label={[blue]left: (Nije dopustivo)}] (K) {9};
	\path (I) ++(-45:\nodeDist) node [node, label={[blue]right: (Nije dopustivo)}] (L) {10};
	% nacrtaj grane:
	\draw (A) -- (B) node [left,pos=0.25] {$x_1=1$}(A);
	\draw (A) -- (C) node [right,pos=0.25] {$x_1=0$}(A);
	\draw (C) -- (D) node [left,pos=0.25] {$x_2=1$}(C);
	\draw (C) -- (E) node [right,pos=0.25] {$x_2=0$}(C);
	
	\draw (D) -- (F) node [left,pos=0.25] {$x_3=1$}(D);
	\draw (D) -- (G) node [right,pos=0.25] {$x_3=0$}(D);
	
    \draw (G) -- (H) node [left,pos=0.25] {$x_4=1$}(G);
	\draw (G) -- (I) node [right,pos=0.25] {$x_4=0$}(G);
	
    \draw (I) -- (K) node [left,pos=0.25] {$x_5=1$}(I);
	\draw (I) -- (L) node [right,pos=0.25] {$x_5=0$}(I);
	
	%add text (info) x1=x4=x5=0; x2=x3=1 je optimum:
	
\end{tikzpicture}
    \caption{Drvo odluke za rješavanje problema binarnog programiranja.}
    \label{fig:bnb_binary}
\end{figure}

Prodiskutujmo ovo rješenje po čvorovima dobijenog stabla:
  \begin{itemize}
      \item U čvoru 0 imamo da je rješenje $x_i = 0$, za sve $i$, koje  nije dopustivo, ali znamo da   tada za optimalno rješenje vrijedi $z^*=f(x^*) \leq 10$.
      \item  Dalje, granamo ovaj problem na dva (korak 2), jedan gdje je $x_i=1$ a drugi $x_1=0$, odakle dobijamo dva potproblema (odgovaraju čvorovima 1 i 2). U čvoru 2 imamo potproblem za koji je $x_1=1$. Jasno je da kada uvrstimo $(1,0, \ldots, 0)$ u početni problem, da je ono dopustivo. Prema tome, optimalna vrijednost problema neće biti manji od 2, odakle zaključujemo da je za ovaj potproblem $z^*=f(x^*) \geq 2$. Dakle, imamo $LB$=2. 
      \item Problem u čvoru 2 je isti kao problem u čvoru 1, pa nastavljamo dalje sa dijeljenjem problema fiksirajući slobodne varijable. 
      \item Sada fiksiramo promjenjivu $x_2$ (uz već fiksiran $x_1=0$). 
            Za potproblem u čvoru 4, provjerimo da ne postoji dopuna do dopustivog rješenja za ovako fiksirane vrijednosti (narušeno ograničenje 1), pa tu stajemo sa njim. Za potproblem u čvoru 3, imamo sada podjelu na dva potproblema fiksirajući varijablu $x_3$, tj. dva   nova čvora 5 i 6. Za problem u čvoru 5, lako se vidi da za ovakve fiksirane varijable imamo dopustivo rješenje za koje je vrijednost funkcije cilja jednaka 4, pa zaključujemo da je $z^*=f(x^*) \leq 4$, odakle imamo $LB=4$. Problem u čvoru 6 dijelimo dalje (po varijabli $x_4$), odakle dobijamo dva nova potproblema, koji odgovaraju čvoru 7 i 8. Lako se zaključi da je $z^*<LB$ ka ovaj potproblem.  Za čvor 8, imamo novo grananje (po varijabli $x_5$). Kako su ovdje sve varijable kompletno fiksne, primijetimo da niti jedna od ovih tačaka  nije dopustiva.
            \item Prema tome, optimalno rješenje početnog problema je $LB=4$ i dostiže se u tački $x=(0, 1, 1, 0, 0)$. 
  \end{itemize}
  Potpuna enumeracija bi generisala 32 čvora za gornji problem. Implicitna enumeracija generiše svega 11 čvorova. 
 
\section{Metoda odsjecajućih ravni}
  
\emph{Metoda odsjecajućih ravni} rješava cjelobrojne programe mijenjanjem rješenja linearnog programiranja sve dok se ne dobije cjelobrojno rješenje. Metoda ne radi  na principu dijeljenja dopustivog regiona problema na podregione, kao u B\&B metodama, već radi sa samo jednim linearnim programom, kojeg poboljšava iterativnim dodavanjem novih ograničenja. Nova ograničenja sukcesivno smanjuju dopustiv region dok se ne pronađe cjelobrojno optimalno rješenje.   
 Istorijski gledano, to je prvi algoritam razvijen za probleme cjelobrojno programiranja za koji se dokazalo da konvergira u konačnom broju
koraka. Iako se algoritam generalno smatra   neefikasnim, ovaj metod je dovelo do konstrukcije drugih, učinkovitijih algoritama.  
  
 \begin{definition}{Validna nejednakost} za ILP je svako ograničenje koje ne eliminiše niti   jedno moguće cjelobrojno rješenje problema.
 \end{definition}
 Drugo ime za {validnu nejednakost} je \emph{odsjecajuća ravan}.
Recimo, ako imamo sljedeći problem ILP-a:
\begin{align*}
    &\max z = 3x_1 + 4 x_2 \\
    &\mbox{s.t.} \\
    &5x_1 + 8x_1 \leq 24 \\
    & x_1, x_2 \geq 0, x_1,x_2\in \mathbb{Z},
\end{align*}
jedna njegova validna nejednakost je $z \leq 5$. 

\begin{definition}
      Konveksni omotač za problem  ~(\ref{ilp-formulation}) je najmanji (dopustivi) poliedar nekog LP-a koji sadrži sve cjelobrojne tačke tog problema.
\end{definition}
Ako riješimo LP problem čiji je dopustivi skup konveksni omotač cjelobrojnih tačaka, onda je to rješenje optimalno za odgovarajući ILP. Međutim ovaj problem je  NP-težak, pa prema tome nije očekivano da se takav konveksni omotač može naći u generalnom slučaju. Nalazak korisnih ograničenja (ne svih) koja učestvuju u izgradnji konveksnog omotača je takođe veoma težak zadatak, mada je ovo ponekad i moguće (kao u slučaju problema trgovačkog putnika). Prema tome, ostaje nam naći korisne odsjecajuće ravni neovisno od problema nalaska konveksnog omotača, što se najčeše  u praksi i radi. 

Posmatrajmo   \emph{problem pakovanja skupa} dat na sljedeći način. Neka je data kolekcija $D$ rombova (u $\mathbb{R}^2$). 
Zadatak se sastoji od odabira maksimalnog broja rombova tako da se niti jedan od njih ne prepliće (presjeca).  Za rombove kažemo da se prepliću ako imaju barem jednu zajedničku tačku u presjeku. 
Neka je $O$ skup svih parova rombova koji se prepliću. Sljedeći ILP odgovara ovom problemu:
\begin{align*}
    &\max \sum_{d\in D}x_d\\
    & x_d + x_{d'} \leq 1, \forall (d, d^{'}) \in O \\
    & x_d \in \{0,1\}, \forall d \in D,
\end{align*}
gdje je $x_d$ binaran varijabla koja dobija vrijednost 1 ako je romb $d$ selektovan, inače 0. 
Kao što vidimo, broj binarnih varijabli u praksi može biti veoma velik, što nas rješava mogućnosti efikasne primjene neke od B\&B tehnika.

Pokušajmo dodati odsjecajuće ravni u prethodni ILP. Za svaku tačku $c$, enumerišimo sve one (moguće) rombove iz $D$ koji sadrže ovu tačku. Označimo takav skup sa $D(c)$. Prema tome, za svaki skup $D(c)$, najviše jedan romb može da bude selektovan. Sada dodajemo sljedeća ograničenja u prethodni model
\begin{equation}
     \sum_{d \in D(c)} x_d \leq 1, \forall c.
\end{equation}
Ove odsjecajuće ravni će ubrzati rješavanje ovog problema za   red veličine.

Pozabavimo se sada \emph{Gomorijevim odsjecajućim ravnima}, generalnu metodu za dodavanje odsjecajućih ravni u ILP.  Ideja je dobiti ove ravni iz nekog od ograničenja optimalne tabele simpleks metode LP relaksacije problema. Neka simpleks metod generiše sljedeći skup jednakosti u formi:

$$x_i + \sum_{ij} \overline{a}_{i,j} w_j= \overline{b}_i, i=1, \ldots,m$$
gdje su $x_i$ bazne promjenjive, a $w_j$ nebazne promjenjive. Napišimo ovu jednakost u drugačijem obliku tako da su na lijevoj strani cjelobrojni dijelovi, dok su na desnoj decimalni dijelovi, tj.
$$x_i + \sum_{j} \lfloor \overline{a}_{i,j} \rfloor w_j - \lfloor \overline{b}_i \rfloor = \overline{b}_i - \lfloor \overline{b}_i  \rfloor    - \sum_{j} (\overline{a}_{i,j} - \lfloor \overline{a}_{i,j} \rfloor) w_j.$$

Ako je $x$ dopustivo cjelobrojno rješenje, onda je desna strana manja od 1, pa kako je lijeva strana cjelobrojna u tom slučaju, dobijamo da je ona manja ili jednaka 0, pa imamo
\begin{equation}\label{eq:gomory_cuts}
    \overline{b}_i - \lfloor \overline{b}_i  \rfloor    - \sum_{j} (\overline{a}_{i,j} - \lfloor \overline{a}_{i,j} \rfloor) w_j \leq 0
\end{equation}
za bilo koje dopustivo rješenje koje je cjelobrojno. Dalje, kako su nebazne varijable jednake 0 u bilo kom baznom dopustivom rješenju, tada imamo 
$$ \overline{b}_i - \lfloor \overline{b}_i  \rfloor    - \sum_{ij} (\overline{a}_{i,j} - \lfloor \overline{a}_{i,j} \rfloor) w_j = \overline{b}_i - \lfloor \overline{b}_i \rfloor  \geq 0.$$
Prema tome, pokazali smo da odsjecajuće ravni~(\ref{eq:gomory_cuts}) ne eliminišu bazna dopustiva rješenja, pa ispunjava sve uslove za validnu nejednakost. Uvodeći dodatnu promjenjivu $y_i$ za nejednakosti u (\ref{eq:gomory_cuts}), sljedeća (validna) ograničenja dodajemo u ILP:
\begin{align}\label{gomory_cplex}
       \overline{b}_i - \lfloor \overline{b}_i \rfloor=   \sum_{j} (\overline{a}_{i,j} - \lfloor \overline{a}_{i,j} \rfloor) w_j - y_i 
\end{align}

\emph{\textbf{Primjer.}} Neka je dat sljedeći ILP problem:\\
$$\begin{array}{ll}
    &\max 3 x_1 + 4 x_2 \\
    & {s.t. }  \\
    & \frac{2}{5}x_1 + x_2 \leq 3 \\
    &\frac{2}{5}x_1 - \frac{2}{5}x_2 \leq 1 \\
    &x_1, x_2 \geq 0, \\
    &  x_1, x_1 \in \mathbb{Z}.
\end{array}$$
Riješimo ga uz pomoć gomorijevih odsjecajućih ravni. 

\emph{Rješenje.}
Inicijalna simpleks tabela je data sa 

$$\begin{array}{cccc|c}
   \frac{2}{5}           & 1               & 1 & 0 & 3 \\
   \frac{2}{5}           & -\frac{2}{5}    & 0 & 1 & 1 \\ \hline
   -3                    &  -4             & 0 & 0 & 0
\end{array}$$
Dovedimo drugu varijablu (kolona 2) u bazu, pa imamo 
$$\begin{array}{cccc|c}
   \frac{2}{5}           & 1               & 1           & 0 & 3 \\
   \frac{14}{25}         & 0               & \frac{2}{5} & 1 & \frac{11}{5}\\ \hline
   -\frac{7}{5}                  & 0               &4 & 0 & 12
\end{array}$$
Dalje, biramo pivot element u datoj simpleks tabeli, a to je elemet $\overline{a}_{2,1} = \frac{14}{25}$, pa dobijemo simpleks tabelu
$$
\begin{array}{cccc|c}
    0    &  1  &  \frac{10}{14} &  -\frac{10}{14}  &  \frac{20}{14}                  \\
    1    &  0  &  \frac{10}{14} &   \frac{25}{14}  &   \frac{55}{14}\\ \hline
    0    &  0  &  5             &    \frac{5}{2}   &    \frac{35}{2}
\end{array}
$$
Kako u posljednjoj vrsti nemamo negativnih vrijednosti, zaključujemo da je ovo optimalna simpleks tabela. Na osnovu (\ref{gomory_cplex}),   za prvi red simpleks tabele i odrogarajuće ogranjičenje generišemo odsjecajuću ravan:
$$   \frac{5}{7}x_3 + \frac{2}{7} x_4 +      y_1   = \frac{6}{14}=\frac{3}{7}$$
pa je dodajemo u (završnu) simpleks tabelu:
$$
\begin{array}{ccccc|c}
    0    &  1  &  \frac{10}{14} &  -\frac{10}{14}  &  0 & \frac{20}{14}                  \\
    1    &  0  &  \frac{10}{14} &   \frac{25}{14}  &  0 & \frac{55}{14}\\ 
    0    &  0  & \frac{5}{7}    &   \frac{2}{7}    &  -1 & \frac{3}{7}  \\
     \hline 
    0    &  0  &  5             &    \frac{5}{2}   &  0 &    \frac{35}{2}
\end{array}
$$
Načinimo sada jediničnu podmatricu u gornjoj lijevoj matrici $\overline{A}$, za treću kolonu (i odgovarajuću varijablu $x_3$), pivotirajući oko elementa $\overline{a}_{3,3}$, čime dobijamo 

$$
\begin{array}{ccccc|c}
    0    &  1  &   0 &   -1  &            1 & 1                  \\
    1    &  0  &  0 &    \frac{3}{2}  &  1 & \frac{7}{2}\\ 
    0    &  0  &  1  &   \frac{2}{5}    &  -\frac{7}{5} & \frac{3}{5}  \\
     \hline 
    0    &  0  &  0   &    \frac{1}{2}  &  7  &    \frac{29}{2}
\end{array}
$$
Kao što vidimo, rješenje problema je $(\frac{7}{2}, 1, 0, 0, \frac{3}{5})$, što i dalje nije cjelobrojno rješenje. Dalje, dodajemo novu odsjecajuću ravan, koja se izvodi iz drugog ograničenja (drugi red simpleks tabele): 
$$ \frac{1}{2} x_4 - y_2 = \frac{1}{2}.$$
Dodajmo ovo ograničenje u posljednju simpleks tabelu:

$$
\begin{array}{cccccc|c}
    0    &  1  &   0 &   -1  &            1 & 0 & 1                  \\
    1    &  0  &  0 &    \frac{3}{2}    &  1 & 0 &  \frac{7}{2}\\ 
    0    &  0  &  1  &   \frac{2}{5}    &  -\frac{7}{5} &  0 & \frac{3}{5}  \\
    0    & 0   &  0  &   \frac{1}{2}    & 0     & -1 & \frac{1}{2} \\
     \hline 
    0    &  0  &  0   &    \frac{1}{2}  &  7  &   0 &  \frac{29}{2}
\end{array}
$$
Sada za varijablu $x_4$ (četvrta kolona), pivotiramo oko elementa $\overline{a}_{4,4}$, pa dobijamo simpleks tabelu 

$$
\begin{array}{cccccc|c}
0 &  1   &  0  &  0  &    1             &    -2           &   2         \\
1 &  0   &  0  &  0  &    1             &     3           &   2         \\
0 &  0   &  1  &  0  &   -\frac{7}{5}   &     \frac{4}{5} &   \frac{1}{5}\\
0 &  0   &  0  &  1  &   0              &    -2           &   1   \\ \hline
0 &  0   &  0  &  0  &   7              &     1           &   14
\end{array}
$$


Iz tabele zaključujemo da je bazno rješenje problema 
$x=(2,2, \frac{1}{5}, 1)$, a optimalno $(2, 2)$, što je i optimalno rješenje početnog problema. 

Rješenje ILP problema gdje su svi koeficijenti u ograničenjima cjelobrojni, je prikazano sljedećim primjerom. \\
%https://www.math10.com/en/geometry/geogebra/geogebra.html
\emph{Primjer}. Riješimo sljedeći problem ILP-a:
\begin{align*}
    &\max 3 x_1 + 4 x_2 \\
    &\mbox{s.t.} \\
    & 3 x_1 - x_2 \leq 12 \\
    & 3 x_1 + 11 x_2 \leq 66 \\
    & x_1, x_2 \geq 0 \\
    & x_1, x_2 \in \mathbb{Z}
\end{align*}
\emph{Rješenje. }
Na Slici~ \ref{fig:region_ilp_primjer_2} dat je skup tačaka koje su dopustive za problem, za koji je optimalna tačka $x^*=(5,4)$.
\begin{figure}
    \centering
    \includegraphics[width=170pt,height=170pt]{region_ilp_primjer_2.eps}
    \caption{Dopustiv skup tačaka problema.}
    \label{fig:region_ilp_primjer_2}
\end{figure}

Riješimo sada ovaj problem uz pomoć Gomorijevih odsjecajućih ravni. 
Početna simpleks tabela je data sa 
$$\begin{array}{ccc c| c}
    3  & -1 & 1 &  0  & 12  \\
    3  & 11 & 0 &  1  & 66 \\ \hline
   -3  & -4 & 0 &  0  & 0
\end{array}$$
Nakon dvije iteracije pivotiranja, dobijamo simpleks tabelu 
$$\begin{array}{ccc c| c}
1 & 0 &  \frac{11}{36}   &  \frac{1}{36}  &  \frac{11}{2} \\
0 & 1 &  -\frac{1}{12}  &  \frac{1}{12}  &  \frac{9}{2}   \\ \hline
0 & 0 &  \frac{7}{12}   &  \frac{5}{12}  &  \frac{69}{2}
\end{array} $$
Optimalno rješenje je $x^* = (\frac{11}{2}, \frac{9}{2}, 0, 0)$ koje nije cjelobrojno. Dodajmo gomorijevu odsjecajuću ravan generisanu iz ograničenja u prvoj vrsti simpleks tabele (za prvu baznu komponentu $x_1^* = \frac{11}{2}$):
$$  \frac{11}{36} x_2 + \frac{1}{36} x_3 - y_1 = \frac{1}{2},$$
pa dobijamo tabelu 
$$\begin{array}{ccccc| c}
1 &  0 &   \frac{11}{36}  & \frac{1}{36}   &  0 & \frac{11}{2} \\
0 &  1 &   -\frac{1}{12}  & \frac{1}{12}   &  0 & \frac{9}{2} \\
0 &  0 &  \frac{11}{36}   &  \frac{1}{36}  & -1 & \frac{1}{2} \\ \hline
0 & 0  &  \frac{7}{12}    & \frac{5}{12}   &  0 & \frac{69}{2}
\end{array} $$
Kako bazno dopustivo rješenje nije očigledno, primijenimo dvofazni simpleks metod da bi izabrali bazu, odakle dobijamo tabelu 
$$\begin{array}{ccccc| c}
1   &   0       &   0   &   0             & 1              & 5 \\
0   &   1       &   0   &   \frac{1}{11}  & -\frac{3}{11}  & \frac{51}{11} \\
0   &   0       &   1   &   \frac{1}{11}  & -\frac{36}{11} &  \frac{18}{11} \\ \hline
0   &   0       &   0   &   \frac{4}{11}  & \frac{21}{11}  &  \frac{369}{11} \\
\end{array} $$
Kako su svi koeficijenti u posljednjoj vrsti veći od 0, slijedi da je optimalno bazno rješenje jednako $x=(5, \frac{51}{11}, \frac{18}{11}, 0, 0)$, koje opet nije cjelobrojno. 
 Prema tome, dodajmo sljedeću gomorijevu odsjecajuću ravan za bazno rješenje $x^*_2 = \frac{51}{11}$ (posmatrajući vrstu 2 posljednje simpleks tabele):
 
 $$ \frac{1}{11} x_4 + \frac{8}{11} x_5 - y_2 = \frac{11}{18},$$
 odakle imamo tabelu 
 $$\begin{array}{cccccc| c}
 1   &   0   &  0  &   0             &   1  &   0              &   5 \\
 0   &   1   &  0  &  \frac{1}{11}    &   -\frac{3}{11}    &  0 & \frac{51}{11} \\
 0   &   0   &  1  &  \frac{1}{11}    & -\frac{36}{11}       & 0 & \frac{18}{11}  \\
 0   &   0   &  0  &  \frac{1}{11}    &  \frac{8}{11}   & -1 & \frac{7}{11} \\ \hline
 0   &   0   &  0  &   \frac{4}{11}   &   \frac{21}{11} & 0 & \frac{369}{11}
\end{array} $$
I dalje nije očigledno šta su bazne varijable, pa uradimo dvofazni simpleks metod, te dobijamo 
 $$\begin{array}{cccccc| c}
1    &   0   &   0   &  -\frac{1}{8}   &   0    &    \frac{11}{8}    &  \frac{33}{8} \\
0    &   1   &   0   &   \frac{1}{8}   &   0    &    -\frac{3}{8}    & \frac{39}{8} \\
0    &   0   &   1   &   \frac{1}{2}   &   0    &    - \frac{9}{2}   & \frac{9}{2} \\
0    &   0   &   0   &   \frac{1}{8}   &   1    &    - \frac{11}{8}  & \frac{7}{8} \\ \hline
0    &   0   &   0   &   \frac{1}{8}   &   0    &     \frac{21}{8}   & \frac{255}{8}
\end{array} $$
Odgovarajuće optimalno bazno dopustivo rješenje i dalje nije cjelobrojno -- niti jedna komponenta nije cjelobrojna. 

Prema tome, dodajemo gomorijevu odsjecajuću ravan za vrstu 2 prethodne simpleks tabele, koja je oblika
$$  \frac{1}{8}x_4 + \frac{5}{8} y_2 - y_3 = \frac{7}{8},$$
te dobijamo tabelu
$$ \begin{array}{ccccccc| c}
1    &   0   &   0   &  -\frac{1}{8}   &   0    &    \frac{11}{8}    & 0 & \frac{33}{8} \\
0    &   1   &   0   &   \frac{1}{8}   &   0    &    -\frac{3}{8}    & 0 & \frac{39}{8} \\
0    &   0   &   1   &   \frac{1}{2}   &   0    &    - \frac{9}{2}   & 0 & \frac{9}{2} \\
0    &   0   &   0   &   \frac{1}{8}   &   1    &    - \frac{11}{8}  & 0    & \frac{7}{8} \\ 
0    &   0   &   0   &   \frac{1}{8}   &   0    &    \frac{5}{8}   & -1 & \frac{7}{8} \\ \hline
0    &   0   &   0   &   \frac{1}{8}   &   0    &     \frac{21}{8}   & 0 & \frac{255}{8}   
\end{array} $$
I dalje nije jasno koju još varijablu treba dodati u bazne varijable (bazu), uradimo dvofazni simpleks metod, odakle dobijamo 

$$ \begin{array}{ccccccc| c}
    1    &   0   &   0   &  0 &  1  &   0    &    0    & 5  \\
0    &   1   &   0   &  0   &   -\frac{1}{2}    &   0   & \frac{1}{2} & 4 \\
0    &   0   &   1   &  0   &   -\frac{7}{2}    &   0   & \frac{1}{2} & 1 \\
0    &   0   &   0   &  1  &   \frac{5}{2}    &  0 &  -\frac{11}{2}    & 7 \\ 
0    &   0   &   0   &   0 &  -\frac{1}{2}    &   1   & - \frac{1}{2} & 0\\ \hline
0    &   0   &   0   &  0  &   1    &    0   & 2 & 31  
\end{array} 
$$
gdje je lako uočiti da je optimalno bazno dopustivo rješenje $x=(5, 4, 1, 7, 0, 0, 0 )$, tj. rješenje početnog problema je $x^*=(5, 4)$.

\section{B\&C algoritam za rješavanje ILP-a}
%https://homepages.rpi.edu/~mitchj/handouts/bc_algo/
% http://www.mi.fu-berlin.de/wiki/pub/Main/GunnarKlauP1winter0708/discMath_klau_ILP_I.pdf
Za razliku od B\&B procedure koja rješava ILP, B\&C dodaje  i metod odsjecajućih ravni u rješavanju  potproblema koji odgovaraju čvorovima (drveta). Dakle, ako  uzimamo trenutno aktivni čvor i rješavamo njegov potproblem, dijelimo ga na nekoliko potproblema (podjelom dopustivog regiona na više disjunktnih -- dodavanjem ograničenja) ili ga rješavamo rekurzivnim dodavanjem (gomorijevih) odsjecajućih ravni. Dekonstrirajmo ovu ideju na rješavanje jednog ILP-a.

\emph{Primjer}.  Riješimo problem modelovan uz pomoć sljedećeg ILP-a:
\begin{align*}
    &\max 6 x_1 + 5 x_2 \\
    &  {s.t. } \\
    & 3x_1 + x_2 \leq 11 \\
    & - x_2 + 2 x_2 \leq 5 \\
    & x_1, x_2 \geq 0 \\
    & x_1, x_1 \in \mathbb{Z}
\end{align*}

\emph{Rješenje}. B\&C procedura prvo rješava LP relaksaciju početnog problema (simpleks metodom), odakle dobijamo rješenje $x=(\frac{17}{7}, \frac{26}{7})$
sa optimalnom vrijednošću $33\frac{1}{7}$. Nakon toga treba da se donese odluka, da li se problem rješava dodavanjem odsejcajućih ravni ili podjelom dopustivog regiona na manje (disjunktne) podregione. Podijelimo region po koordinati $x_1$, odakle ćemo dobiti dva potproblema 

\begin{align*}
    &\max 6 x_1 + 5 x_2 \\
    & {s.t. } \\
    & 3x_1 + x_2 \leq 11 \\
    & - x_2 + 2 x_2 \leq 5 \hspace{2cm} (P1) \\
    & x_1 \geq 3 \\
    & x_2 \geq 0 \\
    & x_1, x_2 \in \mathbb{Z}
\end{align*}

\begin{align*}
    &\max 6 x_1 + 5 x_2 \\
    & {s.t. } \\
    & 3x_1 + x_2 \leq 11 \\
    & - x_2 + 2 x_2 \leq 5 \hspace{2cm} (P2) \\
    & x_1  \leq 2 \\
    & x_2 \geq 0 \\
    & x_1, x_2 \in \mathbb{Z}
\end{align*}

Relaksacija problem ($P1$) daje riješenje $x^*=(3,2)$, koje je cjelobrojno, pa prema tome i dopustivo u početnom problemu. Njena vrijednost je 28, što je i donja granica ($LB$) početnog problema. Relaksacija problema ($P2$) nam daje rješenje $x^*=(2, \frac{7}{2})$, čija je optimalna vrijednost $\frac{29}{2}$.  Prema tome, rješenje nije cjelobrojno. Primjenjujući metod gomorijevih odsjecajućih ravni na problem ($P2$), konstruišemo odsjecajuću ravan $2x_1 + x_2 \leq 7$ koju dodajemo u problem ($P2$) pa dobijamo problem 
\begin{align*}
    &\max 6 x_1 + 5 x_2 \\
    & {s.t. } \\
    & 3x_1 + x_2 \leq 11 \\
    & - x_2 + 2 x_2 \leq 5  \\
    & 2x_1 + x_2 \leq 7 \hspace{2cm} (P3)\\ 
    & x_1  \leq 2 \\
    & x_2 \geq 0 \\
    & x_1, x_2 \in \mathbb{Z}
\end{align*}

Rješavajući LP relaksaciju problema ($P3$), dobijamo rješenje $x^*=(\frac{9}{5}, \frac{17}{5})$, tj.  optimalna vrijednost je $27.8$. Kako je $LB \geq 28.8$, niti jedno cjelobrojno rješenje problema ($P3$) ne može biti bolje od trenutno najbolje donje granice ($LB=28$), pa zaključujemo da je optimalo rješenje početnog problema $x^*=(3,2)$. 

\section{Lagranžova relaksacija}
U rješavanju problema optimizacije, nalazak optimalnog rješenja je jedan od glavnih ciljeva. Međutim, za mnoge probleme nije realno očekivati da se garantuje optimalnost, već najbolje što se može učiniti za data ograničenja  je da se ponudi dobra donja granica za optimalnu vrijednost. Ako je ta ganica blizu optimuma, u mnogo slučajeva ona može da zamijeni optimum, štedeći resurse kojima raspolažemo. 

Ideja \emph{Lagranžove relaksacije} se sastoji u tome da u modelu ILP-a  koji ima  ograničenja koja čine problem teškim (ova procjena je najčešće stvar praktičnog iskustva),  posmatramo kao dio ciljne funkcije koju penalizujemo nekim parametrom.  %parametrom $\lambda>0$. 
Ovo ograničenje potom brišemo iz skupa ograničenja modela a zatim rješavamo novi problem. Na ovaj način, rješenje ovakvog problema je donja granica (za problem minimizacije) za optimalno rješenje datog problema. U praksi, ona je često jako blizu vrijednosti optimuma. 

\emph{Primjer}. Posmatrajmo problem \emph{najkraćeg puta sa ogaraničenjem} (eng. \emph{Constrained Shortest Path Problem}). Neka je dat usmjeren neciklični graf $G=(V,E)$. Za svaku granu $(i,j) \in E$ dodijelimo cijenu puta $c_{i,j}$ i vrijeme putovanja $t_{i,j}$. Pretpostavimo da je čvor $i=1$ startni čvor (izvorišni čvor), a čvor $n = |V|$   završni čvor (terminalni čvor). Zadatak je da se nađe put  od izvorišnog do terminalnog čvora koji je najeftiniji ali tako da se čitav put pređe u vremenskom periodu $T$.

Ovaj problem se modeluje pomoću sljedećeg ILP-a:
 \begin{align}
    &z^*=\min\sum_{(i,j) \in E }c_{i,j}x_{i,j} \\
    &{s.t. }\\
    & \sum_{i} x_{i,j} - \sum_{i} x_{j,i} = \begin{cases}  
                                               1, \mbox{ ako } i=1 \\
                                              -1, \mbox{ ako } i=n \\
                                               0, \mbox{ inače }
                                            \end{cases} \\
    & \sum_{(i,j) \in E} t_{i,j} x_{i,j} \leq T \\
    & x_{i,j} \in \{0, 1 \}, \forall (i,j) \in E.
\end{align} 

Binarna varijabla $x_{i,j}$ dobija vrijednost 1 ako je odabrana grana $(i,j)$ na   putu, a 0 inače.  
Prvo ograničenje u modelu nam daje da je dopustivo rješenje upravo put od izvorišnog do terminalnog čvora. Drugo ograničenje nam kazuje da je vrijeme prelaska puta u granicama dopustivog. Ovo ograničenje spada pod ``komplikovanim'' ograničenjima jer, kao što znamo,  pronalazak najkraćeg puta u direktnim grafovima sa unaprijed definisanim izvorišnim čvorom je polinomijalno rješiv (Dajkstrin algoritam), dok dodavanjem ograničenja o vremenu taj problem postaje NP-težak problem. Ideja je sada relaksirati ovaj problem uz prebacivanje ograničenja za vrijeme u funkciji cilja koja se zatim penalizuje. 
Dakle, Lagranžova relaksacija problema je data sa:

\begin{align*}
       &L(\lambda)= \min\sum_{(i,j) \in E }c_{i,j}x_{i,j}  + \lambda(\sum_{(i,j) \in E} t_{i,j} x_{i,j} - T ) = \min \sum_{(i,j) \in E} (c_{i,j} + t_{i,j} )x_{i,j} - \lambda T \\
        &{s.t. }\\
    & \sum_{i} x_{i,j} - \sum_{i} x_{j,i} = \begin{cases}  
                                               1, \mbox{ ako } i=1 \\
                                              -1, \mbox{ ako } i=n \\
                                               0, \mbox{ inače }
                                            \end{cases} \\
     & x_{i,j} \in \{0, 1 \}, \forall (i,j) \in E.
\end{align*}
Primijetimo da je $L(\lambda) \leq z(\lambda)  \leq z^*$, za sve $\lambda > 0$, gdje je $z(\lambda)$ problem koji ima funkciju cilja $L(\lambda)$ uz uključeno ograničenje o vremenu u skup ograničenja modela. Dakle, za $\lambda >0$, $L(\lambda)$ nam daje donju granicu za optimalno rješenje početnog problema. 

Problem $L^* = \max \{ L(\lambda) \mid \lambda > 0  \}$ se naziva \emph{problem lagranžovog multiplikatora}. Može se pokazati da vrijedi 
$$ L(\lambda) \leq L^* \leq z^*.$$

U praksi se pokazalo da je Lagranžova relaksacija dobra tehnika za dobijanje granica za optimalnu vrijednost problema. Pokušajmo sada primijeniti ovu tehniku na \emph{problem trgovačkog putnika}.  

Pogledajmo ovaj problem sa grafovske strane. Znamo da kolekcija grana formira rutu ako su svaka dva čvora grafa pokrivena sa dvije grane. Takođe, ako obrišemo grane incidentne sa čvorom 1, ostatak rute čini stablo koje pokriva graf  $G\setminus \{1\}$.  
Definišimo sa $A(j)$ skup svih čvorova koji su incidentni sa čvorom $j$. Relaksacija: definišimo sa $T_1$ skup svih ruta koje nakon brisanja grana koje pokrivaju čvor $1$ formiraju drvo.  

Shodno tome, konstruišemo model
\begin{align*}
    &z^* = \min \sum_{(i,j)\in E} c_{i,j} x_{i,j}\\
    & \sum_{ \{ i \mid (i,j) \in E \} } x_{i,j} = 2, \forall i \in \{1,\ldots, n \} \\
    & x \in T_1,
\end{align*}
gdje $x_{i,j} = 1$ ako grana $(i,j)$ pripada ruti, a 0 inače.

Lagranžova relaksacija za ovaj problem može se zadati sa 
\begin{align*}
     &L(\lambda) = \min \sum_{(i,j)\in E} c^\lambda_{i,j} x_{i,j} - 2 \sum_{i} \lambda_i \\
     & x \in T_1
\end{align*}
gdje je $\lambda=(\lambda_1, \ldots, \lambda_n)$ i $c^\lambda_{i,j} = c_{i,j} + \lambda_i + \lambda_j$. 

Rješenje problema lagranžovog multiplikatora u praksi daje izvrsna rješenja i obično su rješenja blizu prave rute. Optimalno pokrivajuće stablo lagranžovog problema $L(\lambda^*)$ za optimalni $\lambda^*$ će nam često u praksi dati rješenje sa  nekoliko visećih čvorova. 

Konstruišimo još jednu Lagranžovu relaksaciju za ovaj problem uvodeći \emph{ograničenja pokrivanja}, tj. da u svakoj ruti broj grana koje imaju oba kraja u skupu čvorova $S$ kardinalnosti $|S|$ je najviše $|S|-1$, pa imamo: 

\begin{align*}
     & z^* = \min \sum_{(i,j)\in E} c_{i,j} x_{i,j} \\
     & \sum_{ \{ i \mid (i,j) \in E \} } x_{i,j} = 2, \forall i \in \{1,\ldots, n \} \\
     & \sum_{(i,j) \in E  \wedge i,j \in S} x_{i,j} \leq |S|-1, \forall S \subseteq V \\
     & x_{i,j} \in \{0, 1 \}, (i,j)\in E.
\end{align*}
Lagranživa relaksacija prethodnog ILP-a ima oblik 
\begin{align*}
 &L(\lambda) = \min \sum_{(i,j)\in E} c^\lambda_{i,j} x_{i,j} - 2 \sum_{i} \lambda_i \\
 & \sum_{(i,j) \in E} x_{i,j} \leq |S|-1, \forall S \in V \\
 & \sum_{(i,j) \in E} x_{i,j} = n
\end{align*}
gdje je $\lambda=(\lambda_1, \ldots, \lambda_n)$ i $c^\lambda_{i,j} = c_{i,j} + \lambda_i + \lambda_j$. 

% interior point method (dodati)...
\section{Metod Generisanja Kolona}% ovo je za LP probleme sa velikim brojem kolona, pogledati u https://coral.ise.lehigh.edu/~ted/files/ie418/lectures/Lecture18.pdf file:///C:/Users/PC/Downloads/ColumnGenerationTutorial.pdf

%video: https://www.youtube.com/watch?v=O918V86Grhc
Često se u praksi nalazi na situaciju da je u LP-u (ili ILP-u) broj varijabli puno (eksponencijalno) veći  u odnosu na broj ograničenja. U osnovi, riječ je o ekstremno velikim modelima sa matricom $A$ velikih dimenzija. Kada je riječ o rješavanju ovakvih problema, veliki dio matrice (tj. njene kolone) nam obično nikada i neće biti relevantan u rješavanju. Da bi se riješila specifična instanca problema, ono što nam je potrebno su:
\begin{itemize}
    \item Ograničenja koja se vežu uz optimalnost.
    \item Varijable koje su bazne u optimalnom rješenju.
\end{itemize}
Dakle, ono što je potrebno su ograničenja čije su odgovarajuće dualne vrijednosti pozitivne, kao i varijable koje imaju pozitivne vrijednosti koeficijenata doprinosa za optimalno rješenje (tj. vektor  $\overline{c}$). Ako bismo imali ove varijable i ograničenja na raspolaganju od početka, problem bi riješili veoma brzo. Međutim, ovo nije  besplatna informacija.  U simpleks metodi, vektor doprinosa je potrebno računati u svakoj iteraciji, što nije efikasno ako je matrica $A$ velikih dimenzija. Takođe, vrijeme potrebno za generisanje simpleks tabele bi bilo ogromno.  Oba ova problema su rješiva uz pomoć \emph{metode generisanja kolona}.  Ideja ovog metoda se sastoji u sljedećem. 
\begin{itemize}
    \item Krenimo sa ``obećavajućim'' podskupom $S$ kolona matrice $A$; 
    \item Riješimo restrikovani LP na odabrnom podskupu kolona $S$; 
    \item Procijenimo ostale kolone i dodajmo u $S$ one sa negativnim 
          cijenama doprinosa;
    \item Itrerativno pozivamo perthodna dva koraka dok god postoje kolone   sa negativnim doprinosom koje nisu u $S$.
\end{itemize}
Tehnički zapisano, krećemo od \emph{restrikovanog master problema} (RMP)
\begin{align*}
    &\min c^T x \\
    &\mbox{s.t} \\
    & \sum_{i \in I} A_i x_i  \leq b \hspace{2cm} (RMP)\\
    & x \geq 0. 
\end{align*}
gdje $I$ inicijalizujemo kao skup kolona kojie čine inicijalno BDR za RMP (i po mogućnosti neke druge kolone za koje mislimo da su ``bitne'' u kontekstu problema).  Riješimo RMP,  te izračunamo odgovarajuće optimalno dualno rješenje. Sada je potrebno naći varaijblu $x_j$ i odgovarajuću kolonu $A_j$ za koju je koeficijent doprinosa negativan, tj. $\overline{c_j} = c_j - c_B^T B^{-1}A_j < 0$.
%Pogledati: https://www.youtube.com/watch?v=0SV99VJaGzw
Ovo se može uraditi rješavanjem \emph{column generating potproblema} (CGSP):
$$\min_{a \in C} \overline{c_j} = \min_{a \in C} c_a - c_B^T B^{-1} a,$$
gdje je $C$ skup kolona nad nekim globalnim skupom. Za LP problem možemo staviti $C = \{1,\ldots,n\}$. 

Ako je rješenje problema kolona $a \in C$ za koju je $\overline{c_a}<0$, dodamo odgovarajuću $A_a$ u skup $S$, te riješimo  RMP na novom skupu kolona. Ako ne postoji takva kolona, onda je rješenje RMP takođe optimalno i za početni problem. %Ovaj metod se još naziva \emph{generički metod generisanja kolona}.   
 Proces dodavanja kolona se nastavlja sve dok postoji kolona $a\in C$ sa negativnom cijenom doprinosa. 

Postoji mnogo pristupa kako ažurirati skup $S$ tokom iteracija. 
Najjednostavniji se tiče zadržavanja svake kolone koja je do sada izgenerisana  u skup $S$ i dodati novu u postojeći skup. Naprednija strategija se tiče izbacivanja onih kolona iz skupa $S$ koje su nebazne u svakoj iteraciji. 

\emph{Bazna column generation šema.} U osnovi, šema se sastoji od dva koraka:
\begin{enumerate}
	\item Prvo izaberemo za ulazne kolone one sa najvećim negativnim koeficijentom doprinosa među varijablama koje odgovaraju skupu $I$.
	\item Jednom kada su svi koeficijenti nenegativni (tj. kada smo našli optimalnu vrijednost za  RMP), tražimo nove varijable (kolone) van skupa $I$ (rješavajući CGSP) koje će biti ubačene u $I$. 
\end{enumerate}
Ako u koraku 1 za skup $I$ uzmemo bazne kolone, u svakom koraku pri rješavanju CGSP dobijamo kolonu koja ulazi kao bazna i zamjenjuje kolonu iz $I$. To znači da rješavanje RMP traje samo jednu iteraciju (simpleks metoda), jer uvijek imamo $m$ kolona i novu ulaznu kolonu $A_a$. Dakle, ovaj proces ne uzima mnogo memorije i rješavanje RMP je efikasno. Težište je ovdje prebačeno na korak 2 i rješavanje CGSP. Ako ne postoji efikasan način rješavanja ovog problema, onda efikasna primjena CG frejmvorka je nerealna.  
 

Iterativni proves rješavanja RMP problema se može prekinuti i ranije (bez dostizanja optimalnog rješenja početnog problema), usljed velikog broja iteracija,  iako je moguće da postoje kolona van RMP problema koje će eventualno ući u konstrukciju optimalne baze.  Takođe, ako RMP nije riješen do optimalnosti u nekoj iteraciji, ali CGSP jeste, i dalje se garantuje rješavanje početnog (LP) problema do optimalnosti kada se (master) iteracije prekinu. Prema tome, rješavanje RMP problema u svakoj iteraciji nije toliko bitno dok god rješavamo CGSP do optimalnosti u svakom koraku. Obruto ne vrijedi:   ako bi iskoristili neku heuristiku za rješavanje CGSP, onda se optimalnost početnog LP-a ne može garantovati. Razlog je vrlo jednostavan, heuristika treba da nađe bilo koju kolonu sa negativnim koeficijentom doprinosa koja će biti ubačena u RMP, čine se proces (uspješno) nastavlja. Ali, ako heuristika ne uspije u nalasku takve kolone, to ne znači da takva kolona ne postoji. 


 U nastavku dajemo primjenu \emph{metode generisanja kolona} na poznatom \emph{Cutting stock} problemu. 
 
 \emph{Problem}. Tvornica papira proizvodi rolne papira fiksne širine  $W$. 
 Kupci naručuju različit broj rolni različite širine $w \in \mathbb{R}^m$, dok je sa vektorom $b \in \mathbb{R}^m$ dat zahtjev (broj naručenih rolni).  Zadatak je pronaći optimalan način  rezanja velike rolne da bi se zahtjevi ispunili, a smanjio otpad.  
 
 \emph{Rješenje.} Na Slici~\ref{fig:cuting_stock_solutions} je dato rješenje jedne instance problema. 
 Što se tiče kolona za ovom problemu, one predstavljaju dopustive obrasce (kombinacije rezanja). Jedan dio obrasca sa slike bi bio $1820$ x $2$ (rolne) u prvoj koloni.
 Primijetimo da broj različitih obrazaca raste eksponencijalno u odnosu na broj narudžbi.  Ako bismo izvršili enumeraciju svih mogućih obrazaca, trebali bi riješiti sljedeće ILP modele:
 \begin{align*}
      & \min \sum_{i} x_i \\
      & \sum_{ij} a_{i,j }x_j \geq b_i, \forall i \hspace{2cm} (CSILP)\\
      &  x_j \geq 0, x_{j} \in \mathbb{Z} 
 \end{align*}
 gdje je $a_{i,j}$ broj puta da se narudžba $i$ pojavi u obrascu $j$ (vrsta na slici), dok  je $x_j$ broj puta koliko je obrazac $j$ korišten. Primjera radi, na  Slici~\ref{fig:cuting_stock_solutions} je $a_{1,1}=3$ i $x_1 = 2$, dok je $a_{1,2}=0$; $a_{1,5}=1$ i $ x_5 = 12$.
 
 Ideja je ne stvarati obrasce na početku, već ih generisati prema potrebi (po kolonama) koristeći \emph{metod generisanja kolona}. Kolona $a$ odgovara dopustivom obrascu akko vrijedi 
 $$ \sum_{i=1}^m a_i w_i \leq W,$$
 gdje $a$ sadrži samo nenegativne (cjelobrojne) vrijednosti. 
% Primijetimo da je cijena svakog paterna po kolonama jednaka za svaku kolonu. 
Primijetimo da je na osnovu prethodnog (razmatrajući relaksaciju problema  $CSILP$), vrijednosti koeficijenata doprinosa 
jednaki $\overline{c} = 1 - \sum_{i} a_{j,i} y_i$.  
 Dakle, CG potproblem izgleda ovako:
$$ \begin{array}{lll}
     &\max& \sum_{i=1}^m y_i a_i \\
     &  &\sum_{i} w_i a_i \leq W \hspace{2cm} (CGP)\\
     & &a_i \geq 0 \\
     & &a_i \in \mathbb{Z},
 \end{array}$$
  gdje su $y_i$ vrijednosti optimuma duala. 
 Ovaj problem je poznat pod nazivom \emph{cjelobrojni problem ruksaka} (eng. integer knapsack problem). Iako je NP-težak, on se u praksi rješava na vrlo efikasan način uz pomoć dinamičkog programiranja. 
 
 \begin{figure}[!ht]
     \centering
     \includegraphics[width=230pt, height=230pt]{cutting_stock.eps}
     \caption{Rješenje jedne instance.}
     \label{fig:cuting_stock_solutions}
 \end{figure}
 Za ovaj problem je lako naći inicijalno bazno dopustivo rješenje:
 za $i$-tu baznu kolonu uzimamo $i$-ti jedinični vektor, tj. obrazac dobijen rezanjem jedne rolne dužine $w_i$. Ovakav skup kolona formira inicijalnu dopustivu bazu. Svakako, malo je vjerovatno da će ove kolone biti korištene u optimalnom rješenju. 
 Prema tome, algoritam za ovaj problem bi išao ovako:
 \begin{enumerate}
     \item Konstruišimo inicijalno bazno dopustivo rješenje (jedinični vektori) i kolone ubacimo u skup $S$.
     \item Riješimo relaksaciju restrikovanog problema ($CSILP$) i vratimo dualno optimalno rješenje. 
     \item Riješimo ($CGP$).
     \item Ako je vrijednost optimalnog rješenja negativna, ubaciti novu kolonu $a$ (koja je rješenje potproblema) u skup $S$. Inače, prekidamo proces jer je optimalno rješenje nađeno. 
     \item Riješiti relaksaciju ($CSILP$) na novom skupu kolona $S$.
 \end{enumerate}
 Primijetimo da je dodavanje nove kolone u $S$ odgovara dodavanju novog obrasca (u rješenje). 
 
 \emph{Primjer.} Riješimo sada jednu instancu ovog problema pomocu CG frejmvorka. Recimo da imamo $W = 15$, te tri narudžbe za sječenje:
 \begin{enumerate}
 	\item stavka: $b_1=80$ rolni dužine 4;
 	\item stavka: $b_2=50$ rolni dužine 6;
 	\item stavka: $b_3=100$ rolni dužine 7. 
 \end{enumerate}
 Označimo sa $A_j = \begin{pmatrix}
                          a_4 \\
                          a_6 \\
                          a_7
                   \end{pmatrix}$
               je patern $j$, koji označava koliko   kojih ronli smo ugradili u veliku rolnu na jediničnu širinu. Enumerišimo sve paterne i otpad koji se generiše njime: 
               $$A_1 = 
               \begin{pmatrix}
               	     3 \\
               	     0 \\
               	     0  
               \end{pmatrix},
               A_2=\begin{pmatrix}
                 	0 \\
                	2 \\
                	0  
               \end{pmatrix}, 
           A_3=\begin{pmatrix}
           	0 \\
           	0 \\
           	2  
         \end{pmatrix},
           A_4=  \begin{pmatrix}
           	2 \\
           	0 \\
           	1  
           \end{pmatrix},
       A_5 = \begin{pmatrix}
       	2 \\
       	1 \\
       	0  
       \end{pmatrix},
   A_6 =\begin{pmatrix}
      	0 \\
        1 \\
      	1  
   \end{pmatrix},$$
sa veličinom otpada 
$$ waste_1 = 3, waste_2 = 3, waste_3 = 1, waste_4 = 0, waste_5 = 1, waste_6 = 2,$$
redom. 
ILP model koji odgovara gore ulaznim podacima je sljedeći:
\begin{align*}
	 &\min x_1 + x_2 + x_3 + x_4 + x_5 + x_6 \\
	 &s.t. \\
	 &\begin{pmatrix}
	 	3 \\
	 	0 \\
	 	0  
	 \end{pmatrix} x_1 + \begin{pmatrix}
	 0 \\
	 2 \\
	 0  
 \end{pmatrix} x_2 +\begin{pmatrix}
 0 \\
 0 \\
 2  
\end{pmatrix} x_3 + 
 \begin{pmatrix}
	2 \\
	0 \\
	1  
\end{pmatrix} x_4 + 
 \begin{pmatrix}
	2 \\
	1 \\
	0  
\end{pmatrix} x_5 + 
\begin{pmatrix}
	0 \\
	1 \\
	1  
\end{pmatrix} x_6 = \begin{pmatrix}
      80 \\
      50 \\
      100
\end{pmatrix} \\
& x_i \geq 0, x_i \in \mathbb{Z}, i=1,\ldots,6.
\end{align*}
 Uzmimo prve tri varijable $x_1, x_2$ i $x_3$ koji će generisati početni skup kolona $I$.
 Dakle, imamo sljedeći restrikovani MP:
 \begin{align*}
 	 &\min x_1 + x_2 + x_3 \\
 	 & s.t. \\
 	 &\begin{pmatrix}
 	 	3 \\
 	 	0 \\
 	 	0  
 	 \end{pmatrix} x_1 + \begin{pmatrix}
 	 	0 \\
 	 	2 \\
 	 	0  
 	 \end{pmatrix} x_2 +\begin{pmatrix}
 	 	0 \\
 	 	0 \\
 	 	2  
 	 \end{pmatrix} x_3 = \begin{pmatrix}
  	     80 \\
  	     50 \\
  	     100
  \end{pmatrix} \\
  & x_i \geq 0, x_i \in \mathbb{Z}, i=1,2,3.
 \end{align*}  
Da bi problem gledali sa jednostavnije strane, izbacimo uslove integralnosti (cjelobrojnosti promjenjivih). Tada ovaj problem možemo da riješimo uz pomoć simpleks metoda gdje je 
$B^{-1} =\begin{pmatrix}
	    \frac{1}{3} & 0 & 0 \\
	    0 & \frac{1}{2} & 0  \\
	    0 &   0 & \frac{1}{2}
\end{pmatrix}$ a završna simpleks tabela ima oblik 

\begin{center}
 
\begin{tabular}{cccc|c}
	  $x_1$ &     $\frac{1}{3}$  &   0 & 0  & $\frac{80}{3}$ \\
	  $x_2$ &     0              &  $\frac{1}{2}$  & 0 & $25$ \\
	  $x_3$ &     0              &  0    &  $\frac{1}{2}$  & 50 \\ \hline
	  $z$   &  $\frac{1}{3}$     &  $\frac{1}{2}$   &  $\frac{1}{2}$ & $\frac{305}{3}$ 
\end{tabular}
\end{center}
Sljedeći korak je naći kolonu čija je koeficijent doprinosa negativan i upaciti je potom u restrikovani MP da bi se trenutno rješenje poboljšalo. Treba da riješimo column generating potproblem
\begin{align}
	\min_{i=1,\ldots,n} \overline{c_j} = \min_{i=1,\ldots,n} 1 - y^T N
\end{align}
gdje su $N$ vektori (kolone) koji odgovaraju nebaznim varijablama. Ovaj problem je ekvivalentan rješavanju problema
\begin{align}
	\max_{j=1,\ldots,n} y^T A_j,
\end{align}
gdje su $A_j$ paterni, $j=1,\ldots, 6$. 
Ako je rješenje veće od 0, optimalno rješenje nađeno rješavanjem prethodnog RMP je optimalno i za početni problem. Inače, biramo varijablu (i odgovarajuću kolonu) sa minimalnim negativnim doprinosom koju potom ubacujemo u RMP. Kako je svaki patern dat u opštem slučaju kao $A_j = \begin{pmatrix}
	a_4 \\
	a_6 \\
	a_7
\end{pmatrix}$, CG potproblem se svodi na sljedeći optimizacioni problem:
\begin{align}
	 \max y_1 a_4 + y_2 a_6 + y_3 a_7  
\end{align}
uz zadovoljenje uslova o maksimalnoj širini
\begin{align}
   &	4 a_4 + 6 a_6 + 7 a_7 \leq 15 \\
   &	a_4, a_6, a_7 \geq 0, a_4, a_6, a_7 \in \mathbb{Z}.
\end{align}
kako smo to i ranije pomenuli, ovaj problem je klasični problem ruksaka koji se u praksi rješava veoma efikasno. Dakle, ako je rješenje problema ruksaka manje ili jednako od 1, trenutno najbolje rješenje je optimalno rješenje. U protivnom, optimalno rješenje $(a_4^*, a_6^*, a_7^*)^T$ ulazi kao nova kolona u RMP. Na osnovi prethodne simpleks tabele imamo: $y_1 = \frac{1}{3}, y_2 = y_3 = \frac{1}{2}$, pa treba da riješimo sljedeći CG problem:
\begin{align*}
      &\frac{1}{3} a_4 + \frac{1}{2} a_6 + \frac{1}{2} a_7 \\
      & 4 a_4 + 6 a_6 + 7 a_7 \leq 15 \\
      & 	a_4, a_6, a_7 \geq 0, a_4, a_6, a_7 \in \mathbb{Z}.
\end{align*}
Uz pomoć algoritma dinamičkog programiranja riješimo ovaj problem, pa dobijamo rješenje 
$(a_4^*, a_6^*, a_7^*)^T =  (2, 0, 1)^T=A_4$ optimalne vrijednosti $\frac{7}{6}$. Prekonvertujmo vektor $\begin{pmatrix}
	2\\
    0 \\
    1
\end{pmatrix}$
na bazu koja je generisana vektorima baze $x_1$, $x_2$ i $x_3$.  Iz toga slijedi da vektor 
$$ B^{-1}A_4 = \begin{pmatrix}
	  \frac{2}{3} \\
	  0           \\
	  \frac{1}{3}
\end{pmatrix}$$ ulazi u novu simpleks tabelu (uz redukovanu cijenu doprinosa od -(1- $\frac{7}{6}$)= $\frac{1}{6}$):

\begin{center}
	
	\begin{tabular}{ccccc|c}
		$x_1$ &     $\frac{1}{3}$  &   0 & 0  &      $ \frac{2}{3}$           & $\frac{80}{3}$ \\
		$x_2$ &     0              &  $\frac{1}{2}$  & 0     & 0                 &     $25$ \\
		$x_3$ &     0              &  0    &  $\frac{1}{2}$  & $ \frac{1}{3}$    & 50 \\ \hline
		$z$   &  $\frac{1}{3}$     &  $\frac{1}{2}$   &  $\frac{1}{2}$ &   $\frac{1}{6}$   & $\frac{305}{3}$ 
	\end{tabular}
\end{center}
U novododanoj koloni tražimo pivot element (kao i u simpleks metodi). Lako je vidjeti da je pivot element $\frac{2}{3}$, pa radeći elementarne transformacije po vrstama oko pivota, dobijamo simpleks tabelu:
\begin{center}
	\begin{tabular}{ccccc| c}
		  $x_4$ & $\frac{1}{2}$ & 0 & 0 & 1 & 40 \\
		  $x_2$ & 0 & $\frac{1}{2}$ & 0 & 0 & 25 \\
		  $x_3$ & -$\frac{1}{4}$ & 0 & $\frac{1}{2}$ & 0 & 30 \\ \hline
		  z  & $\frac{1}{4}$ & $\frac{1}{2}$ & $\frac{1}{2}$ & 0 & 95 
	\end{tabular}
\end{center}

Dalje, generišimo novi CG potproblem čitajući vrijednost dualnih promjenjivih iz prethodne simpleks tabele: $y_1 = \frac{1}{4}$, $y_2 = \frac{1}{2}$, $y_3= \frac{1}{2}$, a dobijamo novi potproblem:
\begin{align*}
	 \frac{1}{4} a_4 + \frac{1}{2} a_6 + \frac{1}{2} a_7
\end{align*}
uz uslove nenegativnosti i kapaciteta i integralnosti (cjelobrojnosti). Rješavajući problem uz pomoć dinamičkog problema, dobijamo optimalno rješenje $A_5 = (2,1,0)^T$, dok je vrijednost optimuma za CG potproblem jednak 1, odakle slijedi da je optimum početnog problema nađen sa prethodnim rješenjem (ne postoji više ulaznih kolona koje se dodaju u RMP), i ono je jednako 95, dok je rješenje dato sa $x_1^* = 0, x_2^* = 25, x_3^*=30, x_4^*= 40$. Dakle, koristimo samo 3 različita paterna za sječenje. 
\\ \vspace{1cm}
 %Za uraditi:  https://ocw.mit.edu/courses/sloan-school-of-management/15-083j-integer-programming-and-combinatorial-optimization-fall-2009/lecture-notes/ (Lekcija 19-25)
  
 \textbf{\large Zadaci}
 \begin{enumerate}
 	\item %http://web.tecnico.ulisboa.pt/mcasquilho/compute/_linpro/TaylorB_module_c.pdf
 	Pomoću metode grananja i ograničavanja (B\&B) riješiti sljedeći problem ILP-a:
 	\begin{align*}
 		&\max 100 x_1 + 150 x_2 \\
 		& s.t. \\
 		& 8000 x_1 + 4000 x_2 \leq 40 000 \\
 		& 15 x_1 + 30 x_2 \leq 200 \\
 		& x_1, x_2 \geq 0 \\
 		& x_1, x_2 \in \mathbb{Z}.
 	\end{align*}
   \item %http://web.tecnico.ulisboa.pt/mcasquilho/compute/_linpro/TaylorB_module_c.pdf
   	Pomoću metode grananja i ograničavanja  (B\&B) riješiti sljedeći problem ILP-a:
   \begin{align*}
   	    &\max 5 x_1 + 4 x_2 \\
   	    & s.t. \\
   	    & 3 x_1 + 4 x_2 \leq 10 \\
   	    & x_1, x_2 \geq 0 \\
   	    & x_1, x_2 \in \mathbb{Z}.
   \end{align*}
Nakon primjene B\&B metode, riješiti metod grafički dijeljeći region na podregione i uoprediti dobijena rješenja. 
\item 	Pomoću metode grananja i ograničavanja  (B\&B) riješiti sljedeći problem ILP-a:
\begin{align*}
	 &\max 5x_1 + 6 x_2 + 4 x_3 \\
	 &s.t. \\
	 & 5x_1 + 3 x_2 + 6 x_3 \leq 20 \\
	 & x_1 + 3x_2 \leq 12 \\
	 & x_1,x_2, x_3 \geq 0 \\
	 & x_2 \in \mathbb{Z}.
\end{align*}
\item %http://www.ens-lyon.fr/DI/wp-content/uploads/2012/01/LagrangianRelax.pdf
 Pomoću metode implicitne enumeracije riješiti sljedeći ILP:
\begin{align*}
  &\max 1000 x_1 + 700 x_2 + 800 x_3 \\
  &s.t. \\
  & 5000 x_1 + 6000 x_2 + 4000 x_3 \leq 10000 \\
  & x_1, x_2, x_3 \in \{0, 1\}.
\end{align*}
\item  Pomoću metode implicitne enumeracije riješiti sljedeći ILP:
\begin{align*}
	 &\max 20 x_1 + 30 x_2 + 10 x_3 + 40 x_4 \\
	 &s.t. \\
	 & 2x_1 + 4 x_2 + 3 x_3 + 7 x_4 \leq 10 \\
	 & 10 x_1 + 7 x_2 + 20 x_3 + 15 x_4 \leq 40 \\
	 & x_1 + 10 x_2 + x_3 \leq 10 \\
	 & x_1, x_2, x_3, x_4 \in \{0, 1\}.
\end{align*}
	\item Metodom gomorijevih odsjecajućih ravni, riješiti sljedeći ILP:% https://homepages.rpi.edu/~mitchj/handouts/gomorycuts/gomorycuts.html
	\begin{align*}
		 &\min -x_1 - x_2 \\
		 &s.t.\\
		 & 2 x_1 + 5x_2 \leq 20 \\
		 & 4 x_1 + 3 x_2 \leq 17 \\
		 & x_1, x_2 \geq 0 \\
		 & x_1, x_2 \in \mathbb{Z}.
	\end{align*}
\item Metodom gomorijevih odsjecajućih ravni, riješiti sljedeći ILP:% https://homepages.rpi.edu/~mitchj/handouts/gomorycuts/gomorycuts.html
\begin{align*}
	& \max x_1 + 4 x_2 \\
	& s.t. \\
	& 2 x_1 + 4 x_2 \leq 7 \\
	& 5 x_1 + 3 x_2 \leq 15 \\
	& x_1, x_2 \geq 0 \\
	& x_1, x_2 \in \mathbb{Z}.
	\end{align*}
\item    %http://sisdin.unipv.it/labsisdin/teaching/courses/ails/files/Cutting%20Plane%20Method.pdf
  Uz pomoć algoritma B\&C riješiti sljedeći problem ILP-a:
  \begin{align*}
  	 &\max x_1 + 2 x_2 \\
  	 &s.t. \\
  	 & -2x_1 + 2 x_2 \leq 5 \\
  	 & 6 x_1 + 4 x_2 \leq 25 \\
  	 & x_1, x_2 \geq 0 \\
  	 & x_1, x_2\in \mathbb{Z}.
  \end{align*}
\item  Za sljedeći problem 
\begin{align*}
	&\min c^T x \\
	&s.t. \\
	& Ax = b \\
	& D x \geq q \\
	& x \geq 0
\end{align*}
napisati odgovarajuću lagranžovu relaksaciju. 
\item %https://personal.eur.nl/birbil/bolbilim/teaa/02_Lag_Rel.pdf
Neka je dad problem ILP-a:
\begin{align*}
	&\max x_2 \\
	& -2x_1 + 2x_2 \leq 1 \\
	& 2 x_1 + 2 x_2 \leq 7 \\
	& x_1, x_2 \geq 0 \\
	& x_1, x_2 \in \mathbb{Z}.
\end{align*}
Definisati Lagranžovu relaksaciju za ovaj problem (npr. uzeti prvo ograničenje za ``teško''). Riješiti početni problem sa jednom od tehnika za rješavanje ILP-a. Potom, riješiti Lagranžovu relaksaciju problema za $\lambda=0.25$. Šta možemo zaključiti na osnovu rješenja Lagranžove relaksacije i pročetnog problema? 
\item   Pomoću Column generation frejmvorka, riješiti jedni instancu Cutting stock problema gdje je  
$W = 20$, te postoje tri narudžbe za sječenje: 1. stavka: $b_1=60$ rolni dužine 7; 2. stavka: $b_2=40$ rolni dužine 8; 3. stavka: $b_3=70$ rolni dužine 10. 

 \end{enumerate}
 
 \newpage
 
 \chapter{Dekompozicioni Metodi}
 
Dekompozicione metode u matematičkom programiranju su tehnike pomoću kojih se polazni problem (na primjer, problem linearnog programiranja) razbija u više manjih problema, te se, rješavanjem tih manjih problema, na kraju dolazi i do rješenja polaznog.

Široka primjena metoda linearnog, cjelobrojnog i mješovitog cjelobrojnog linearnog programiranja u modelovanju i rješavanju velikog broja različitih problema iz teorije i prakse, doveli su do porasta interesa i za primjenu i razvoj dekompozicionih metoda. Čak se i tradicionalne metode za rješavanje problema cjelobrojnog programiranja, kao što su B\&B, ili odsjecajuće ravni, takođe   mogu smatrati dekompozicionim metodama, jer one dijele polazni problem na LP relaksaciju i cjelobrojna ograničenja.

Treba napomenuti da i savremeni MILP rješavači, o čemu će biti govora kasnije, takođe u svojim implementacijama koriste i dekompozicione algoritme, koji, u nekim slučajevima, lakše i brže dovode do rješenja.
 
 
 \section{Benderova Dekompozicija}
 
 Benderova metoda je uvedena šezdesetih godina dvadesetog vijeka, kao algoritam za rješavanje MILP programa. 
 Osnovna ideja Benderove dekompozicije primijenjenog na MILP program je podjela skupa promjenljivih na dva podskupa, od kojih se jedan skup promjenljivih (skup cjelobrojnih promjenljivih) smatra ``komplikovanim'', odnosno skupom promjenljivih čijim se fiksiranjem dolazi do značajnog pojednostavljenja polaznog problema. Prvi problem (koji se zove i master problem) se rješava nad prvim skupom promjenljivih, dok se vrijednosti promjenljivih iz drugog skupa,  za dato rješenje prvog potproblema, određuju rješavanjem drugog potproblema. Uspješnu primjenu Benderove dekompozicije, između ostalog, obezbjeđuje i teorija dualnosti, odnosno teoreme slabe i jake dualnosti.
 

 Posmatrajmo sada sljedeću formulaciju MILP programa
 \begin{equation}
 \begin{aligned}\label{bender1}
 \min\  &f^Tx+g^Ty\\
 s.t.\  &Ax+By\geqslant c\\
 &x\geqslant 0,\ y \in \mathbb{Z}
 \end{aligned}
\end{equation}
 gdje su $x$ i $y$ vektori neprekidnih i cjelobrojnih promjenljivih, respektivno, dimenzija $p$ i $q$. $f,g,c$ su vektori, a $A$ i $B$ matrice odgovarajućih dimenzija. 
 
 Pretpostavimo da raspolažemo jednom početnom vrijednošću vektora $y$. Za tu vrijednost (označimo je sa $\overline{y}$) dobijamo sljedeći potproblem
  \begin{equation}
 	\begin{aligned}\label{bender2}
\min\ &  f^Tx+g^T\overline{y}\\
  s.t.\ & Ax\geqslant c-B\overline{y}\\
 &x\geqslant 0
  \end{aligned}
\end{equation}
 
Sada posmatrajmo dualni problem potproblema~\ref{bender2}, ignorišući term $g^T\overline{y}$ koji je konstantan.
  \begin{equation}
	\begin{aligned}\label{bender3}
	\max\ &u^T (c-B\overline{y})\\
	s.t.\ &u^TA\leqslant f\\
	&u\geqslant 0
  \end{aligned}
\end{equation}

Sada uključujemo teoriju dualnosti i razmatramo sljedeće mogućnosti, koje mogu da se jave.
\begin{itemize}
\item Ako je optimalno rješenje problema~(\ref{bender2}) $z^*$, a optimalno rješenje duala~(\ref{bender3}) $u^*$, na osnovu teoreme o jakoj LP dualnosti imamo
  \begin{equation}
	\begin{aligned}\label{bender4}
z^*-g^Ty=(u^*)^T(c-B\overline{y})
	\end{aligned}
\end{equation}


Dalje, uočiomo da oblast dopustivih rješenja dualnog problema~(\ref{bender3}) ne zavisi od vrijednosti $\overline{y}$. Stoga, $u^*$ je uvijek dopustivo rješenje problema~(\ref{bender3}), bez obzira na vrijednost $\overline{y}$. Odavde, na osnovu slabe LP dualnosti dobijamo

  \begin{equation}
\label{bender5}
		z\geqslant g^Ty+(u^*)^T(c-By)
\end{equation}


Posljednja nejednakost propisuje jednju donju granicu funkcije cilja polaznog problema. Ovo je ključni element koji se koristi u Benderovoj dekompoziciji, pomoću kog se određuje jedna odsjecajuća ravan za master problem (koji će biti definisan kasnije). Treba napomenuti da odsjecajuća ravan~(\ref{bender5}) ukazuje na činjenicu da, ako bi se za $y$ uzela vrijednost $y=\overline{y}$, funkcija cilja bi bila veća ili jednaka vrijednosti $\overline{z}$, koja se dobije u potproblemu, s obzirom da važi $	z\geqslant g^Ty+(u)^T(c-B\overline{y})$.

Ovo takođe daje i donju granicu za druge vrijednosti $y$ koje bismo mogli probati u narednim iteracijama.

\item Posmatrajmo sada slučaj da je dualni potproblem neograničen. U toj situaciji važi nejednakost


\begin{equation}
	\label{bender6}
	(u^*)^T(c-By)>0
\end{equation}

gdje je ${(u^*)}^T$ zrak mogućih rješenja duž kog funkcija neograničeno raste (ekstremni zrak).

U ovom slučaju, cilj je eliminisati ovaj zrak iz daljeg razmatranja (budućih rješenja). Da bismo to uradili, potrebno je osigurati da izraz $(u^*)^T(c-By)$ bude manji ili jednak od nule u svim narednim koracima. Tako, master problemu dodajemo novu odsjecajuću ravan, definisanu sa
\begin{equation}
	\label{bender7}
	(u^*)^T(c-By)\leqslant 0
\end{equation}

\end{itemize}
 
Sada možemo definisati master problem koji nastaje dodavanjem svih odsjecajućih ravni generisanih u prethodnim koracima.
  \begin{equation}
	\begin{aligned}\label{bender8}
		\min\ &z\\
		s.t.\ & g^Ty+(u^k)^T(c-By), \ k \in K\\
		& (u^k)^T(c-By), \ k \in L\\
		&y \in \mathbb{Z}
	\end{aligned}
\end{equation}
 
 gdje je $K$ skup ekstremnih tačaka, a $L$ skup ekstremnih zrakova od potproblema. Rješavanjem master problema (koji je obično puno lakši od početnog problema) dobijamo novu vrijednost za $y$, koju koristimo u sljedećoj iteraciji.
 
 Treba napomenuti da je potproblem~(\ref{bender2}) restrikcija originalnog problema~(\ref{bender1}), pa je njegova optimalna vrijednost $z^*$ jedna gornja granica za funkciju cilja polaznog problema. Takođe je master problem~(\ref{bender8}) relaksacija polaznog problema, jer se pri rješavanju master problema ne posmatraju sva ograničenja. Stoga je optimalna vrijednost master problema donja granica za funkciju cilja originalnog problema.
% DOPUNITI
 

 
 
 \begin{algorithm}[!ht] \label{alg:bender}
 	\begin{algorithmic}[1] 
 		\STATE Postavi $\overline{y}\in\mathbb{Z}$ na inicijalnu vrijednost
 		\STATE 	$LB \gets$ $-\infty$;$UB \gets$ $+\infty$
 		\WHILE{$UB-LB>\epsilon$}
 		\STATE Riješi dualni problem (Benderov potproblem)
 		
 		$$	\begin{aligned}
 			\max\ &u^T (c-B\overline{y})\\
 			s.t.\ &u^TA\leqslant f\\
 			&u\geqslant 0
 			\end{aligned}$$
 		
 		\IF{Potproblem nema dopustivo rješenje}
 		\STATE  KRAJ // nema  rješenja  
 		\ENDIF
 		\IF{Potproblem ima optimalno rješenje}
 		\STATE $UB \gets \min\{UB,g^Ty+(u^k)^T(c-By)\}$
 		\STATE Generiši Benderovu odsjecajuću ravan $z\geqslant g^Ty+(u^k)^T(c-By)$ i dodaj je u master problem
 		\ENDIF
		 \IF{Potproblem nije ograničen}
		\STATE Generiši Benderovu dopustivu ravan 	$(u^k)^T(c-By)\leqslant 0$ i dodaj je u master problem
		\ENDIF
		\STATE Riješi Benderov master problem
			$$\begin{aligned}
			\min\ &z\\
			s.t.\ & g^Ty+(u^k)^T(c-By), \ k \in K\\
			& (u^k)^T(c-By), \ k \in L\\
			&y \in \mathbb{Z}
		\end{aligned}$$
			i odredi novu vrijednost $\overline{y}$ i vrijednost rješenja $z^*$.
		\STATE $LB \gets$ $\max\{LB,z^*\}$
 		\ENDWHILE
 	\end{algorithmic}
 	\caption{Benderova dekompozicija}\label{alg:bender}
 \end{algorithm}



U primjeru kojim ilustrujemo upotrebu Benderove dekompozicije posmatramo jedan jednostavan problem maksimizacije dobiti na osnovu ulaganja po različitim kriterijumima.
Iako je Algoritmom~\ref{alg:bender} opisan postupak rješavanja problema minimizacije, algoritam se vrlo lako može preformulisati tako da se on može primijeniti i na problem maksimizacije. Jasno je da će u tom slučaju, dualni problem, prikazan u liniji 4 algoritma tada postati problem minimizacije, te će se, rješavanjem dualnog potproblema dobijati donje granice.


\emph{Primjer.} 

Pretpostavimo da raspolažemo sumom od 1000KM, koju možemo iskoristiti za ostvarivanje dobiti prema dva različita kriterijuma:
\begin{itemize}
	\item Oročenje novca sa fiksnom kamatom u iznosi od 4.5\%. Dodatno ograničenje je da se može oročiti samo cjelobrojan iznos novca.
	
	\item Ulaganje u neke od 10 vrsta dionica ($f_1, f_2, f_3,\ldots,f_{10}$), sa stopama rasta $1\%,2\%,\ldots,10\%$, respektivno. Za svaku vrstu dionica, može se investirati maksimalno 100KM.
\end{itemize}
Postavlja se pitanje kako treba uložiti početnu količinu novca, tako da se ostvari maksimalna dobit.

S obzirom na postavku zadatka, jasno je da bi optimalno rješenje trebalo da podrazumijeva da se u dionice $f_5,\ldots,f_{10}$ sa maksimalnim mogućim ulaganjem (po 100KM), dok se ostatak novca oročava sa kamatom od  4.5\%.

Sada ćemo problem formalno definisati i riješiti ga metodom Benderove dekompozicije.

Neka su promjenljive definisane sa:

$x_1,x_2,\ldots,x_{10}$: iznos uložen u dionice $f_1, f_2, f_3,\ldots,f_{10}$, respektivno

$y$: iznos koji je oročen sa fiksnom kamatom u iznosi od 4.5\%. Sada se problem može formlisati kao
\begin{equation}\label{primer:formulacija1}
	\begin{aligned}
		\max\ 1.01x_1+1.02x_2+\ldots+1.10x_{10}+1.045y\\
		s.t.\ x_1+x_2+\ldots+x_{10}+y\leqslant1000\\
		x_1\leqslant 100\\
		...\\
		x_{10}\leqslant 100\\
		y\in \mathbb{Z}\\
		x1,x_2,\ldots,x_{10},y\geqslant 0
	\end{aligned}
\end{equation}

Zapišimo sada model u obliku koji odgovara postavci metoda Benderove dekompozicije.
 \begin{equation}\label{primer:formulacija2}
	\begin{aligned}
		\max\  &f^Tx+g^Ty\\
		s.t.\  &Ax+By\leqslant c\\
		&x\geqslant 0,\ y \in \mathbb{Z}^+
	\end{aligned}
\end{equation}


$x=\left(\begin{array}{c}
	x_1 \\
	x_2 \\
	\vdots \\
	x_10
\end{array}\right)$,  
$f = \left(\begin{array}{c}
	1.01 \\
	1.02 \\
	\vdots \\
	1.10
\end{array}\right)$

Primijetimo da je su u našem primjeru $g$ i $y$ jednodimenzioni vektori, koje ćemo u daljem zapisu identifikovati sa njihovom (jedinom) koordinatom, odnosno
$y=(y)$ i $g=(1.045)$. Takođe je i 

$A=\left(
\begin{array}{ccc}
	1 & \ldots & 1 \\
	1 & \ldots & 0 \\
	\vdots & \ddots & \vdots \\
	0 & \ldots & 1
\end{array}\right)$
$B=\left(\begin{array}{c}
	1 \\
	0 \\
	\vdots \\
	0
\end{array}\right)$ 
$c=\left(\begin{array}{c}
	1000 \\
	100 \\
	\vdots \\
	100
\end{array}\right)$ 


Primijenimo sada Benderovu dokompoziciju. Najprije treba odrediti početnu vrijednost za $\overline{y}$, za koju, u ovom koraku, možemo uzeti bilo koju nenegativnu vrijednost. Neka je $\overline{y}=1500$. Dalje, neka su $LB=-\infty$ i $UB=+\infty$ i uzmimo da je $\epsilon = 0.1$.

 Nakon inicijalnih postavki, prvi korak je rješavanje dualnog problema (Benderovog potproblema). S obzirom da je početni problem problem maksimizacije, dualni problem će sada biti problem minimizacije. Obilježimo promjenljvie dualnog problema vektorom  $u$, koji ima 11 koordinata (polazni problem ima 11 oraničenja).
 
 Računamo funkciju cilja dualnog problema:
 $$
u^T (c-B\overline{y})=(u_1\ldots u_{11})\cdot \left(\left(\begin{array}{c}
	1000 \\
	100 \\
	\vdots \\
	100
\end{array}\right)-\left(\begin{array}{c}
1500 \\
0 \\
\vdots \\
0
\end{array}\right)\right) = -500u_1+100u_2+\ldots+100u_{11}
$$
dok su ograničenja dualnog problema

$$
\begin{aligned}
	u_1+u_2&\geqslant 1.01\\
	u_1+u_3&\geqslant 1.02\\
	\vdots&\\
	u_1+u_{11}&\geqslant 1.1\\
	u_1&\geqslant 1.045\\ 
	u&\geqslant 0\\
\end{aligned}
$$

Lako se vidi da rješenje dualnog problema nije ograničeno (sa donje strane), za $u_1 = +\infty$, $u_2 = u_3=\ldots u_{11}=0$.
Odnosno, 
$$u=\left(\begin{array}{c}
 1 \\
	0 \\
	\vdots \\
	0
\end{array}\right)$$ je ekstremni zrak.

Prateći tok algoritma, određujemo odsjecajuću ravan

$$u^{T}(c-By)\geqslant 0$$
odnosno
$$1000-y\geqslant 0$$
Sada rješavamo master problem

$$
\begin{aligned}
	\max z\\
	1000-y\geqslant 0\\
	y\in\mathbb{Z}^+\\	
	\end{aligned}
$$

Vidimo da, bez obzira na vrijednost $y$, vrijednost funkcije cilja nije ograničena.
Drugim riječima, ako uzmemo bilo koju dopustivu vrijednost za $y$ (recimo $\overline{y}=1000$) dobijamo da je $\overline{z} = +\infty$. Sada možemo zaključiti da u prvoj iteraciji algoritma nismo uspjeli da smanjimo gornju granicu, te nam ostaje $UB = +\infty$.

 Prelazimo na sljedeću iteraciju. Formulišimo novi dualni problem.
 
  Računamo novu funkciju cilja dualnog problema sa vrijednošću $\overline{y}=1000$:
 $$
 u^T (c-B\overline{y})=(u_1\ldots u_{11})\cdot \left(\left(\begin{array}{c}
 	1000 \\
 	100 \\
 	\vdots \\
 	100
 \end{array}\right)-\left(\begin{array}{c}
 	1000 \\
 	0 \\
 	\vdots \\
 	0
 \end{array}\right)\right) = 100u_2+\ldots+100u_{11}
 $$
 Imajući u vidu ograničenja dualnog problema, zaključujemo da za vrijednost vektora $$u=\left(\begin{array}{c}
 	1.1 \\
 	0 \\
 	\vdots \\
 	0
 \end{array}\right)$$
funkcija cilja ima minimalnu vrijednost jednaku 0.

Sada ćemo moći da popravimo donju granicu, odnosno

$$LB = \max\{LB,g^Ty+(u)^T(c-By)\}=\max\{-\infty,1.045*1000+0\} = 1.045$$.

Dalje, dodajemo odsjecajuću ravan kao ograničenje master problema:
$$z\leqslant g^Ty+(u)^T(c-By)$$ 
odnosno
$$z\leqslant 1.045y+\left(\begin{array}{c}
	1.1 \\
	0 \\
	\vdots \\
	0
\end{array}\right)^T
\left(\left(\begin{array}{c}
	1000 \\
	100 \\
	\vdots \\
	100
\end{array}\right)-\left(\begin{array}{c}
1 \\
0 \\
\vdots \\
0
\end{array}\right)y\right)$$
$$z\leqslant 1.045y+\left(\begin{array}{c}
	1.1 \\
	0 \\
	\vdots \\
	0
\end{array}\right)^T
\left(\begin{array}{c}
	1000-y \\
	100 \\
	\vdots \\
	100
\end{array}\right)$$
Odnosno

$$z\leqslant 1100-0.055y$$

Sada novodobijenu odsjecajuću ravan pridodajemo ograničenjima master problema i rješavamo master problem

$$
\begin{aligned}
	\max z\\
	1000-y\geqslant 0\\
	z\leqslant 1100-0.055y\\ 
	y\in\mathbb{Z}^+\\	
\end{aligned}
$$

Nije teško odrediti da je optimalna vrijednost funkcije cilja master problema $\overline{z}=1100$, koja se dobija za vrijednost $\overline{y}=0$.
Sada možemo da ažuriramo gornju granicu koristeći vrijednost funkcije cilja, odnosno

$$UB = \min\{UB,\overline{z}\} = 1100$$

Pošto je razlika između gornje i donje granice još uvijek veća od $\epsilon$ ($UB-LB = 1100-1045=55$), prelazimo na sljedeću iteraciju.

Uzimamo $\overline{y}=0$ i ponovo rješavamo dualni problem.

Funkcija cilja dualnog problema sada izgleda 

 $$
u^T (c-B\overline{y})=(u_1\ldots u_{11})\cdot \left(\left(\begin{array}{c}
	1000 \\
	100 \\
	\vdots \\
	100
\end{array}\right)-\left(\begin{array}{c}
	0 \\
	0 \\
	\vdots \\
	0
\end{array}\right)\right) =1000u_1+ 100u_2+\ldots+100u_{11}
$$

koja, s obzirom na ograničenja u dualnom problemu, ima minimalnu vrijednost 1055 za vektor $$u=\left(\begin{array}{c}
	0\\
	1.01 \\
	1.02 \\
	\vdots \\
	1.1
\end{array}\right)$$

Pošto dual ima optimalno rješenje, računamo novu donju granicu, odnosno,


$$LB = \max\{LB,g^Ty+(u)^T(c-By)\}=\max\{1.045,0+ 1055\} = 1055$$.

Dobijamo novu odsjecajuću ravan koju ćemo pridodati za rješavanje master problema

$$z\leqslant 1.045y+\left(\begin{array}{c}
	0\\
	1.01 \\
	\vdots \\
	1.1
\end{array}\right)^T
\left(\left(\begin{array}{c}
	1000 \\
	100 \\
	\vdots \\
	100
\end{array}\right)-\left(\begin{array}{c}
	1 \\
	0 \\
	\vdots \\
	0
\end{array}\right)y\right)$$
Odnosno 
$$z\leqslant 1.045y+1055$$

Sada novi master problem izgleda 


$$
\begin{aligned}
	\max z\\
	1000-y\geqslant 0\\
	z\leqslant 1100-0.055y\\ 
	z\leqslant 1.045y+1055\\
	y\in\mathbb{Z}^+\\	
\end{aligned}
$$


Rješavanjem ovog problema cjelobrojnog programiranja (na primjer, pomooću nekog od računarskih programa) dobija se optimalno rješenje za cjelobrojnu vrijednost $\overline{y}=41$, koje iznosi $\overline{z} = 1097.745$

Sada možemo da ažuriramo i gornju granicu, odnosno 

$$UB = \min\{1100,\overline{z}\} =  \min\{1100,1097.745\} =1097.745$$

Računamo razliku između gornje i donje granice

$$UB-LB=1097.745-1055 = 42.745$$
i pošto je razlika još uvijek veća od $\epsilon$, nastavljamo dalje sa iterativnim postupkom.

Uzmimo $\overline{y}=41$ i ponovo formirajmo i riješimo dualni problem. 
Funkcija cilja dualnog problema sada izgleda 
$$\min 959u_1+ 100u_2+\ldots+100u_{11},$$

a rješavanjem problema uz data ograničenja dobijamo optimalno rješenje 1013.59, za vrijednosti vektora 
$$u=\left(\begin{array}{c}
	1.01 \\
	0 \\
	0.01\\
	0.02\\
	\vdots \\
	0.09
\end{array}\right)$$

Ažuriranjem donje granice dobija se 
$$LB = \max\{1055,1.045*41+1013.59\} = \max\{1055,1056.435\} = 1056.435 $$

Dalje, dodajemo novu odsjecajuću ravan

$$z\leqslant 1.045y+\left(\begin{array}{c}
	1.01 \\
	0 \\
	0.01\\
	0.02
	\vdots \\
	0.09
\end{array}\right)^T
\left(\left(\begin{array}{c}
	1000 \\
	100 \\
	\vdots \\
	100
\end{array}\right)-\left(\begin{array}{c}
	1 \\
	0 \\
	\vdots \\
	0
\end{array}\right)y\right)$$
Odnosno 
$$z\leqslant 1.045y+1010-1.01y+100\cdot0.45$$
t.j.
$$z\leqslant 0.035y+1055$$

Ovo ograničenje pridodajemo master problemu, koji sada izgleda


$$
\begin{aligned}
	\max z\\
	1000-y\geqslant 0\\
	z\leqslant 1100-0.055y\\ 
	z\leqslant 1.045y+1055\\
	z\leqslant 0.035y+1055\\
	y\in\mathbb{Z}^+\\	
\end{aligned}
$$

Rješavanjem ovog master problema dobijamo optimalno rješenje 
 za cjelobrojnu vrijednost $\overline{y}=500$, koje iznosi $\overline{z} = 1072.5$.
 
 Ažuriramo i gornju granicu

$$UB = \min\{1097.745, 1072.5\} =  1072.5$$

Računamo razliku između gornje i donje granice $1072.5-1056.435$, što je još uvijek veće od $\epsilon$, pa prelazimo na narednu iteraciju.

Uzimamo 
$\overline{y}=500$ i formiramo novi dualni problem sa funkcijom cilja

$$\min 500u_1+ 100u_2+\ldots+100u_{11},$$

čija optimalna vrijednost iznosi 540, za vrijednost vektora $u$

$$u=\left(\begin{array}{c}
	1.05\\
	0\\
	0\\
	0\\
	0\\
	0\\
	0.01 \\
	0.02 \\
	\vdots \\
	0.05
\end{array}\right)$$

Ažuriramo donju granicu,
$$LB = \max\{1056.435, 1.045\cdot 500+540\} =1062.5 $$




Dalje, master problemu pridružujemo odsjecajuću ravan
 
 
 $$z\leqslant 1.045y+\left(\begin{array}{c}
 	1.05\\
 0\\
 0\\
 0\\
 0\\
 0\\
 0.01 \\
 0.02 \\
 \vdots \\
 0.05
 \end{array}\right)^T
 \left(\left(\begin{array}{c}
 	1000 \\
 	100 \\
 	\vdots \\
 	100
 \end{array}\right)-\left(\begin{array}{c}
 	1 \\
 	0 \\
 	\vdots \\
 	0
 \end{array}\right)y\right)$$
 Odnosno 
 $$z\leqslant 1.045y+1050-1.05y+100\cdot0.15$$
 t.j.
 $$z\leqslant -0.005y+1065$$
 
 
 Kada i ovo ograničenje pridodamo master problemu, dobijamo novi master problem
 
 $$
 \begin{aligned}
 	\max z\\
 	1000-y\geqslant 0\\
 	z\leqslant 1100-0.055y\\ 
 	z\leqslant 1.045y+1055\\
 	z\leqslant 0.035y+1055\\
 	z\leqslant -0.005y+1065\\
 	y\in\mathbb{Z}^+\\	
 \end{aligned}
 $$
 čije se optimalno rješenje dobija za vrijednost za cjelobrojnu vrijednost $\overline{y}=250$, koje iznosi $\overline{z} = 1063.75$.
 
 Ažuriranjem gornje granice dobijamo 
 $$UB = 1063.75$$, pa je razlika između gornje i donje granice jednaka
 $1063.75-1062.5=1.25$, što je još uvijek veće od $\epsilon$.
 
Ponovo formiramo dualni problem uzimajući $\overline{y}=250$.
 
 Nova funkcija cilja sada izgleda
 $$\min 750u_1+ 100u_2+\ldots+100u_{11},$$
 
 a optimalna vrijednost funkcije cilja je 800.5 za vrijednost vektora $u$
 
 
 $$u=\left(\begin{array}{c}
 	1.03\\
 		0\\
 		0\\
 		0\\
 0.01\\
 0.02\\
 0.03\\
 0.04\\
 0.05\\
 	1.06\\
 	1.07 \\
 \end{array}\right)$$
 
 Ispitujemo da li se ažurira donja granica:
 $$LB = \max\{1062.5, 1.045\cdot 250+ 800.5\} = \max\{1062.5,1061.75\}=1062.5$$
 
 Dalje, određujemo odsjecajuću ravan
 
 
 $$z\leqslant 1.045y+\left(\begin{array}{c}
 	1.03 \\
 	0 \\
 	0\\
 	0\\
 	0.01\\
 	0.02\\
 	0.03\\
 	0.04\\
 	0.05\\
 	0.06\\
 	0.07
 \end{array}\right)^T
 \left(\left(\begin{array}{c}
 	1000 \\
 	100 \\
 	\vdots \\
 	100
 \end{array}\right)-\left(\begin{array}{c}
 	1 \\
 	0 \\
 	\vdots \\
 	0
 \end{array}\right)y\right)$$
 Odnosno 
 $$z\leqslant 1.045y+1030-1.03y+28$$
 t.j.
 $$z\leqslant 0.015y+1058$$
 
 i pridodajemo je master problemu, koji izgleda
  $$
 \begin{aligned}
 	\max z\\
 	1000-y\geqslant 0\\
 	z\leqslant 1100-0.055y\\ 
 	z\leqslant 1.045y+1055\\
 	z\leqslant 0.035y+1055\\
 	z\leqslant -0.005y+1065\\
 	z\leqslant 0.015y+1058\\
 	y\in\mathbb{Z}^+\\	
 \end{aligned}
 $$
 
 Rješavanjem master problema dobijamo novu vrijednost $\overline{y} =350$, a gornja granica se ažurira na 
 $$UB = 1063.25$$
 
 Ponavljajući postupak još jednom, dobijamo redom: 
 \begin{itemize}
 	\item 
 vrijednost funkcije duala 697,
 \item vektor
 
  $$u=\left(\begin{array}{c}
 	1.04\\
 	0\\
 	0\\
 	0\\
 	0\\
 	0.01\\
 	0.02\\
 	0.03\\
 	0.04\\
 	0.05\\
 	1.06\\
 \end{array}\right)$$
\item $LB = 1062.75$
\item odsjecajuću ravan:  $z\leqslant 0.005y+1061$
\end{itemize}


Rješavajući još jednom master problem, koji sada izgleda

  $$
\begin{aligned}
	\max z\\
	1000-y\geqslant 0\\
	z\leqslant 1100-0.055y\\ 
	z\leqslant 1.045y+1055\\
	z\leqslant 0.035y+1055\\
	z\leqslant -0.005y+1065\\
	z\leqslant 0.015y+1058\\
	z\leqslant 0.005y+1061\\
	y\in\mathbb{Z}^+\\	
\end{aligned}
$$
dobijamo da je nova vrijednost $\overline{y}=400$, a gornja granica $UB = 1063$.

Formirajući i rješavajući (pokazaće se, po posljednji put), dualni problem, dobija se optimalno rješenje 645, pa donja granica iznosi 1063.

Sada vidimo da smo dobili da je donja granica jednaka gornjoj i možemo obustaviti iterativni postupak.

Sada znamo da se optimalno rješenje polaznog problema~\ref{primer:formulacija2}, odnosno~\ref{primer:formulacija1} dobija za vrijednost $\overline{y}=400$, te se on svodi na problem

 \begin{equation}\label{primer:formulacija3}
	\begin{aligned}
		\max\  &f^Tx\\
		s.t.\  &Ax\leqslant c-B\overline{y}\\
		&x\geqslant 0
	\end{aligned}
\end{equation}
čije je rješenje predstavljeno vektorom

$$x =\left(\begin{array}{c}
	0\\
	0\\
	0\\
	0\\
	0\\
	100\\
	100\\
	100\\
	100\\
	100\\
	100\\
\end{array}\right)$$



  \section{Dantzig-Wolfe Dekompozicija}%https://www.maxwell.vrac.puc-rio.br/29077/29077_5.PDF
 %https://www.youtube.com/watch?v=wxz0NJvKZNM
 %Glavni link: https://www.youtube.com/watch?v=IposxYVBUnY
 
 U ovom odjeljku ćemo objasniti još jednu korisnu tehniku za rješavanje problema linearnog programiranja - Dantzig-Wolfe (DW) dekompoziciju. Ova tehnika je originalno dizajnirana za rješavanje problema linearnog programiranja velikih dimenzija. Osnovna ideja DW dekompozicije je da se na podskup ograničenja polaznog problema primijeni Teorema Minkovskog, odnosno Teorema o reprezentaciji za konveksne poliedre, te da se polazni problem razbije na rješavanje više manjih problema.
 
 \begin{thm}
 	Neka je $P = \{ x \in \mathbb{R}^n \mid Ax \leq b\}$ ograničeni poliedar i neka je $\{x^{(1)}, \ldots, x^{(p)} \}$ skup ekstremnih tačaka od $P$. Tada za sve $x \in P$ vrijedi 
 	 $$ x = \sum_{i=1}^p \lambda_i x^{(i)},$$ 
 	 gdje je $\lambda_i \geq 0,i=1,\ldots,p$, $\sum_{i=1}^p \lambda_i=1$.
 \end{thm}
 
 Pođimo od kanonske formulacije problema linearnog programiranja
 
  \begin{equation}
 	\begin{aligned}\label{dw1}
 		\min\  &c^Tx\\
 		s.t.\  &Ax=b\\
 		&x \in X
 	\end{aligned}
 \end{equation}
 
 gdje je skup $X$ poliedar. Iako za DW dekompoziciju nije neophodno, u daljem razmatranju, radi lakše analize DW dekompozicije, smatraćemo da je $X$ ograničen poliedar, odnosno politop.
 
 Dalje, navešćemo i sljedeću pretpostavku: Ako bismo iz skupa ograničenja izbacili ograničenja $Ax=b$, tada bi rješavanje problema bilo jednostavno. Drugim riječima, skup $X$ je opisan nekim ``jednostavnim'' ograničenjima, dok ograničenja $Ax=b$ čine problem značajno težim, koje ćemo zbog toga i zvati ``komplikovanim ograničenjima''. 
 
 Posmatrajmo sada konfiguraciju za primjenu Teoreme o reprezentaciji na skup $X$.
 
 Neka su tačke $x^{(1)},x^{(2)},\dots,x^{(t)}$ vrhovi politopa $X$.  
 Prema Teoremi o reprezentaciji, za svaku tačku $x\in X$ važi da se ona može predstaviti kao konveksna kombinacija tačaka $x^{(1)},x^{(2)},\dots,x^{(t)}$.
 
 Neka je  $x \in X$ proizvoljna tačka iz skupa $X$.  Tada postoje $\lambda_1,\lambda_2,\ldots,\lambda_t$, takvi da važi:
 
 \begin{equation}
 	\begin{aligned}
 		&x = \sum_{j=1}^t\lambda_jx^{(j)}\\
 		 &\sum_{j=1}^t\lambda_j = 1\\
 		&\lambda_j\geqslant 0,\ j = 1,\ldots,t
 	\end{aligned}
 \end{equation}
 
 Ponovimo da Teorema o reprezentaciji ima svoju formulaciju i u slučaju da poliedar nije ograničen, ali zbog pojednostavljenja daljeg objašnjenja DW dekompozicije, ovaj slučaj nećemo razmatrati.
 
 Uzimajući u obzir prikazanu reprezentaciju proizvoljne tačke $x\in X$, početni problem~(\ref{dw1}) sada možemo preformulisati 
 
 
   \begin{equation}
 	\begin{aligned}\label{dw2}
 		\min\  &c^T\cdot \sum_{j=1}^t\lambda_jx^{(j)}\\
 		s.t.\  &A\cdot \sum_{j=1}^t\lambda_jx^{(j)}=b\\
 		 		 &\sum_{j=1}^t\lambda_j = 1\\
 		&\lambda_j\geqslant 0,\ j = 1,\ldots,t
 	\end{aligned}
 \end{equation}
odnosno
    \begin{equation}
 	\begin{aligned}\label{dw3}
 		\min\  & \sum_{j=1}^t(c^T x^{(j)})\lambda_j\\
 		s.t.\  &\sum_{j=1}^t (A x^{(j)})\lambda_j=b\\
 		&\sum_{j=1}^t\lambda_j = 1\\
 		&\lambda_j\geqslant 0,\ j = 1,\ldots,t
 	\end{aligned}
 \end{equation}
 
 Sada se vidi da je početni problem~(\ref{dw1}) sada predstavljen ekvivalentnom reprezentacijom~(\ref{dw3}), u kojem se, umjesto polaznih promjenljivih (vektora $x$), sada posmatraju promjenljive $\lambda_j,\ j = 1,\ldots,t$ (skup ovih promjenljivih ćemo zvati $\lambda$ promjenljive), uz pretpostavku da su  vrhovi $x^{(1)},x^{(2)},\dots,x^{(t)}$ konveksnog politopa $X$ poznati. Variranjem vrijednosti $\lambda$ promjenljivih po dopustivom skupu iz formulacije~\ref{dw3}, generišu se tačke iz dopustivog skupa polazne formulacije~(\ref{dw1}). Sa druge strane, svaka tačka $x$ iz formulacije~(\ref{dw1}) ima svoju reprezentaciju preko odgovarajućih vrijednosti  $\lambda$ promjenljivih u dopustivom skupu formulacije~(\ref{dw3}). S obzirom na to da i funkcije cilja odgovaraju jedna drugoj, zaključujemo da je i optimalno rješenje polaznog problema~(\ref{dw1}) jednako optimalnom rješenju reformulisanog problema~(\ref{dw3}).
 
 Samom reformulacijom polaznog problema~(\ref{dw1}) u DW formulaciju~(\ref{dw3}) nismo postigli mnogo, jer broj vrhova politopa, a time i broj $\lambda$ promjenljivih može biti jako veliki.
 
 Međutim, pravi razlog za DW dekompoziciju leži u činjenici da za rješavanje problema~(\ref{dw3}) ne moramo eksplicitno da koristimo sve vrhove politopa $X$. Umjesto toga, krenućemo od jednog   manjeg podskupa (a samim tim i podskupom skupa $\lambda$ promjenljivih). Nakon toga, primijenićemo tehniku ``generisanja kolona'' (engl. \emph{column generation}), kako bismo u razmatranje uključili nove vrhove politopa $X$, koje će pomoći poboljšanju rješenja tzv. \emph{Restricted master problema}.
 
 Označimo sada problem formulisan  sa~(\ref{dw3}) kao \emph{Master problem} (MP). Na osnovu master problema formiramo tzv. Restricted master problem (RMP)  sa manjim brojem $\lambda$ promjenljivih.
 
     \begin{equation}
 	\begin{aligned}\label{dw4}
 		\min\  & \sum_{j\in I}(c^T x_j)\lambda_j\\
 		s.t.\  &\sum_{j\in I} (A x_j)\lambda_j=b\\
 		&\sum_{j\in I}\lambda_j = 1\\
 		&\lambda_j\geqslant 0,\ j  \in I
 	\end{aligned}
 \end{equation}
gdje je $I$ skup indeksa onih vrhova politopa koji su uključeni u RMP.

Označimo sa $\overline{z}$ optimalnu vrijednost funkcije cilja RMP, a sa $z^*$ optimalnu vrijednost master problema.

Primijetimo da je $\overline{z}$ jedna gornja granica za master problem, jer je svako dopustivo rješenje RMP takođe i dopustivo za master problem. Ova konstatacija će nam biti od koristi u razmatranju koje slijedi.

Da bismo provjerili da li je optimalno rješenje RMP ujedno i optimalno rješenje master problema, potrebno je da provjerimo da li su koeficijenti doprinosa svih nebaznih promjenjivih nenegativni, tj. postoji li neka nebazna varijabla koja može doprinijeti dodatnom smanjenju funkcije cilja. Kao što znamo iz simpleks tablele i ranije sekcije o dualnosti linearnog programiranja, ove vrijednosti su ekvivalentne optimalnim vrijednostima dualnih promjenjivih (duala problema RMP).   
%je reduced cost od svih nebazičnih promjenljivih NIJE JASNO...


%i trebamo optimalne vrijednosti dualnih promjenljivih

Označimo vektorom $y$ optimalne vrijednosti dualnih promjenljih koje se odnose na ograničenja $\sum_{j\in I} (A x^{(j)})\lambda_j=b$ i skalarom $\alpha$ optimalnu vrijednost dualne promjenljive koja se odnosi na ograničenje $\sum_{j\in I}\lambda_j = 1$. 

Da bi se odredili   koeficijenti doprinosa za $\lambda_j$, odredimo šta imamo u odgovarajućoj koloni: U funkciji cilja, imamo $c^Tx^{(j)}$, u ograničenjima $A x^{(j)} $ i još jednu jedinicu (na osnovu ograničenja $\sum_{j\in I}\lambda_j = 1$). Tako, kolona na koju se fokusiramo da bismo izračunali doprinose izgleda ovako


 $$\left(\begin{array}{c}
 	c^T x^{(j)}\\
 	A x^{(j)} \\
 	1 
 \end{array}\right)$$
 
 i sada rješavamo \emph{Column generation potproblem}, čiji je cilj da se pronađe najmanji koeficijent doprinosa. Ukoliko je on manji od nule, dobija se nova kolona koja treba da se doda u potproblem RMP.  U slučaju da je on nenegativan, tada je optimalno rješenje RMP ujedmo i optimalno rješenje MP.
 
 Column generation potproblem se definiše kao
 
      \begin{equation}
 	\begin{aligned}\label{dw6}
 		\min_{j=1,\ldots,t}\  & \{c^T x^{(j)} -y^T	Ax_j-\alpha\cdot 1\}=\min_{x\in X}\  & \{c^Tx-y^T	Ax-\alpha\}\\
 	\end{aligned}
 \end{equation}
 
jer je rješenje problema na desnoj strani jednakosti upravo u nekom od vrhova politopa $X$.

Prisjetimo se sada da smo za jednu od polaznih pretpostavki imali da je skup $X$ opisan kao skup sa ``jednostavnim'' ograničenjima, što znači da je problem na desnoj strani jednakosti (\ref{dw6}) jednostavan za rješavanje.

Reformulišimo  Column generation potproblem sada kao problem maksimizacije, gdje ćemo za funkciju cilja uzeti negativnu vrijednost funkcije cilja minimizacije, tj.
 
 
       \begin{equation}
 	\begin{aligned}\label{dw7}
 		\max_{j=1,\ldots,t}\  &  \{y^T	Ax-c^Tx+\alpha\}\\
 	\end{aligned}
 \end{equation}
Neka je $\hat{z}$ optimalna vrijednost funkcije cilja ovog problema maksimizacije.

Posmatrajmo sada jedno dopustivo rješenje $x$ polaznog problema. Za to rješenje važi 
$x\in X$ i $Ax=b$, pa imamo da vrijedi %Za to rješenje $x$ važi 	
 
 $$y^T	Ax-c^Tx+\alpha\leqslant \hat{z} \Leftrightarrow c^Tx\geqslant y^T	Ax+\alpha-\hat{z} \Leftrightarrow  y^T b+\alpha-\hat{z}$$
 
 Primijetimo sada da je  $y^T b+\alpha$ zapravo  optimalna vrijednost funkcije duala od RMP, koja je dalje, jednaka optimalnoj vrijednosti $\overline{z}$ RMP-a. 
 
 $$ c^Tx\geqslant \overline{z}-\hat{z}$$
 
 Sada zaključujemo da je razlika između optimalne vrijednosti RMP-a i problema maksimizacije Column generation problema donja granica za originalni LP. Pošto ovo važi za proizvoljno rješenje $x$, zaključujemo da važi 
 $$z^*\geqslant \overline{z}-\hat{z}$$
 odnosno, razlika $\overline{z}-\hat{z}$ je donja granica za optimalnu vrijednost funkcije cilja polaznog problema.
 
 Dalje, prisjetimo se da je $\overline{z}$ gornja granica za $z^*$, odnosno važi 
\begin{equation}\label{dw8}
	  \overline{z}\geqslant z^*\geqslant \overline{z}-\hat{z}
\end{equation}
 
 Izraz~(\ref{dw8}) se može koristiti za određivanje koliko daleko se optimalno rješenje polaznog problema razlikuje od rješenja koja se dobijaju u iterativnom procesu DW dekompozicije.
 
 U slučaju kada je $\hat{z}$ jednako nuli, iz~(\ref{dw8}) se vidi da je vrijednost $\overline{z}$ zapravo i optimalno rješenje polaznog problema.
 
 \emph{Primjer.}%http://eaton.math.rpi.edu/faculty/Mitchell/courses/matp6640/notes/09C_egdcmpbeamer.pdf
 
 Posmatrajmo problem linearnog programiranja
 
   \begin{equation}
 	\begin{aligned}\label{primjer:dw1}
 		\max\  &x_1\\
 		s.t.\  &x_1+3x_2\leqslant \frac94\\
 		 &2x_1-3x_2\leqslant 0\\
 		&x \in X=\{(x_{1,2}):0\leqslant x_{1, 2}  \leqslant 1\}.
 	\end{aligned}
 \end{equation}
 
 Vidimo da u ovom problemu imamo dva ``komplikovana'' ograničenja ($x_1+3x_2\leqslant \frac94$ i
 $2x_1-3x_2\leqslant 0$). Dalje, vidimo da je skup $X$ definisan kao jedinični kvadrat, što u našem slučaju to znači da je riječ o ``jednostavnom'' ograničenju. 
 
 \begin{figure}\label{fig:dw1}
 	
 	\includegraphics[scale=4]{dw2.png}
 	\caption{Grafička interpretacija problema. Optimalno rješenje je označeno sa $x^*$. }
 	\label{fig:dw1}
 \end{figure}
 
 Prije nego što na ovom problemu ilustrujemo upotrebu DW dekompozicije, riješimo problem na neki od (u ovom slučaju) bržih načina. Ako problem predstavimo grafički (Slika~\ref{fig:dw1}), vidimo da je dopustivi skup osjenčeni trougao, a da se maksimalna vrijednost funkcije cilja dostiže u vrhu $(\frac34, 
 \frac12)$ tog trougla, odnosno,

    \begin{equation}
 z^* = \frac 34\qquad \textnormal{za}\ x^*=\left(\begin{array}{c}
 	\frac34\\
 	\frac12.
 \end{array}\right)
 \end{equation}
 
 Formirajmo sada polaznu konfiguraciju za primjenu DW dekompozicije.
 
 Skup $X$ je politop koji ima četiri tjemena:
 
 $$   
 x^{(1)}=\left(\begin{array}{c}
 		0\\
 		0
 	\end{array}\right),\  x^{(2)}=\left(\begin{array}{c}
 	1\\
 	0
 \end{array}\right),\  x^{(3)}=\left(\begin{array}{c}
 0\\
 1
\end{array}\right) \textnormal{i}\ x^{(4)}=\left(\begin{array}{c}
1\\
1
\end{array}\right)
$$
 
 Zapišimo i polazni problem u kompaktnijem obliku, odnosno
 
 $$
 A = \left(\begin{array}{cc}
 	1 & 3 \\
 	2 & -3
 \end{array}\right) \ b=\left(\begin{array}{c}
 \frac 9 4\\
 0
\end{array}\right)\ c=\left(\begin{array}{c}
1\\
0
\end{array}\right),
 $$
 
 pa polazni problem možemo napisati kao
    \begin{equation}
 	\begin{aligned}\label{primjer:dw2}
 		\max\  &c^Tx\\
 		s.t.\  &Ax\leqslant b\\
 		&x \in X
 	\end{aligned}
 \end{equation}
Na osnovu teoreme o reprezentaciji, svako rješenje $x \in X$ možemo zapisati kao

$$\begin{aligned}
&x = \sum_{j=1}^4\lambda_j x^{(j)}\\
&\sum_{j=1}^4\lambda_j=1\\
&\lambda_1,\lambda_2,\lambda_3,\lambda_4\geqslant 0
\end{aligned}$$
 Preformulacijom problema~(\ref{primjer:dw2}) dobijamo
 
     \begin{equation}
 	\begin{aligned}\label{primjer:dw3}
 		\max\  & \sum_{j=1}^4(c^T  x^{(j)})\lambda_j\\
 		s.t.\  &\sum_{j=1}^4 (A  x^{(j)})\lambda_j\leqslant b\\
 		&\sum_{j=1}^4\lambda_j = 1\\
 		&\lambda_j\geqslant 0,\ j = 1,\ldots,4
 	\end{aligned}
 \end{equation}
 Odnosno, nakon sređivanja 
      \begin{equation}
 	\begin{aligned}\label{primjer:dw4}
 		\max  & \lambda_2+\lambda_4\\
 		s.t.\  &\left(\begin{array}{c}
 			1\\
 			2
 		\end{array}\right)\lambda_2+\left(\begin{array}{c}
 		3\\
 		-3
 	\end{array}\right)\lambda_3+\left(\begin{array}{c}
 	4\\
 	-1
 \end{array}\right)\lambda_4\leqslant \left(\begin{array}{c}
 			\frac 9 4\\
 			0
 		\end{array}\right)\\
 		&\sum_{j=1}^4\lambda_j = 1\\
 		&\lambda_j\geqslant 0,\ j = 1,\ldots,4
 	\end{aligned}
 \end{equation}

Da bismo u ograničenjima izbjegli znak $\leqslant$ u prva dva ograničenja, dodajmo modelu dvije izjednačavajuće promjenljive $s_1$ i $s_2$, te model zapišimo kao
      \begin{equation}
	\begin{aligned}\label{primjer:dw5}
		\max\  & \lambda_2+\lambda_4\\
		s.t.\  &\lambda_2+3\lambda_3+4\lambda_4+s_1=\frac 94\\
		&2\lambda_2-3\lambda_3-\lambda_4+s_2=0\\
		&\sum_{j=1}^4\lambda_j = 1\\
		&\lambda_j\geqslant 0,\ j = 1,\ldots,4\\
		&s_1,s_2\geqslant 0
	\end{aligned}
\end{equation}

Sada se može inicijalnizovati RMP, biranjem dopustive baze.

Izabraćemo promjenljive $\lambda_1, s_1$ i $s_2$ kao inicijalne osnovne promjenljive. Pošto  promjenljive $\lambda_2,\lambda_3$ i $\lambda_4$ ne egzistiraju u potproblemu,  RMP izgleda ovako
      \begin{equation}
	\begin{aligned}\label{primjer:dw6}
		\max\  & 0\\
		s.t.\  &s_1=\frac 94\\
		&s_2=0\\
		&\lambda_1 = 1\\
		&\lambda_1,s_1,s_2\geqslant 0
	\end{aligned}
\end{equation}
Posljednji problem se trivijalno rješava (funkcija cilja ima vrijednost 0, a vrijednost promjenljivih se direktno očitavaju iz ograničenja). Ispitajmo sada optimalnu vrijednost dualnih promjenjivih, dakle $y$ i $\alpha$ uz pomoć simpleks tabele problema \ref{primjer:dw6}. Ona izgleda ovako
\begin{center}

\begin{tabular}{c|cccc}
	       &$s_1$  & $ s_2$   & $\lambda_1$ &  \\
 $s_1$	   &  1  &   0      &   0         &  $\frac{9}{4}$ \\
  $s_2$	  &  0  &    1     &   0         &  0             \\
$\lambda_1$	  &  0  &    0     &   1         &  1   \\ \hline
	$z$   & 0  &    0     &   0         &  0
\end{tabular}
\end{center}
 
Posmatrajmo sada dualni problem problema~\ref{primjer:dw3}. Označimo sa $y_1$, $y_2$ i $\alpha$ promjenljive dualnog problema. Kako imamo optimalnu simpleks tabelu, vrijednost optimuma dualnih promjenjivih jednaka je odgovarajućim koeficijentima doprinosa (posljednji red tabele), pa je $y_1 = 0 = y_2 = \alpha$. 

%Za dalje razmatranje biće nam potrebna  Tabela~\ref{tbl:dw1}, koju ćemo popunjavati u iterativnom procesu.
\begin{table}\centering
	\begin{tabular}{|c|c|c|}
		\hline
	$BV$ &	$(y_1,y_2,\alpha)=c^T_B B^{-1}$ & $\overline{z}= c^T_B B^{-1}b$ \\
		\hline
	$\vdots$ & 	$B^{-1}$& $B^{-1}b$ \\
		\hline
	\end{tabular}\caption{Forma tabele za praćenje vrijednosti u iterativnom procesu DW dekompozicije}\label{tbl:dw1}
\end{table}

\emph{Iteracija 1.} 
Konstruišemo column generation problem sa
\begin{align}\label{eq:cg-1}
	 \max_{x \in X} (1, 0)^T x + 0 - (0, 0) \left(\begin{array}{cc}
	 	1 & 3 \\
	 	2 & -3
	 \end{array}\right)  x = \max_{x \in X} x_1. 
\end{align} 
Optimalna vrijednost problema (\ref{eq:cg-1}) je jednaka $\hat{z}=1$, i dostiže se, recimo, u ekstremnoj tački $ x^{(2)}= (1, 0)^T.$ Kako je optimalna vrijednost pozitivna, ulazna kolona za prethodni potproblem postoji te je treba da odaberemo. Ova kolona (ako posmatramo problem (\ref{primjer:dw5})) će biti data sa 
\begin{align}
     \begin{pmatrix}
     	    c^T  x^{(2)} \\
     	    A x^{(2)}  \\
     	    1     \\
     \end{pmatrix} = \begin{pmatrix}
               1 \\
               1  \\
               2  \\
               1\\
 \end{pmatrix}
\end{align}
Kada pogledamo prethodne vrijednosti kolone i master problem (\ref{primjer:dw5}), jasno je da ona odgovara koeficijentima varijable $\lambda_2$. Dakle, prethodna kolona je data u odnosu na $\lambda_2$, ali je sada prebacimo na trenutnu bazu datu sa $s_1, s_2$ i $\lambda_1$, gdje je $B^{-1} =  \begin{pmatrix}
	1 & 0 & 0 \\
	0 & 1 & 0  \\
	0 & 0 & 1  \\
\end{pmatrix}. $ %da bismo dodali potrebnu kolonu za RMP. 
Za to je potrebno izvršiti njenu transformaciju na nove baze čiji su koraci opisani u Tabeli \ref{tbl:dw1}, odakle dobijamo kolonu za dodavanje u RMP:
 
$$	\begin{pmatrix}
	       1 \\
	      1  \\
	      2  \\
	      1\\
	\end{pmatrix}
 $$

Ubacimo za trenutak ovu kolonu u prethodnu simpleks tabelu, odakle imamo tabelu: 

 \begin{center}
 	
 	\begin{tabular}{c|ccccc}
 	                &$s_1$        & $ s_2$   &  $\lambda_1$ & $\lambda_2$   &                \\
 		$s_1$	    &   1      &    0         &   0         &     1         &  $\frac{9}{4}$ \\
 		$s_2$	    &   0      &    1         &   0         &     2         &  0             \\
 		$\lambda_1$ &   0      &    0         &   1         &     1         &  1             \\ \hline
 		$z$         &   0      &    0         &   0         &    -1         &  0
 	\end{tabular}
 \end{center}
Primijetimo da je cijena doprinosa dodate kolone promijenjena sa 1 na -1 (zbog korištenja tabelarne forme simpleks metoda, optimalna vrijednost problema je -$\hat{z}$, jer se u stvari minimizuje CG potproblem). Sada koristimo novu kolonu kao ulaznu kolonu za transformacije -- u njoj tražimo kandidata za pivota kako smo to i vidjeli u simpleks metodi. Odaberemo element čija je vrijednost $2$, pa pivotirajmo oko njega. Prvo sve elemente u koloni 2 podijelimo sa 2, te potom izvršimo elementarne transformacije u kojima načinimo nule u ostalim elementima novododate kolone. Varijabla $s_2$ izlazi iz baze, dok $\lambda_2$ ulazi u bazu. Na kraju dobijamo transformisanu tabelu:

\begin{center}
	
	\begin{tabular}{c|ccccc}
	             	&$s_1$     &    $ s_2$                &  $\lambda_1$   & $s_2$     &                \\
		$s_1$	    &   1      &   -$\frac{1}{2}$         &   0         &     0         &  $\frac{9}{4}$ \\
		$\lambda_2$ &   0      &    $\frac{1}{2}$         &   0         &     1         &  0             \\
		$\lambda_1$ &   0      &    -$\frac{1}{2}$        &   1         &     0         &  1             \\ \hline
		$z$         &   0      &    $\frac{1}{2}$         &   0         &    0          &  0
	\end{tabular}
\end{center} 
Dakle, bazne varijable su sada iz skupa $\{s_1, \lambda_1, \lambda_2\}$, koja odgovara baznoj matrici 
$B^{-1} = 
\begin{pmatrix}
	   1 & -\frac{1}{2}    &  0 \\
	   0 & \frac{1}{2}     &  0  \\
	   0 & -\frac{1}{2}    &  1  \\
\end{pmatrix}$
na osnovu prethodne simpleks tabele, dobijamo   vrijednosti dualnih varijabli iz koeficijenta doprinosa, tj. $y_1 = 0, y_2 = \frac{1}{2}, \alpha = 0$. \\
\emph{Iteracija 2.} Iz prethodnog dobijamo column generation potproblem 
\begin{align}
	 \max_{x \in X} (1, 0)^T x - (0, \frac{1}{2})\left(\begin{array}{cc}
	 	1 & 3 \\
	 	2 & -3
	 \end{array}\right)  x   - 0 = \max_{x \in X}x_1 - x_1 + \frac{3}{2}x_2 = \max_{x \in X} \frac{3}{2}x_2.
\end{align}
Rješenje ovog problema je lako dobiti, tj. optimum se dostiže u, recimo,  tački $x^{(3)}= (0, 1)^T$, dok je optimalna vrijednost jednaka $\hat{z}= \frac{3}{2}$. Kako je $\hat{z} > 0$, treba da odaberemo novu kolonu koja se dodaje u RMP. 
Ova kolona (ako posmatramo problem (\ref{primjer:dw5})) je   data sa 
\begin{align}
	V =   \begin{pmatrix}
		c^T  x^{(3)}\\
		A  x^{(3)}  \\
		1     \\
	\end{pmatrix} = \begin{pmatrix}
		0 \\
		3  \\
		-3  \\
		1\\  
	\end{pmatrix}
\end{align}

Kada pogledamo prethodne vrijednosti kolone $V$ i master problem (\ref{primjer:dw5}), jasno je da ona odgovara koeficijentima varijable $\lambda_3$. Dakle, prethodna kolona je data u odnosu na varijablu $\lambda_3$ početnog problema, ali je sada izražavamo preko trenutne baze (potproblema) vektora $s_1, s_2$ i $\lambda_2$. Dakle, nakon množenja kolone sa inverzom baze $B^{-1}$, koraci opisani u Tabeli \ref{tbl:dw1}, sljedeća kolona je ulazna koja se dodaje u simpleks tabelu:

\begin{center}
 
  $\begin{pmatrix}
	 -\frac{3}{2}            \\
	 \frac{9}{2}     \\
 	-\frac{3}{2}       \\
	 \frac{5}{2}    \\
   \end{pmatrix}$
\end{center}
Dakle, dobijamo tabelu 

\begin{center}
 
		\begin{tabular}{c|cccc|c}
		   $s_1$	    &   1      &   -$\frac{1}{2}$         &   0         &   $\frac{9}{2}$          &  $\frac{9}{4}$ \\
		   $\lambda_2$  &   0      &    $\frac{1}{2}$         &   0         &  -$ \frac{3}{2}$         &  0             \\
		   $\lambda_1$  &   0      &    -$\frac{1}{2}$        &   1         &  $\frac{5}{2} $          &  1             \\ \hline
		   $z$          &   0      &    $\frac{1}{2}$         &   0         &   -$\frac{3}{2}$       & 0  
	\end{tabular}
 
\end{center} 
Sada nađimo pivota oko kolone koja je dodana. Kandidati za izlazak iz baze su ili $s_1$ ili $\lambda_2$ dok će mjesto njih ući varijabla $\lambda_3$. Kako je $\frac{9/4}{9/2}=\frac{1}{2} < \frac{1/2}{5/2}=\frac{1}{5}$, imamo da je $\frac{5}{2}$ pivot element. Sada pivotiramo oko tog elementa na način da se kolona transformiše elementarnim transformacijama po vrstama na kolonu sa svim nulama osim na poziciji pivota, gdje treba da stoji jedinica. Na taj način, simpleks tabela se transformiše u novu simpleks tabelu 

\begin{center}
	
	\begin{tabular}{c|cccc|c}
		$s_1$	    &   1      &    $\frac{2}{5}$          &   -$\frac{9}{5}$       &   0          &  $\frac{9}{20}$ \\
		$\lambda_2$  &   0      &    $\frac{1}{5}$         &   $\frac{3}{5}$        &   0          &  $\frac{3}{5}$             \\
		$\lambda_3$  &   0      &    -$\frac{1}{5}$        &   $\frac{2}{5}$        &   1          &  $\frac{2}{5}$            \\ \hline
		$z$          &   0      &    $\frac{1}{5}$         &  $ \frac{3}{5}$        &   0           & $\frac{3}{5}$
	\end{tabular}
	
\end{center} 
  Pročitamo vrijednost dualnih promjenjivih u posljednjoj vrsti: $y_1 =0, y_2=\frac{1}{5}$ i $\alpha=\frac{3}{5}$.\\ \emph{Iteracija 3.} Prema tome, novi CG potproblem je dat sa 
  \begin{align*}
        \max_{x \in X} (1, 0)^T x - (0, \frac{1}{5})\left(\begin{array}{cc}
       	1 & 3 \\
       	2 & -3
       \end{array}\right)  x   - \frac{3}{5} &= \max_{x \in X}x_1  - \frac{2}{5}x_1 + \frac{3}{5}x_2 - \frac{3}{5} \\
       &= \max_{x \in X} \frac{3}{5}x_1 + \frac{3}{5}x_2 - \frac{3}{5}.
  \end{align*} 
Optimalna vrijednost CG potproblema se dostiže u $x^{(4)} = (1, 1)^T$ i ona je jednaka $\hat{z}=\frac{3}{5}$. Kako je $\hat{z}>0$, tražićemo novu kolonu koju treba dodati u potproblem. Ova kolona (ako posmatramo problem (\ref{primjer:dw5})) je   data sa 
\begin{align}
	V =   \begin{pmatrix}
		c^T x^4\\
		A x^4  \\
		1     \\
	\end{pmatrix} = \begin{pmatrix}
		1 \\
		4  \\
		-1  \\
		1\\  
	\end{pmatrix}
\end{align}
Kada pogledamo prethodne vrijednosti kolone $V$ i master problem (\ref{primjer:dw5}), jasno je da ona odgovara koeficijentima varijable $\lambda_4$. Dakle, prethodna kolona je data u odnosu na varijablu $\lambda_4$ početnog problema, ali je sada izražavamo preko trenutne baze (potproblema) vektora $s_1, \lambda_2$ i $\lambda_3$.  Dakle, nakon množenja kolone sa inverzom baze 
$B^{-1}= 
\begin{pmatrix}
	 1 &  \frac{2}{5}   & -\frac{9}{5} \\
	 0 &  -\frac{1}{5}  & \frac{3}{5}  \\
	 0 &  -\frac{1}{5}  & \frac{2}{5}  \\ 
\end{pmatrix} $, koraci opisani u Tabeli \ref{tbl:dw1}, sljedeća kolona je ulazna koja se dodaje u simpleks tabelu:

\begin{center}
	
	$\begin{pmatrix}
		-\frac{3}{5}            \\
		\frac{9}{5}     \\
		 \frac{2}{5}       \\
		\frac{3}{5}    \\
	\end{pmatrix}$
\end{center}
Dakle, imamo simpleks tabelu 

\begin{center}
	
	\begin{tabular}{c|cccc|c}
		$s_1$	    &   1      &    $\frac{2}{5}$          &   -$\frac{9}{5}$       &  $\frac{9}{5} $        &  $\frac{9}{20}$ \\
		$\lambda_2$  &   0      &    $\frac{1}{5}$         &   $\frac{3}{5}$        &   $\frac{2}{5}$        &  $\frac{3}{5}$             \\
		$\lambda_3$  &   0      &    -$\frac{1}{5}$        &   $\frac{2}{5}$        &   $\frac{3}{5}$         &  $\frac{2}{5}$            \\ \hline
		$z$          &   0      &    $\frac{1}{5}$         &  $ \frac{3}{5}$        &   -$\frac{3}{5}$         & $\frac{3}{5}$
	\end{tabular}
	
\end{center} 
Nađimo sada pivota u dodanoj koloni. Kako je $\frac{9/20}{9/5} < \frac{2/5}{3/5}< \frac{3/5}{2/5}$, slijedi da je pivot element $\frac{9}{5}$.  Sada pivotiramo oko tog elementa na način da se kolona transformiše elementarnim transformacijama po vrstama na kolonu sa svim nulama osim na poziciji pivota, gdje treba da stoji jedinica. Na taj način, simpleks tabela se transformiše u novu simpleks tabelu 
\begin{center}
	
	\begin{tabular}{c|cccc|c}
		$\lambda_4$	 &   $\frac{5}{9}$      &    $\frac{2}{9}$          &   -1       &  1      &  $\frac{1}{4}$ \\
		$\lambda_2$  &   -$\frac{2}{9}$    &   $\frac{1}{9}$        &   1        &   0         &  $\frac{1}{2}$        \\
	    $\lambda_3$  &  -$\frac{1}{3}$     &    -$\frac{1}{3}$      &   1        &   0        &  $\frac{1}{4}$      
		    \\ \hline
		$z$          &   $\frac{1}{3}$     &    $\frac{1}{3}$         &  $0$        &  0         & $\frac{3}{4}$
	\end{tabular}
	
\end{center} 
Iz prethodne tabele pročitamo vrijednost dualnih varijabli: $y_1 =  \frac{1}{3}=y_2$, dok je $\lambda=0$. \\
\emph{Iteracija 4.} Na osnovu vrijednosti dualnih varijabli, formira se novi column generation potproblem:
 
	 \begin{align*}
		\max_{x \in X} (1, 0)^T x - (\frac{1}{3}, \frac{1}{3})\left(\begin{array}{cc}
			1 & 3 \\
			2 & -3
		\end{array}\right)  x   - 0 &= \max_{x \in X} (x_1  - x_1 ) = 0    
	\end{align*} 
  Iz ovoga zaključujemo da je $\hat{z}=0$, pa iz (\ref{dw8}) slijedi da smo dobili optimum početnog problema i optimalna tačka je data sa 
\begin{align*}
  	 x^* &= \frac{1}{2}  x^{(2)}+ \frac{1}{4} x^{(3)} + \frac{1}{4} x^{(4)} 
  	     = \frac{1}{2} \begin{pmatrix}
  	     	      1 \\
  	     	      0
  	     \end{pmatrix} +
       \frac{1}{4} \begin{pmatrix}
       	                  0 \\
       	                  1
       \end{pmatrix} +
   \frac{1}{4} \begin{pmatrix}
   	                  1 \\
   	                  1
   \end{pmatrix}\\
   &= \begin{pmatrix}
   	        \frac{1}{2} + 0 + \frac{1}{4} \\
   	        0 + \frac{1}{4} + \frac{1}{4}
   \end{pmatrix} = \begin{pmatrix}
         \frac{3}{4} \\
         \frac{1}{2}
  \end{pmatrix}
\end{align*}
\vspace{1cm} \\

\textbf{Zadaci}
\begin{enumerate}
	\item % http://motor.ece.iit.edu/ms/benders.pdf
	  	Uz pomoć Benderove dekompozicije riješiti sljedeći MILP problem:
	  \begin{align*}
	  	   &\min x + y \\
	  	   &s.t. \\
	  	   & 2x + y \geq 3 \\
	  	   & x \geq 0 \\
	  	   & y \in \{-5, -4,\ldots, 3, 4\}.
   	  \end{align*}
	\item %http://eaton.math.rpi.edu/faculty/Mitchell/courses/matp6620/notesMATP6620/lecture23/23C_benders_egbeamer.pdf
	Uz pomoć Benderove dekompozicije riješiti sljedeći MILP problem:
	\begin{align*}
		 &\max 8 y_1 + 9 y_2 + 5 y_3 + 6 y_4 - 15 x_1 - 10 x_2 \\
		 & s.t.\\
		 &y_1 + y_3 \leq 1 \\
		 & y_1 + y_4 \leq 1 \\
		 &y_2 + y_4 \leq 1 \\
		 & -x_1-x_2 \leq -1 \\
		 & y_1 - x_1 \leq 0 \\
		 & y_2 - x_1 \leq 0 \\
		 & y_3 - x_2 \leq 0 \\
		 & y_4 - x_2 \leq 0 \\
		 & y_1,y_2,y_3,y_4,x_1, x_2 \geq 0 \\
		 & x_1, x_2 \in \mathbb{Z}.
	\end{align*}
\item %https://homepages.rpi.edu/~mitchj/matp6640/
%https://personal.eur.nl/birbil/ie606/04_DW_Dec/04_DW_Dec_Octave.html
Uz pomoć DW dekompozicije riješiti sljedeći MILP problem:
\begin{align*}
	&\min x_1 - 3 x_2 \\
	& s.t. \\
	& -x_1 + 2x_2 \leq 6 \\
	& x_1 + x_2 \leq 5 \\
	& x_1, x_2 \geq 0.
\end{align*}

\item %https://perso.uclouvain.be/anthony.papavasiliou/public_html/DantzigWolfe.pdf
	Uz pomoć   DW dekompozicije riješiti sljedeći MILP problem:
\begin{align*}
	 &\min -4x_1 - x_2 - 6 x_3 \\
	 & s.t.\\
	 & 3 x_1 + 2 x_2 + 4 x_3 = 17 \\
	 & x \in X = \begin{cases}
	 	1 \leq x_1 \leq 2 \\
	 	1 \leq x_2 \\
	    1 \leq x_3 \leq 2. 
	 \end{cases}
\end{align*}
\item %https://homepages.rpi.edu/~mitchj/handouts/egdcmp/ 
    Proučiti opšti slučaj za DW dekompoziciju kada poliedar koji odgovara problemu nije ograničen (u njemu postoji zrak). Nakon toga, uz pomoć DW dekompozicije riješiti sljedeći MILP problem:
	\begin{align*}
		 &\min x_1 - x_2 - 2 x_3 \\
		 & s.t. \\
		 & x_1 + x_2 + x_3 = 3 \\
		 & x \in X = \begin{cases}
		 	        0 \leq x_1 \leq 2 \\
		 	        0 \leq x_2 \\
		 	        0 \leq x_3 \leq 2. 
		 \end{cases}
	\end{align*}

\end{enumerate}

%TODO... prvo izraziti kolone u odnosu na originalni problem, potom prebaciti u odnosu na bazne vektore, ubaciti u prethodnu simpleks tabelu (baznih vektora), pivotirati tabelu, dobiti novu tabelu, izvuci baze, dualne vrijednosti, formirati novi CG problem. 


 \chapter{Metode za Nalaženje Dopustivih Rješenja}

\section{Pohlepni Algoritmi}
 
Pohlepni algoritmi su programska paradigma koja gradi riješenje komponentu po komponentu tako da  naredna komponenta rješenja koja se dodaje po nekom kriterujumu donosi veće benefite u odnosu na sve ostale komponente koje se razmatraju za dodavanje u parcijalnom riješenju. Dakle, u svakom trenutku bira se komponenta koja je lokalno najbolji kandidat za dodavanje u rješenje.  Ovi algoritmi se često koriste u rješavanju teških optimizacionih problema i najčešće su prva strategija koja se primjenjuje prije 
upotrebe neke složenije paradigme. Optimizacioni problem se rijetko može riješiti do optimalnost pomoću pohlepnih algoritma ali se sa njim mogu ponuditi dobra aproksimaciona rješenja u kratkom vremenskom periodu koja često služe kao osnov za konstrukciju naprednijih algoritama koja nalaze  rješenja boljeg kvaliteta. Pohlepni algoritmi nekad mogu riješiti problem, kao što je, recimo, Frakcioni problem ruksaka, ali ne i 0-1 Knapsack problem. 

U ovoj sekciji razmatramo nekoliko poznatih pohlepnih algoritama koji se mogu naći u literaturi, kao što su:
\begin{itemize}
	\item  \emph{Kruskalov algoritam} za minimalno pokrivajuće stablo (MST);
	\item  \emph{Primov algoritam} za minimalno pokrivajuće stablo;
	\item  \emph{Dajkstrin algoritam} za nalaženje najkraćih puteva;
	\item  Pohlepni algoritam za problem \emph{najdužeg zajedničkog podniza} za proizvoljan skup stringova.
\end{itemize}

Neka je dat težinski graf $G=(V,E)$. Svaku težinu grane $uv \in E $ u grafu $G$, označimo sa $w(uv)$. 
Krenimo prvo sa definicijom pokrivajućeg stabla, pa potom i minimalnog pokrivajućeg stabla. 
\begin{definition}
  Stablo $T =(V_1, E_1)$ je pokrivajuće za graf $G=(V,E)$ akko
  $V_1 = V$ i $E_1 \subseteq E$. Pokrivajuće stablo $T$ grafa $G$ sa minimalnom težinom 
  $\sum_{e \in E(T)=E_1} w(e)$ se naziva minimalno pokrivajuće stablo (MST) grafa $G$. 
\end{definition}
Postoji nekoliko efikasnih algoritama za pronalazak MST, koje u nastavku i opisujemo. 


\subsection{Primov algoritam}

Algoritam izvršava sljedeće korake:

\begin{itemize}
	\item Kreirati skup \emph{mstSkup} da bi se pratili svi čvorovi koji su već uključeni u MST.
	\item Dodijeliti vrijednosti svakom čvoru u ulaznom grafu: inicijalizovati ih na +$\infty$. 
	      Dodijeli vrijednosti 0 za čvor koji je izabran prvi za MST;
	\item Dok god \emph{mstSkup} ne uključi sve čvorove iz $V$, radimo sljedeće korake:
	\begin{itemize}
		\item Izabrati čvor $u$ koji nije u \emph{mstSkup} sa minimalnom vrijednošću (pohlepni korak);
		\item \emph{mstSkup} = \emph{mstSkup}$\cup \{u\}$;
		\item Ažurirati vrijednosti svih susjeda čvora $u$ na sljedeći način:
		     \begin{itemize}
		     	\item Za svaki susjed $v$, ako je težina grane $uv$ manja od
		             ranije vrijednosti za $v$, dodijeliti vrijednost čvoru $v$ na $w(uv)$. 		    
	         \end{itemize}
	\end{itemize}
\end{itemize}

Ideja dodjele vrijednosti čvorovima koji još nisu prisutni u MST je u tome da se efikasno izabere grana minimalne težine koja treba da se doda u trenutni MST. Dakle, ove vrijednosti ukazuju na grane minimalne težine kojse su povezane sa skupom čvorova koji su već uključeni u MST.

Kompleksnost algoritma. Lista susjedstva i pretraga: $O(|V|^2)$. Ako  koristimo prioritetni red za nalaženje grane minimalne težine, postiže se kompleksnost od $O( |E| \log(|V|))$. 

MST ima aplikacije u ($i$) dizajniranju mreža kao što je telefonska, gdje je potrebno u svako domaćinstvo (koje je predstavljeno jednim čvorom) postaviti linije tako da se povežu sva domaćinstva u mrežu uz potrošnju što manje materijala za infrastrukturu mreže; ($ii$) aproksimaciji drugih teških optimizacionih problema kao što je problem trgovačkog putnika (TSP). Ponovimo, u TSP-u je potrebno naći najkraću konturu koji posjećuje u (težinskom) grafu. Primijetimo da su takvi putevi takođe MST. Težina MST je manja nego težina TSP, jer minimizujemo nad većim skupom rješenja, tako da se može pokazati da je nalazak MST-a u težinskom grafu aproksimira nalazak TSP-a (nad euklidskim težinskim grafovima).  
($iii$) Klaster analiza. $k$-klaster problem  se može posmatrati kao problem nalaženja MST-a, a potom brisanja $k-1$ najskupljih grana iz MST. 

\subsection{Kruskalov algoritam.}

Ovo je još jedan pohlepni algoritam za nalaženje MST. Radi na principu sortiranja 
grana na osnovu njihove težine. Neka je $\emph{mst} = \emptyset$. Preciznije, sljedeći koraci se izvršavaju:

\begin{enumerate}
	\item Sortiranje svih grana u neopadajućem poretku;
	\item Odabir najlakše grane i provjera da li se formira ciklus ako se ova 
	grana doda u skup grana koje su do sada ubačene u skup \emph{mst}; Ako to nije slučaj, ubaciti granu u trenutni skup \emph{mst}. Inače, uzeti granu koja je sljedeća u sortiranom nizu (pohlepni korak);
	\item Ponoviti korak 2, dok se ne doda tačno $|V|-1$ grana u \emph{mst}.
\end{enumerate} 

\noindent Vremenska kompleksnost algoritma je $O(|E|\log |E|)$ ili $O(|E|\log |V|)$. Sortiranje grana uzima $O(|E| \log|E|)$ vremena. Potom, za svaku granu 
se primjenjuje operacija nalaženja i dodavanja grane u skup \emph{mst}. Ove dvije operacije se izvršavaju u $O(\log |V|)$ vremenu. Dakle, algoritam treba vrijeme od $O(|E|\log |E| + |E|\log |V|)$ za svoje izvršavanje. Kako je $|E|=O(|V|^2)$, dobijamo kompleksnost $O(|E| \cdot \mathrm{log}(|V|))$. 

\subsection{Dajkstrin algoritam}

Ovaj algoritam je dosta sličan Primovom algoritmu koji služi za nalaženje najkraćih puteva u grafu. Ovaj algoritam generiše tzv. SPT (eng. \emph{shortest path tree}) sa datim korjenim čvorom $s$ tako  što se formiraju dva disjunktna skupa čvorova, jedan koji sadrži čvorove uključene u SPT, a na drugoj strani svi ostali čvorovi. Inicijalno, svim čvorovima je dodjeljena vrijednost, tj. $dist[u]=\ +\infty, \forall u \in V\setminus \{s\}$, $dist[s]=0$. Neka je $Q = V$. 
U svakom koraku algoritma nalazimo čvor $u$ koji je u skupu $Q$ sa minimalnom udaljenšću \emph{dist} od korjenog čvora $s$. Zatim se posmatraju njegovi susjedi $v$ te težine grana od čvora $u$. U slučaju da je zbirna vrijednost $dist[u]$  i težine grane $w(uv)$ manja od trenutne $dist[v]$, vrijednost $dist[v]$ se ažurira jer je nađen novi najkraći put od $s$ od $v$.  Čvor $u$ se zatim izbacuje iz skupa $Q$. Algoritam nastavlja sa istim koracima dok god $Q \neq \emptyset$. 
Svi koraci algoritma su dati u Algoritmu~\ref{alg:dijkstra-algorithm}. Nakon završetka algoritma, vrijednost $dist$[$u$] odgovara težini najkraćeg puta od korjenog čvora $s$ do čvora $u$. 


\begin{algorithm}[!ht]
	\begin{algorithmic}[1]
		\FOR{ svaki čvor $v \in V$:} 	%// Inicijalizacija  
	      	\STATE   $dist[v] \gets +\infty$ 	%// Inicijalne udaljenosti od korjenog cvora $s$
		    \STATE $previous[v] \gets null$ 	%// čvor prije u optimalnoj stazi
		\ENDFOR
		\STATE	$dist[s] \gets 0$ 	 
		\STATE	$Q \gets V(G)=V$
		\WHILE{$Q \neq \emptyset$} 	 
		\STATE $u \gets$ čvor iz $Q$ sa najmanjom vrijednošću $dist$
		\STATE $Q \gets Q \setminus \{u\}$
		\FOR{ sve susjede $v$ od $u$}  
		\STATE $temp \gets dist[u] + w(u, v)$
		\IF{$temp < dist[v]$}
		\STATE  $dist[v] \gets temp$
		\STATE $previous[v] \gets u$ 
		\ENDIF
		\ENDFOR
		\ENDWHILE
		\STATE	\textbf{return} $previous$ 
	\end{algorithmic}
    		\caption{Dajkstra($G,s $)}\label{alg:dijkstra-algorithm}
\end{algorithm}

Vremenska kompleksnost gornje implementacije algoritma je $O(|V|^2)$. Ako je graf predstavljem listom susjedstva, i skup $Q$ (linija 6, Algoritam \ref{alg:dijkstra-algorithm}) je implementiran kao binarni hip, 
kompleksnost se redukuje na $O(|E| \cdot \log |V|)$.

Napomenimo da Dajkstrin algoritam ne radi sa grafovima koji imaju negativne težine (pogledati inicijane uslove u  pseudokodu, te liniju 12).  Za ovakve grafove,  primjenjuje se Bellman–Ford algoritam koji je baziran na dinamičkom programiranju. Njega ne pominjemo u detaljima u ovoj knjizi.  %, o kojem ćemo nešto više reći u narednim sekcijama.

\subsection{Frakcioni Problem Ruksaka}

\begin{definition}
  Neka je dato $n$ proizvoda sa svojim  težinom i vrijednošću, 
  te ruksak čiji je kapacitet $W$. Frakcioni problem ruksaka traži da se   odabere dio od nekih proizvoda i stave u ruksak pri tome da vrijednost u ruksaku bude što veća ali da se pri tom ne naruši kapacitet ruksaka.
\end{definition}
U 0-1 problemu ruksaka se ne dopušta dijeljenje proizvoda, ili se uzima cijeli (1) ili se uopšte ne uzima (0). U frakcionalnom problemu ruksaka, svaki proizvod posjeduje težinu i vrijednost, te se kao takav može podijeliti na dijelove (recimo uzme se pola od ukupne količine proizvoda). Efikasno riješavanje ovog problema se izvodi primjenom pohlepnog algoritma na sljedeći način. 
\begin{itemize}
	\item Računajmo podjele količina/vrijednost za svaki proizvod, te se proizvodi  sortiraju na osnovu tih vrijednosti.   \item Uzmemo proizvod sa najvećom količničkom vrijednošću te ga dodamo u ruksak. 
	\item Nastavljamo proces dodavanja sa sljedećim proizvodom dok ga ne budemo mogli da ga  dodamo cijelog u ruksak.    Ako je to slučaj, dodamo dio njega (onoliko koliko god je moguće, a da se kapacitet ruksaka ne naruši). 
\end{itemize}
Može se pokazati sljedeća teorema. 

\begin{thm}
      Pohlepni algoritam opisan prethodno za problem Frakcionog ruksaka uvijek nalazi optimalno rješenje.
\end{thm}
\subsection{Pohlepni pristup za rješavanje LCS problema}

String definišemo kao niz karaktera nad (konačnom) azbukom $\Sigma$. 
Problem najdužeg podniza (eng. \emph{Longest common subsequence}), ili skraćeno LCS, je problem koji uzima u ulazu  $n$ stringova (označimo ovaj skup sa $S$) proizvoljne dužine. Njegov zadatak je da se nađe string makimalne dužine tako da je  zajednički podniz za sve stringove iz skupa $S$.  Neka su u ulazu data tri stringa dužine šest: $S = \{  \texttt{abbccb}, \texttt{abccab}, \texttt{abbbcb}   \}$. Rješenje problema je $s=\texttt{abcb}$. Primijetimo da je $s$ podniz za sva tri stringa iz $S$, a može se (direktno) provjeriti da je to najduži takav string. 
 Ovaj problem se može riješiti u $O(n^m)$ vremenu uz pomoć dinamičkog programiranja, gdje je $n$ dužina najdužeg stringa u ulazu, a $m$ broj stringova u ulazu. Specijalno, za  $m=2$, problem je rješiv u $O(n^2)$ vremenu. Za proizvoljan ulaz, problem je NP-težak.  


Jedan od najjednostavnijih pristupa u rješavanu ovog problema je  \emph{pohlepni pristup}, tzv. \emph{Best-Next} (BN) heuristika. Prije nego navedemo detalje algoritma, uvedimo nekoliko definicija i oznaka koje će biti korištene u konstrukciji algoritma. Za cjelobrojni vektor $p^L = (p^L_1,\ldots, p^L_m)$, definišemo sa
$S[p^L] = \{s_i[p^L_i, |s_i| \mid i=1,\ldots,m\}$, gdje $|s|$ označava dužinu stringa $s$, a $s[x,y]$ podstring (sufiks) stringa $s$ koji počinje od karaktera na poziciji $x$, a završava sa karakterom na poziciji $y$. Konvencija je da se indeksi u stringu numerišu krenuvši od 1. Dakle, $s= [1, |s|]$ za svaki string $s$. Primjera radi, za (pozicioni) vektor $p^L=(1,2,2)$ i skup $S$ sa početka ove podsekcije je $S[ (1,2,3)] = \{ s_1[1, |s_1|], s_2[2, |s_2|], s_3[3, |s_3|]  \}= \{ \texttt{bbccb}, \texttt{ccab}, \texttt{bcb}\}$. 
 
Dalje, sa $p^L_{i,a}$ definišemo poziciju prvog pojavljivanja karaktera $\texttt{a}\in \Sigma$ koja je  $p^L_{i,a} \geq p^L_i$ (ukoliko karakter ne postoji, dodijelimo vrijednost $n+1$). Skup karaktera $\Sigma_{p^L}$ koji se pojavljuju u svakom od stringova u $S[p^L]$ se nazivaju dopustive ekstenzije u odnosu na pozicioni vektor $p^L$. 

U konstrukciji pohlepnog algoritma, odredimo  skup dopustivih komponenti te koji je kriterijum odabira komponenti u svakom od koraka algoritma. Inicijalno rješenje $s$ je prazan string, koji je, trivijalno, dopustivo rješenje za svaki LCS. Ideja je u svakom koraku proširiti rješenje za jedan karakter tako da spojimo taj karakter sa $s$ (sa desna) dok god je to moguće i pri tome da je prošireni string i dalje LCS. Prema tome, krenemo sa pozicijom $p^L = (1, \ldots, 1)$ koja odgovara čitavom skupu $S=S[p^L]$ i praznim stringom $s =\varepsilon$ kao inicijalno rješenje. Dalje, da bi očuvali dopustivost rješenja kada se rješenje proširi za jedan karakter, za komponente rješenja $\Sigma_{p^L}$ ćemo uzeti sve karaktere koji se nalaze u svim stringovima iz $S=S[p^L]$, jer na taj način  ekstenzija $s = s \cdot x$ za bilo koji $x \in \Sigma_{p^L}$ će dati dopustivo LCS rješenje. Među karakterima iz $\Sigma_{p^L}$ treba odabrati (lokalno) najboljeg kandidata za proširivanje rješenja. Treba imati na umu da se kandidat $x\in \Sigma_{p^L}$ može pojaviti na nekoliko pozicija u svakom stringu iz $S=S[p^L]$. Kako ne želimo ekstenzije koje vode ka podoptimalnim rješenjima, biramo karakter $x$ koji je najbliže početku u stringovima iz $S=S[p^L]$, dakle na pozicijama $p^L_{p^L_{i},a},i=1,\ldots,m$. 
To je koncept pohlepne funkcije $g$ data u nastavku sekcije. Ideja konstrukcije funkcije $g$ se sastoji u odabiru onog karaktera za proširivanje rješenja $s$ koji preskače najmanji broj karaktera iz dalje pretrage. Sljedeći korak se sastoji u ažuriranju prostora pretrage za novi korak. Kako smo proširili rješenje za $x$, nove komponente rješenja koje su dopustive tražimo u skupu stringova $S[p^L_{1,x}+1,\ldots, p^L_{m, x}+1]$. Postupak nastavljamo dok god postoje komponente koje mogu proširiti rješenje. 


\noindent Da sumiramo, pohlepni (BN) pristup za rješavanje LCS problema izvršava sljedeće korake:
\begin{itemize}
	\item Kreće se od (parcijalnog) rješenja koje je prazna niska, $s=\varepsilon$;
	\item Iniciramo pozicione vektor $p^L \gets (1,\ldots, 1) $;
	\item Dok god jedan od $p^L_i$ nije jednak $n+1$, radimo sljedeće: 
	\begin{itemize}
   	     \item $\Sigma_{p^L} \gets$ naći dopustive ekstenzije u $S[\textrm{pL}]$
	      \item Od svih karaktera u $\Sigma_{p^L}$, odaberemo onaj koji minimizuje vrijednost funkcije 
	      $$g( p^L,a) = \sum_{i=1}^m\frac{p^L_{i,a} - p^L_i + 1 }{|s_i| - p^L_i + 1 }, a \in \Sigma_{ p^L }.$$
	      Neka je taj karakter označen sa $a^*$. 
	      \item Ažuriramo: $s \gets  s \cdot a^*$, $p^L_i \gets p^L_{i, a^*} +1, i = 1,\ldots,m.$
    \end{itemize}
\end{itemize}
Algoritam vraća vrijednost $s$. 

Primijetimo da ovakav algoritam ne može da garantuje optimalno rješenje. 

\noindent \emph{Primjer}.  Neka su data dva stringa: $s_1 = \texttt{acb}, s_2 = \texttt{bac}$. Ako uzmemo  $ b$ kao prvi karakter, rješenje koje dobijamo je \texttt{b}. Medjutim, optimalno rješenje je string $s=\texttt{ac}$. 

\section{Aproksimativni Algoritmi}
  %https://home.cs.colorado.edu/~srirams/courses/csci5654-fall13/ilpLectures.pdf
  
   Za veliki broj optimizacionih problema sa enormnom kompleksnošću u praksi jednostavno ne postoje efikasni egzaktni algoritmi, te je za  njihovo rješavanje potrebano izdvojiti ogromne vremenske/memorijske resurse; dakle, za  ovakve probleme ne postoji (egzaktan) algoritam koji se izvršava u polinomijalnom vremenu $O(|P|)$, gdje je $P \in {Poly}$ neki polinom iz vektorskog prostora polinoma \emph{Poly}. Sa druge strane, većina pohlepnih algoritama i naprednijih heuristika ne daje nikakvu garanciju na nađeno rješenje iako su ta rješenja u velikom broju slučajeva visokog kvaliteta. Negdje između egzaktnih i heurističkih algoritama se smiještaju \emph{aproksimativni algoritmi} koji su polinomijalni, daju dopustiva rješenja uz garanciju o njihovom kvalitetu. 
  
  \noindent Algoritam pripada klasi \emph{aproksimativnih algoritma} ako:
  \begin{enumerate}
  	\item se izvršava u polinomijalnom vremenu;
  	%\item garantuje rješenje koje je blizu optimalnog rjesenja;
  	\item posjeduje garanciju da je nađeno (dopustivo) rješenje uvijek unutar nekog faktora ($c$) kvaliteta optimalnog rješenja, bez ikakvog prethodnog znanja o optimumu.
  \end{enumerate}
  Neka je dat algoritam $\mathcal{A}$, problem $P$ i instanca problema $I$. Sa $\mathcal{A}(I)$ označimo (dopustivo) rješenje koje se dobija kao izlaz algoritma $\mathcal{A}$, dok sa $\mathcal{A}^*(I)$ označimo optimalno rješenje za ulaz $I$. Pretpostavimo da je riječ o problemu maksimizacije. 
  
  $\mathcal{A}$ se naziva aproksimativni algoritam problema $P$ ako 
  za bilo koji ulaz (instancu) $I$, $\mathcal{A}$ vraća aproksimativno rješenje $\mathcal{A}(I)$ u polinomijalnom vremenu. 
  
  Postoji dvije vrste aproksimativnih algoritama:
  \begin{itemize}
  	\item \emph{apsolutni apriksimativni algoritam} -- ako je za svaku instancu problema $P$ ispunjeno
  	$$ |\mathcal{A}(I) - \mathcal{A}^*(I)| \geq c,$$ za neko $c\in \mathbb{R}^+$;
  	\item \emph{relativni aproksimativni algoritam} -- ako je   za svaku instancu problema $P$ ispunjeno
  	$$\frac{\mathcal{A}(I)}{\mathcal{A}^*(I)} \geq c,$$ za neko $c\in \mathbb{R}^+$.
  \end{itemize}
  
  \noindent U tom slučaju kažemo da je algoritma $\mathcal{A}$ $c$--aproksimativni algoritam.
  Primjer problema za koji postoji apsolutni apriksimativni algoritam je bojanje planarnog grafa (eng. \emph{Planar Graph Coloring}). Primjer problema za koji postoji relativni apriksimativni algoritam je pokrivanje čvorova. 
  
  \subsection{Aproksimativni algoritmi za Problem Pokrivanja Čvorova}
  
  Neka je dat graf $G=(V,E)$. Potrebno je naći podskup $C\subseteq V$ najmanje kardinalnosti td. barem jedan čvor svake grane pripada skupu $C$.  Dopustivo rješenje je svaki podskup $C$ koji zadovoljava uslov problema. Takav skup se naziva \emph{pokrivač} čvorova grafa $G$. Primjer pokrivača jednog grafa je dat na Slici~\ref{vertex-cover} gdje pokrivač uključuje sve čvorove crvene boje. 
  
  \begin{figure}
  	\centering
  	\includegraphics[width=50mm]{vertex-cover.eps}
  	\caption{Primjer pokrivača čvora.} 
  	\label{vertex-cover}
  \end{figure}
  
  Posmatrajmo (pohlepni) algoritam za ovaj problem dat Algoritmom~\ref{alg:gridi-vc}. 
  
  %pseudokod algoritma 
  \begin{algorithm}[H] 
  	\begin{algorithmic}[1]
  		\STATE $C \gets \emptyset$
  		\WHILE{$E \neq \emptyset$}
  		\STATE $(u,v) \gets$ bilo koja grana iz $E$
  		\STATE $C \gets C \cup \{u,v\}$
  		\STATE ukloniti sve grane incidentne sa  $u$ ili $v$ iz grafa $G$
  		\ENDWHILE
  		\STATE \textbf{return} $C$
  	\end{algorithmic}   
   
     \caption{Pohlepni algoritam za Problem pokrivanja čvorova}
 \label{alg:gridi-vc}
  \end{algorithm}
  
  \noindent Pokazaćemo da je ovo aproksimativni algoritam. Izračunajmo koeficijent aproksimacije $c$ za Algoritam~\ref{alg:gridi-vc}.
  Grane koje se biraju u ovom algoritmu su grane maksimalnog mečinga ($M$), pa je prema tome, skup $C$ uistinu pokrivač čvorova, prema definiciji mečinga. Dalje, jasno je da se algoritam izvodi u polinomijalnom vremenu. Neka je $C^*$ pokrivač koji je rješenje problema. Tada $C^*$ sadrži barem jedan kraj svake grane iz $M$, odakle slijedi $|C^*|\geq |M|$. Dalje, $|C|= 2 \cdot |M| \geq 2 \cdot |C^*|$. Prema tome, ovo je $2$--aproksimativni algoritam za problem pokrivanja čvorova grafa. Jednakost u prethodnoj aproksimaciji se postiže, recimo, za bipartitne grafove $K_{n,n}$. 
  
  Posmatrajmo sljedeći pohlepni Algoritam ~\ref{alg:gridi-vc-2} za problem pokrivanja čvorova.  
  
  %pseudokod algoritma 
  \begin{algorithm}[H] 
  	\begin{algorithmic}[1]
  		\STATE $C \gets \emptyset$
  		\WHILE{$E \neq \emptyset$}
  		\STATE  $u \gets \textrm{argmin}_{u \in V(G)} deg(u)$
  		\STATE  $C \gets C \cup \{u\}$
  		\STATE $G \gets$ ukloniti sve grane incidentne sa $u$ u $G$  
  		\ENDWHILE
  		\STATE \textbf{return} $C$
  	\end{algorithmic}
     	\caption{Pohlepni algoritam 2 za Problem pokrivanja čvorova}
        \label{alg:gridi-vc-2}
  \end{algorithm}
  
  \noindent Izračunajmo aproksimativni faktor Algoritma~\ref{alg:gridi-vc-2} posmatrajući jedan specijalni graf sa Slike~\ref{vertex-cover}. 
  
  
  \begin{figure}
  	\centering
  	\includegraphics[width=120mm,height=80mm]{vc-2-example.eps}
  	%\caption{Graf (nacrtati ga).} 
  	\label{vertex-cover}
 
  \end{figure}
  
  Optimalno rješenje je podskup čvorova $C^*$ koji se sastoji od svih čvorova sa vrha grafa (obojeni crnom bojom); dakle, ukupno ih je $k!$. Međutim, ako pratimo korake Algoritma~\ref{alg:gridi-vc-2}, dobijemo 
  da je $$|C| = k!\cdot( 1/k + 1/k-1 + \cdots + 1/2 + 1) \approx k! \cdot \log k.$$  
  Dakle, imamo da je
  $$   |C| \approx \log k \cdot |C^*|.$$ Prema tome, ovaj algoritam je $\log k$--aproksimativni algoritam, za $k \in \mathbb{N}$. 
  
  \noindent U literaturi, najbolji faktor je $2 - \frac{1}{\sqrt{\log n}}$ (Karakostas, 2009).
  Ono sto se takođe zna (Hastad, 2001) je da ne postoji aproksimativni faktor 
  koji garantuje da je $c < \frac{7}{6}$ (osim ako $P \neq NP$). 
  
  \subsection{Aproksimativni algoritmi za Problem Trgovačkog Putnika}
  
  Ovaj problem je jako težak kada je u pitanju konstrukcija aproksimativnog algoritma. Tome svjedoči sljedeća teorema.
 \begin{thm}
    Ne postoji polinomijalan algoritam koji može aproksimirati TSP sa  faktorom $c > 1$, osim ako je $P = NP$. 
\end{thm}
  Kažemo da grane grafa zadovoljavaju nejednakost trougla akko za sve različite čvorove $u,v, r$ grafa $G$ vrijedi
  $$ w(u,v) + w(v,r) \geq w(u,r),$$
  gdje su $w(\cdot, \cdot)$ težine grane koja spaja dva čvora. Ovaj problem je poznat 
  pod nazivom \emph{Metrički} TSP. On je i dalje NP--težak, ali se aproksimativni algoritam ipak može konstruisati.  U nastavku algoritme izvodimo za metrički  TSP. Posmatrajmo \emph{algoritam najbližeg dodavanja} koji aproksimira TSP, dat u Algoritmu~\ref{alg:tsp-a1}. 
  
   \begin{algorithm}[!t] 
  
  	\begin{algorithmic}[1]
  		\STATE \textbf{Ulaz}: Kompletan težinski graf $G$
  		\STATE \textbf{Izlaz}: Hamiltonova kontura $T$  
  		\STATE $u,v \gets \mbox{argmin}_{uv \in E} w(u,v)$
  		\STATE $S \gets \{u,v\}$
  		\STATE $T \gets uv$
  		\WHILE{$|S| \neq n$}
  		\STATE $u,t \gets$ $\mbox{argmin}_{(u,t) \in (V(G)\setminus V(T)) \times V(T)} \{w(u, t)\}$
  		\STATE $ S \gets S \cup \{u\}$ 
  		\STATE $(u, q)\gets$ čvor $q$ slijedi $u$ u  $T$
  		\STATE  $uq$ se izbacuje iz $T$, ubacuje se $utq$  // Ažururanje $T$ (rekonstrukcija)
  		\ENDWHILE
  		\STATE \textbf{return} $T$
  	\end{algorithmic}
   	\caption{Aproksimativni algoritam 1 za TSP.}
   	\label{alg:tsp-a1}
  \end{algorithm}

 Ovo je očigledno polinomijalan algoritam. Ispitajmo koji aproksimacioni faktor se 
njime postiže. Primijetimo da algoritam podsjeća na Primov algoritam. Grane koje se identifikuju algoritmom 
konstruišu MST. Zaključujemo da je cijena konture $T$ barem jednaka koliko i cijena MST u odnosu na iste ulazne podatke. Cijena konture za dva čvora $v_i$ i $v_j$ je $2 \cdot w({v_i,v_j})$ (jer računamo i povratnu granu). Posmatrajmo jednu iteraciju Algoritma~\ref{alg:tsp-a1}, gdje se $T$
proširuje za čvor $t$ koji se ubacuje između čvorova  $u$ i $q$. Povećanje cijene (trenutne) konture $T$ u svakoj iteraciji je $$w({u,t}) + w({t,q})-w({u,q}).$$
Na osnovu nejednakosti trougla imamo $ w({t,q}) \leq w({t,u}) + w({u,q})$. Prema tome, porast cijene konture $T$ u svakoj iteraciji je najviše $ w({t, u}) + w({u,t}) = 2\cdot w({u,t})$. 
Dakle, završna kontura ima cijenu koja dostiže cijenu koja je barem dva puta veća od cijene MST. Prema tome, ovo je 2-aproksimativni algoritam. 

 \noindent Pokusajmo poboljšati 2--aproksimativni algoritam~\ref{alg:tsp-a1} uz pomoć \emph{Double tree algoritma}, kojeg objašnjavamo u nastavku. Prije toga uvodimo nekoliko definicija i teorema od bitnog uticaja u formiranju algoritma. 
 \begin{definition}
 	  Neka je dat graf $G=(V,E)$. Ojlerova konturu $T^o$ grafa $G$ je kontura $e_1e_2...,e_me_1$ koja obilazi sve grane grafa $G$. 
 \end{definition}
Vrijedi sljedeća karaketrizacija grafova koji imaju Ojlerovu konturu. 
\begin{thm}
	 Graf $G$ sadrži Ojlerovu konturu akko je povezan i svaki njegov čvor je paran. Takva klasa grafova se naziva Ojlerova klasa grafova.
\end{thm}

 %pseudokod algoritma 
\begin{algorithm}[H] 
	\begin{algorithmic}[1]
		\STATE \textbf{Ulaz}: Kompletan graf $G$
		\STATE \textbf{Izlaz}: Hamiltonova kontura $T$   
		\STATE $mst \gets$  Izračunati MST grafa $G$
		\STATE $mst^{copy} \gets$ Zamijeniti svaku granu u $mst$ sa dvije kopije istog
		\STATE $T^o \gets$ Naći Ojlerovu konturu $T$ u $mst^{copy}$
		\STATE   $T$ $\gets$ Izbaciti duple čvorove iz $T^o$   
		\STATE \textbf{return} $T$ 
	\end{algorithmic}
   	\caption{Aproksimativni algoritam 2 za TSP.}
   	\label{alg:tsp-a2}
\end{algorithm}
  Pokažimo da ovim algoritmom dobijamo 2--aproksimaciju. Jasno je da je algoritam polinomijalan i da je dobijeno rješenje dopustivo. Pokažimo sada da ovim ostvarujemo faktor $2$.  
  Neka je $C^*$ cijena optimalne Hamiltonove konture. Tada je MST $\leq C^*$. 
  Lako se vidi da je cijena Ojlerove konture  $\leq 2 \cdot C^*$. Na osnovu nejednakosti trougla skraćivanje Ojlerove konture (linija 6 u algoritmu) da bi se dobila Hamiltonova kontura $T$ ne može da bude veća od 2$C^*$. Dakle, slijedi da je cijena Hamiltonove konture $\leq 2 C^*$, pa je ovaj algoritam 2--aprokimativni.
  
 
   \begin{figure}[!ht]
 	\begin{subfigure}{.45\textwidth}
 		\centering
 		% include first image
 		\includegraphics[width=.7\linewidth]{tsp-1}  
 		\caption{Graf $G$.}
 		\label{fig:tsp-1}
 	\end{subfigure}
 	\begin{subfigure}{.45\textwidth}
 		\centering
 		% include second image
 		\includegraphics[width=.7\linewidth]{tsp-1a}  
 		\caption{MST grafa $G$}
 		\label{fig:tsp-1a}
 	\end{subfigure}
 
 	\begin{subfigure}{.45\textwidth}
 		\centering
 		% include first image
 		\includegraphics[width=.7\linewidth]{tsp-2a}  
 		\caption{Ojlerova kontura: $C_1 C_3 C_4 C_3 C_5 C_3 C_2 C_3 C_1$.}  
 		\label{fig:tsp-1}
 	\end{subfigure}
 	\begin{subfigure}{.45\textwidth}
 		\centering
 		% include second image
 		\includegraphics[width=.7\linewidth]{tsp-3a}  
 		\caption{Hamiltonova kontura (ciklus): $C_1C_3C_4C_5C_2C_1$.} 
 		\label{fig:tsp-1a}
 	\end{subfigure}
    \label{fig:tsp-1a1}
    \caption{Koraci u konstrukciji Kristofidjesovog algoritma.}
 \end{figure}



Posmatrajmo sljedeći (aproksimativni) algoritam koji umanjuje aproksimativni faktor TSP sa $2$ na 1.5. Algoritam je poznat pod nazivom \emph{Kristofidesov} algoritam i dat je u Algoritmu~\ref{alg:tsp-a3}.

%pseudokod algoritma 
\begin{algorithm}[H] 

	\begin{algorithmic}[1]
		\STATE \textbf{Ulaz}: Kompletan graf $G$
		\STATE \textbf{Izlaz}: Hamiltonova kontura $T$ 
		\STATE $T \gets$ Naći MST grafa $G$
		\STATE $M \gets$ Naći minimalan mečing svih čvorova u $T$ neparnog stepena
		\STATE $T' \gets$ Dodamo grane od $M$ u $T$
		\STATE $T^o\gets$ Nađimo Ojlerovu konturu u $T'$
		\STATE $T \gets$ Izbaciti duple čvorove iz $T^o$
		\STATE \textbf{return} $T$
	\end{algorithmic}	
    \caption{Kristofidesov algoritam.}
    \label{alg:tsp-a3}
\end{algorithm}
  Lako je vidjeti da je ovaj algoritam polinomijalan i da je dobijeno rješenje dopustivo.
 Pokažimo da algoritam ima faktor aproksimacije $c=1.5$.  Cijena TSP $C^*$ dostiže najviše cijenu Ojlerove konture, tj.  $C^*\leq cost(T^o) = cost(T) + cost(M)$.  Takođe vrijedi $cost(T) \leq C^*$. Pokažimo da je $cost(M) \leq  \frac{C^*}{2}$, odakle bi slijedila tvrdnja. Primijetimo da u optimalnoj konturi $T$ postoje dva mečinga: prvi sa čvorovima iz $M$, a drugi za ostale čvorove kojeg označavamo sa $M'$. 
 Kako je $C^* \geq cost(M) \leq cost(M')$ i $cost(M) + cost(M') = cost(T)$, slijedi 
 $2 cost(M) \leq cost(T) \leq C^*$, odakle dobijamo tvrđenje.  U literaturi je pokazano da ne postoji  aproksimacioni algoritam sa faktorom  $c < \frac{220}{219} \approx 1.0045$ (osim ako je $P=NP$). 
 
 
 \subsection{Aproksimativni algoritmi za Problem Binarnog Pakovanja}
% Zadatak: https://scipbook.readthedocs.io/en/latest/bpp.html
\begin{definition}
    Neka je dato $n$ proizvoda veličine $a_1,a_2,\ldots,a_n$ ($0<a_i<1$). Potrebno je spakovati sve proizvode u jedinična pakovanja, tako da je broj korištenih pakovanja minimalan.  
\end{definition} 

  Primjer jedne instance problema pakovanja je dat na Slici~\ref{fig:bin-packing}.

\begin{figure}
	\centering
	\includegraphics[width=100mm]{maxresdefault.eps}% bin-packing
	\caption{Primjer Binarnog Pakovanja.}
    \label{fig:bin-packing}
\end{figure}
 \emph{First-fit} algoritam. Ovo je pohlepni algoritam, koji se sastoji do sljedećih koraka:
\begin{itemize}
	\item Stavljamo proizvode u redu u kojem su poredani za pakovanje, tj. $a_i$ se pakuje prije $a_j$ akko $i < j$;
	\item Stavljamo sljedeći proizvod u pakovanje sa najmanjim indeksom u koji može da stane. \item Ako ne odgovara niti jednom od otvorenih pakovanja, otvoriti novo pakovanje i smjestiti taj proizvod u novo pakovanje.
\end{itemize}


\noindent Analiza algoritma. Ovo je polinomijalan algoritam koji vraća dopustivo rješenje.  Neka je $C^*$ optimalan broj pakovanja koji se otvara da bi se spakovalo svih $n$ stavki. Pretpostavimo da algoritam vraća rješenje $C$ (pakovanja). Iz toga je barem $C-1$ pakovanja više od polovine mjesta je iskorišteno. Odatle je
$$C^* \geq \sum_{i=1}^n a_i > \frac{C-1}{2}\ \Rightarrow\  2 \cdot C^* > C-1 \Rightarrow 2 \cdot C^* \geq C,$$
pa slijedi da je algoritam 2--aproksimacioni. 

 Još jedan pohlepni algiritma za ovaj problem je \emph{Best fit}. Sljedeći proizvod se stavlja u pakovanje koje ostavlja najmanju prazninu od svih pakovanja kada se taj prizvod smjesti u odgovarajuće pakovanje. Ako takvo pakovanje ne postoji, otvoriti novo pakovanje. 
Ovaj algoritam je takodje 2--aproksimacioni. Interesantno je napomenuti da za Problem binarnog pakovanja ne postoji aproksimativni algoritam čiji je faktor $c <\frac{3}{2}$ (osim ako je $P=NP$), kako je pokazano u literaturi. 

 \subsection{Aproksimativni algoritmi za Problem Pokrivanja Skupa}
Ovaj problem predstavlja uopštenje Problema pokrivanja čvorova, i definisan je na sljedeci naćin.
\begin{definition}
	    Neka je dat skup elemenata $X$ te familija podskupova $\mathcal{F}$ skupa $X$ tako da je za svaki $f\in \mathcal{F}$, $|f \cap X| \geq 1$ i $\bigcup_{f \in \mathcal{F}} f = X$. 
	    Potrebno je naći pokrivač $C \subseteq \mathcal{F}$ minimalne kardinalnosti tako da je 
	    $$ \bigcup_{f \in C} f = X.$$
\end{definition}
 U nastavku izlažemo pohlepnu heuristiku koja predstavlja aproksimativni algoritam sa logaritamskim faktorom. To znači, kako je veličina ulaza veća, kvalitet rješenja aproksimativnog algoritma opada relativno u odnosu na veličinu optimalnog rješenja. Kako logaritam kao funkcija raste sporim intenzitetom, ovaj aproksimacioni algoritam ipak daje korisne rezultate.

\begin{figure}
	\centering
	\includegraphics[width=120mm, height=80mm]{set-cover-1.eps}
	\caption{Primjer Pokrivanja Skupa ($\mathcal{F}=\{T_1,T_2,...,T_4\}$, optimalno rješenje je skup $\mathcal{C}=\{T_2, T_3\}$}
	 \label{fig:set-cover-1}
\end{figure}

Što se tice motivacije za ovaj problem, pretpostavimo da imamo skup karakteristika, te skup ljudi koji posjeduju pojedine karakeristike. Potrebno je formirati komisiju sa što manjim brojem osoba tako da se za svaku karakteristiku može naći osoba iz komisije da je stručna u tome. Pohlepni algoritam za ovaj problem je dat u Algoritmu~\ref{alg:set-cover-gridi}.  %objasnjenje algoritma.
Skup $U$ predstavlja skup preostalih nepokrivenih elemenata dok skup $\mathcal{C}$ pedstavlja pokrivač koji se konstruiše kroz iteracije algoritma. U svakom koraku, algoritam nastoji da proširi pokrivač $\mathcal{C}$ na račun smanjenja skupa $U$. Kandidata za proširivanje pokrivača biramo na osnovu pohlepne funkcije datoj u liniji 6. U osnovi, biramo onaj $f' \in \mathcal{F}$ koji ima najviše  elementima iz $U$ sa kojim ima neprazan presjek sve dok je $U \neq \emptyset$. Algoritam se izvodi u $O(|\mathcal{F}| \cdot |X|)$ vremenu, dakle  polinomijalnom. Takođe, jasno je da je rješenje koje se vraća dopustivo. Izračunajmo još aproksimativni faktor algoritma. Prije toga, označimo $d$-ti harmonijski broj $=H_d = \sum_{i=1}^d 1/i$ sa $H(d)$. 
Vrijedi sljedeća teorema.

%pseudokod algoritma 
\begin{algorithm}[!t] 
	\begin{algorithmic}[1]
		\STATE \textbf{Ulaz}: $X$ i familija podskupova $\mathcal{F}$ od $X$
		\STATE \textbf{Izlaz}: pokrivač skupa $X$
		\STATE $U \gets X$
		\STATE $C \gets \emptyset$
		\WHILE{$U \neq \emptyset$}
		\STATE $f \gets \mbox{argmax}_{f \in \mathcal{F}} |\{ f' \mid f' \in U  \wedge\ |f \cap f'| \geq 1\}| $
		\STATE $U \gets U \setminus f$
		\STATE $C \gets C \cup \{f\}$
		\ENDWHILE
	\end{algorithmic}
	\caption{GREEDY-SET-COVER metod za Problem Pokrivanja Skupa.}
    \label{alg:set-cover-gridi}
\end{algorithm}

\begin{thm}
	  GREEDY-SET-COVER algoritam ima aproksimacioni faktor 
	$$ H(\max\{|f| \mid f \in \mathcal{F}\}).$$
	
\end{thm}
\begin{proof}
	  Označimo sa $f_i$, $i$-ti podskup koji je selektovan od strane algoritma: algoritam dodjeljuje cijenu $1$ kad se $f_i$ doda u $\mathcal{C}$. 
	  Cijenu selektovanja $f_i$ distribuiramo podjednakom vjerovatnoćom na sve elemente koji su po prvi put pokriveni sa $f_i$. Posmatrajmo primjer dat na Slici~\ref{fig:set-cover-1}. U prvoj iteraciji pohlepnog algoritma,  
	  6 elemenata je pokriveno sa $T_1$; prema tome, cijena svakog od ovih elemenata je $c_x = \frac{1}{|T_1\setminus \emptyset|}= \frac{1}{6}$. Dalje, u drugoj iteraciji algoritam odabire skup $T_3$, koji pokriva 2 nova elementa; njihova cijena je $c_x=\frac{1}{|T_3 \setminus T_1|} = \frac{1}{2}$. U iteraciji broj 3, odabere se skup $T_2$, te se jedan novi element pokrije; njegova cijena je jednaka $c_x = \frac{1}{T_2 \setminus ( T_1 \cup T_3)}$. 
	 
	 Neka $ c_x$ označava cijenu za pokrivanje elementa $x\in X$.  Svakom elementu se cijena dodijeli najviše jednom, onog puta kada se pokrije po prvi put. Ako se $x$ pokriva prvi put sa $f_i$, tada imamo:
	 $$c_x = \frac{1}{f_i \setminus (f_1 \cup ...\cup f_{i-1})}.$$
	 
	 Algoritam generiše rješenje $\mathcal{C}$, koje je cijene $|\mathcal{C}|$ i ova cijena se raspoređuje elemenatima iz $X$. Kako optimalni pokrivač $C^*$ takođe pokriva skup $X$, dobijamo
	 \begin{align}\label{eq:f1x}
	 	|C| = \sum_{x \in X} c_x \leq \sum_{f \in C^*}\sum_{x \in f} c_x.
	 \end{align}
	  Pokazimo sljedeću ključnu nejednakost koja služi u dokazu ove teoreme. Za svaku $f \in \mathcal{F}$, vrijedi  
	 \begin{equation}\label{eq:f2x}
	 	\sum_{x \in f} c_x \leq H(|f|).
	 \end{equation}
	 
	 Iz formula~(\ref{eq:f1x}) i (\ref{eq:f2x}) bi dobili da je 
	 \begin{equation}
	 	|C| \leq \sum_{f \in C^*}\sum_{x \in f} c_x \leq \sum_{f \in C^*} H(|f|),
	 \end{equation}
	 odakle bi slijedila tvrdnja o vrijednosti aproksimacionog faktora algoritma.
	 Ostaje nam još da pokažemo formulu~(\ref{eq:f2x}). 
	 
	 Neka je $f\in \mathcal{F}$ tako da za $i=1,\ldots,|C|$
	 $$u_i(f) = |f \setminus (f_1 \cup \cdots \cup f_{i} )|$$
	 
	 označava ostale elemente u $f \in \mathcal{F}$ koji su još uvijek nepokriveni nakon što je algoritam dodao skupove $f_1,\ldots, f_i$ u pokrivač $C$ do $i$-te iteracije. Definišimo $u_0(f)=|f|$ za broj elemenata skupa $f$ koji je inicijalno nepokriven. 
	 Označimo sa $k$ prvi indeks tako da je $u_k(f)=0$  -- što znači da su svi elementi skupa $f$ u $k$-toj iteraciji
	 pokriveni prvi put nekim skupovima %$S_1,\ldots,S_i$
	 koji su odabranu u ranijim koracima algoritma. Primijetimo da vrijedi
	 $$ u_o(f) \geq u_1(f) \geq \ldots \geq u_{k-1}(f) \geq u_k(f).$$
	 Prema tome, $u_{i-1}(f) - u_{i}(f)$ predstavlja broj elemenata u skupu $f$ koji su pokriveni 
	 po prvi put sa $f_i$ u $i$-toj iteraciji za $i=1,\ldots,k$. Dakle, vrijedi
	 \begin{align}\label{eq:q1}
	 	\sum_{x \in f} c_x = \sum_{i=1}^k( u_{i-1}(f) - u_{i}(f)) \cdot \frac{1}{ f \setminus ( f_1 \cup \cdots \cup f_{i-1})},
	 \end{align}
 
   \noindent što je jednako sumi brojeva elemenata skupa $f$ pokriven sa $f_i$ pomnožen sa cijenom koja je dodjeljena svakom elementu u $i$-toj iteraciji. Primijetimo da vrijedi:
 \begin{align}\label{eq:q2x}
 	|f_i \setminus (f_1 \cup \cdots \cup f_{i-1})| \geq | f   \setminus (f_1 \cup \cdots \cup f_{i-1}) | := u_{i-1},
 \end{align}
 jer je $f_i$ pohlepni izbor (njegovim izborom pokrićemo čitav (nepokriveni dio) skupa $f_i$) u $i$-toj iteraciji i svaki drugi izbor ne može pokriti više novih (nepokrivenih elemenata). 
 
 Prema tome, iz jednakosti~(\ref{eq:f1x}), te nejednakosti~(\ref{eq:f2x}), slijedi 
 \begin{align*}
 	\sum_{x \in f} c_x \leq \sum_{i=1}^k ( u_{i-1} - u_{i}) \cdot \frac{1}{u_{i-1}}
 \end{align*}
 
 Izraz sa desne strane nejednakosti se može ograničiti na sljedeći način:
   \begin{align*}
 	   \sum_{i=1}^k ( u_{i-1} - u_{i}) \cdot \frac{1}{u_{i-1}} &= \sum_{i=1}^k \sum_{j=u_i + 1}^{u_{i-1}} \frac{1}{u_{i-1}} \leq \sum_{i=1}^k \sum_{j=u_i + 1}^{u_{i-1}}\frac{1}{j} \\
 	   &= \sum_{i=1}^k \left( \sum_{j=1}^{u_{i-1}}\frac{1}{j} - \sum_{j=1}^{u_{i}}\frac{1}{j} \right) \\
 	   &= \sum_{i=1}^k (H(u_{i-1}) - H(u_i)) \\
    	&= H(u_0) - H(u_k) = H(u_0) = H(|f|),
 \end{align*}
 
 odakle slijedi tvrđenje. 
 
\end{proof}

Napomenimo da postoji i težinska verzija Problema pokrivanja skupa. U ovoj verziji je svakom skupu iz $f \in\mathcal{F}$ data težina $w_f$. Zadatak je naći pokrivač $C \subseteq \mathcal{F}$ skupa $X$ sa najmanjom težinom. Ovaj problem na sličan način kao i ne-težinska varijanta može biti aproksimirana do na faktor $H_d= \log d+O(1)$, gdje je $d= \max\{|f|:f \in \mathcal{F}\}$ uz pomoć sličnog pohlepnog algoritma. U tom slučaju, pohlepni kriterij je određen funkcijom 
\begin{align}
	g(f) = \frac{w_f}{|f \cap U|}, f \in \mathcal{F}\setminus C,
\end{align}
gdje je $w_f$ težina skupa. U svakom koraku algoritma određuje skup $f^* \in \mathcal{F}$ koji minimizuje vrijednost funkcije $g$, koji se zatim dodaje u trenutni (parcijalni) pokrivač $C$.

\subsection{Aproksimativni algoritam za Problem Najkraćeg Nadstringa}


\begin{definition}
   Neka je dat skup stringova $S=\{s_1,...,s_n\}$. Problem najkraćeg nadstringa se pita za pronalazak stringa $s$ minimalne dužine koji sadrži sve stringove iz $S$ kao njegove podstrigove. 
  \end{definition}
Bez gubljenja opštosti, mozemo pretpostaviti da niti jedan string $s_i$ nije podstring stringa $s_j, i\neq j$.
Ovaj problem je NP--težak. Ideja je riješiti ga koristeći Problem pokrivanja skupa i 
njegove algoritame iz prethodne sekcije. Pokazaćemo da postoji $2\cdot H_n$--aproksimacija za problem najkraćeg nadstringa. 

 Svakom stringu $\theta$ dodijelimo skup $set(\theta)$ tako da   $set(\theta)$ pokriva string $s\in S$ akko 
je $s$ podstring od $\theta$. Prema tome 
$$set(\theta) = \{ s \in S \mid s \mbox{  podstring od }\theta \}.$$

 Odatle bi pokrivač skupa bila familija takvih skupova $set(\theta)$, iz kojih se konstruiše nadstring skupa $S$ spajajući sve $\theta$ stringove u jedan string. U svakom slučaju familija  $\mathcal{F}$ se ne može definisanti kao skup skupova $set(\theta)$ jer bi u suprotnom $\mathcal{F}$ bio beskonačan. Sa druge strane, ne možemo ograničiti sve stringove $\theta$ samo na one iz $S$, jer bi u suprotnom dobili rješenje koje je jednako konkatenaciji svih stringova iz $S$, što je svakako nekorisno rješenje. Za uspostavljanje balansa, neka iz skupa $S=\{s_1,...,s_n\}$ uzmemo par stringova $s_i$ i $s_j$, nađemo $k>0$  tako da je posljednjih $k$ karaktera stringa $s_i$ jednaka prvih $k$ karakera stringa $s_j$ (poklapanje). Označimo sa $\theta_{ijk}$ string koji se 
dobije preklapanjem stringova $s_i$ i $s_j$ na $k$ karaktera. Oznacimo sa $I$ skup strinova $\theta_{ijk}$  za validne izbore $i,j$ i $k$. Zatim definišemo $\mathcal{F}=\{set(\theta) \mid  \theta \in S \cup I\}$. Dodijeljena cijena svakog skupa $set(\theta))$ je jednaka $|\theta|$. Na osnovu prethodnog, dobijamo algoritam za rješavanje problema Najkraćeg nadstriga Algoritmom~\ref{alg:ss}. 

  \begin{algorithm}[!t] 
	\begin{algorithmic}[1]
		\STATE \textbf{Ulaz}: skup $S=\{s_1,...,s_n\}$
		\STATE \textbf{Izlaz}: aproksimacioni nadstring $s$
		\STATE Izračunati instancu $(X,\mathcal{F})$ problema najkraćeg nadstringa
		\STATE  $\mathcal{C}=\{set(\theta_1), set(\theta_2),...,set(\theta_p)\}\gets$ Primijeniti GREEDY-SET-COVER$(X,\mathcal{F})$
		\STATE  $s \gets \theta_1 \cdots \theta_p$
	\end{algorithmic}
	\caption{Gridi heuristika za Problem Najkraćeg Nadstringa.}
	\label{alg:ss}
\end{algorithm}

\emph{Analiza algoritma}. 

Ako je $\mathrm{OPT}_{ns}$ vrijednost optimalnog rješenja problema  nad instancom $(X,\mathcal{F})$ za problem  najkraćeg nadstringa, a $\mathrm{OPT}_{ss}$ dužina najkraćeg nadstringa, može se pokazati da vrijedi 
$$\mathrm{OPT}_{ns} \leq 2 \cdot \mathrm{OPT}_{ss}.$$

Iz prethodnog bi slijedilo da Algoritam~\ref{alg:ss} daje $2H_n$--aproksimaciju. 

\begin{comment}
  
  
  \section{Problem Pokrivanja Skupa: aproksimacioni algoritmi} 
 
  
 
   
  
  \section{Problem Najkraceg Nadstringa}
   
  
  Ideja za algoritam je svesti problem na problem pokrivanja skupa tako da je neophodno pokriti sve stringove iz $S$ da bi se ispunio uslov problema. 
  
  Svakom stringu $\theta$ dodijelimo skup $set(\theta)$ tako da skup $set(\theta)$ pokriva string $s\in S$ akko 
  je $s$ podstring od $\theta$. Prema tome 
  $$set(\theta) = \{ s \in S \mid s \mbox{  podstring od }\theta \}.$$
  
  Odatle bi pokrivac skupa bila familija takvih skupova $set(\theta)$, iz kojih se konstruise superstring skupa $S$ spajajuci sve $\theta$ stringove u jedan string. U svakom slucaju familija  $\mathcal{F}$ se ne moze definisanti kao skup skupova $set(\theta)$ jer bi u suprotnom $\mathcal{F}$ bio beskonacan. Sa druge strane, ne mozemo ograniciti sve stringove $\theta$ samo na $S$, jer bi u suprotnom dobili rjesenje koje je jednako konkatenaciji svih stringova iz $S$, sto je svakako nekorisno rjesenje. Za uspostavljanje balansa, neka iz skupa $S=\{s_1,...,s_n\}$ uzmemo par stringova $s_i$ i $s_j$, nadjemo $k>0$  tako da je posljednjih $k$ karaktera 
  stringa $s_i$ jednaka prvih $k$ karakera stringa $s_j$ (poklapanje). Oznacimo sa $\theta_{ijk}$ string koji se 
  dobije preklapanjem stringova $s_i$ i $s_j$ na $k$ karaktera. Oznacimo sa $I$ skup strinova $\theta_{ijk}$ 
  za validne izbore $i,j$ i $k$. Zatim definisemo $\mathcal{F}=\{set(\theta) \mid  \theta \in S \cup I\}$. Dodijeljena cijena svakog skupa $set(\theta))$ je jednaka $|\theta|$. Na osnovu prethodnog, dobijamo algoritam za rjesavanje problema Najkraceg Nadstriga pseudokodom~\ref{alg:ss}. 
  
  \begin{algorithm}[!t] 
  	\caption{Gridi heuristika za Problem Najkraceg Nadstringa.}\label{alg:ss}
  	\begin{algorithmic}[1]
  		\STATE \textbf{Ulaz}: skup $S=\{s_1,...,s_n\}$
  		\STATE \textbf{Izlaz}: aproksimacioni nadstring $s$
  		\STATE Izracunati instancu $(X,\mathcal{F})$ problema najkraceg nadstringa
  		\STATE  $\mathcal{C}=\{set(\theta_1), set(\theta_2),...,set(\theta_p)\}\gets$ Primijeniti GREEDY-SET-COVER$(X,\mathcal{F})$
  		\STATE  $s \gets \theta_1 \cdots \theta_p$
  	\end{algorithmic}
  \end{algorithm}
  
  Analiza algoritma. Ako je $\mathrm{OPT}_{ns}$ vrijednost optimalno rjesenje problema  nad instancom $(X,\mathcal{F})$ problema Najkraceg Nadstringa, a $\mathrm{OPT}_{ss}$ duzina najkraceg nadstringa, moze se pokazati da vrijedi 
  $$\mathrm{OPT}_{ns} \leq 2 \cdot \mathrm{OPT}_{ss}.$$
  
  Iz prethodnog bi slijedilo da Algoritam~\ref{alg:ss} daje $2H_n$--faktor aproksimaciju. 
  
 \end{comment} 
  
\section{Heurističke Metode}
 U prethodnom odjeljku smo vidjeli da za aproksimativne algoritme vrijedi važna osobina da se rješavanjem problema ne garantuje pronalazak optimalnog rješenja, ali postoji garancija da se rješenje nalazi unutar nekog faktora kvaliteta (c), u odnosu na optimalno rješenje. \fxnote{nije dobar izraz unutar faktora - ispraviti i gore}
 Drugim riječima, za rješenja dobijena aproksimativnim algoritmima se zna koliko maksimalno mogu da odstupaju od optimalnog rješenja, a to odstupanje je određeno faktorom kvaliteta.
 
 Posebna vrsta približnih metoda (metoda koje ne daju i/ili ne garantuju pronalazak optimalnog rješenja) su tzv. heurističke metode. 
 
 Za razliku od aproksimativnih algoritama, kod heurističkih metoda, u opštem slučaju, ne propisuje se faktor kvaliteta rješenja, već je primarni cilj razviti i primijeniti tehniku pomoću koje se u razumnom vremenu može doći do dovoljno dobrog (zadovoljavajućeg) rješenja. Heurističke metode mogu biti izvedene iz teorijskih razmatranja, ali i iz eksperimentalnih rezultata (na primjer, na osnovu rješavanja problema manjih dimenzija ili uopštavanjem tehnika uspješno primijenjenih na uzorcima). 
 
 
 Snaga heurističkih algoritama leži u smanjenju prostora pretraživanja i usmjeravanju procesa pretraživanja u one regione koji sadrže bolje rješenja, čime se značajno ubrzava proces pronalaženja rješenja. Naravno, ne postoji univerzalna strategija koja garantuje uspjeh heurističkog algoritma, tj. ne postoji garancija da će heuristički algoritam (uvijek) pronaći dovoljno dobro rješenje u razumnom vremenu. Ipak, višedecenijski razvoj i upotreba različitih heurističkih algoritama ukazuju na činjenicu da ove metode zauzimaju veoma važno mjesto u oblasti kombinatorne optimizacije, a njihova uspješna primjena u širokom spektru različitih problema dokazuje njihovu stvarnu upotrebnu vrijednost.
 
 
 Svaka heuristička metoda mora da zadovolji dva pravila: da je rešenje ``dovoljno
 dobro'' i da se algoritam pokrenut na ulazni problem izvršava u realnom vremenu. Treba napomenuti da se pod  ``dovoljno
 dobrim'' rješenjem podrazumijevaju različite procjene, koje mogu biti subjektivne (npr. zasnovane na ličnoj ili profesionalnoj procjeni stručnjaka koji razvija ili koristi metodu), objektivne (npr.  rješenje je dobro ako od optimalnog rješenja odstupa u dozvoljenim granicama) ili zavisne od drugih uslova (na primjer, traži se rješenje problema takvo da je ono ekonomski prihvatljivo, bez obzira na to da li je blizu optimalnog rješenja ili ne). 
 Za neke metode, kvalitet dobijenog rješenja je moguće utvrditi samo eksperimentalno, na primjer, poređenjem sa rješenjima dobijenim uz pomoć drugih metoda. Nekada je cilj heurističke metode samo da se pronađe jedno dopustivo rješenje, dok se u kvalitet samog rješenja uopšte i ne ulazi.
 
 Važna osobina dobro konstruisanih heurističkih metoda je mogućnost prevazilaženja lokalnog ekstrema (što nije slučaj sa pohlepnim algoritmima), u cilju dostizanja globalnog optimalnog rješenja. 
 
 Takođe, heurističke metode se često uspešno mogu integrisati i u egzaktne metode, čime se kombinuje brzina dobijanja rješenja i potvrđivanje optimalnosti.
 
 \section{Metaheurističke metode}
 
 Široku klasu heurističkih metoda čine tzv. ``univerzalne'' heurističke metode, koje se, uz blage modifikacije i prilagođavanje, mogu koristiti za rješavanje više različitih problema. Takve metode nazivamo metaheurističkim metodama, ili metaheuristikama.  
 
 Metaheuristika se formalno definiše kao iterativni proces koji koristi približne metode, kombinujući na inteligentan način različite koncepte za pretraživanje i iskorištavanje čitavog prostora rješenja, da bi se u razumnom vremenu, na efikasan način, odredilo rješenje što bliže optimalnom.
 
 Sa praktičnog, upotrebnog aspekta, cilj metaheuristika je pretraživanje skupa dopustivih rješenja, pri čemu je (ukoliko je potrebno) dozvoljeno i proširenje tog skupa i elementima koji nisu dopustivi, prelazak u rješenja slabijeg kvali\-teta kako bi se izbjegli lokalni optimumi koji nisu i globalni, kombinovanje sa drugim heuristikama itd.
 
 \subsection{Klasifikacija metaheuristika}
 S obzirom na veliki broj raznih metaheuristika koje su se razvile u posljednje vrijeme, prirodno je očekivati da se za  njihov razvoj koriste vrlo različiti pristupi, počev od polazne motivacije, preko strategije pretraživanja, različitih namjena i klasa problema na kojima se primjenjuju.
 U savremenoj literaturi, sreće se nekoliko kriterijuma za klasifikaciju metaheuristika.
 
 Klasifikacija metaheuristika prema polaznoj motivaciji identifikuje tzv. metaheuristike zasnovane na simulaciji prirodnih pojava (eng. nature based metaheuristics), kao što su na primjer genetski algoritmi, mravlje ili pčelinje kolonije ili elektromagnetizam. Nasuprot njima, veliki broj metaheuristika nije motivisan prirodnim procesima (na primjer, tabu pretraživanje, iterativna lokalna pretraga itd.)
 
 Prema broju tačaka kojima se raspolaže unutar jedne iteracije, metaheuristike se dijele na dvije klase: metaheuristike zasnovane na populaciji (eng. population based) i metaheuristike koje rade sa jednom tačkom unutar jedne iteracije (eng. single point search). U prvoj klasi, u istom trenutku algoritam raspolaže sa više tačaka -- različitih rješenja problema. Pretraživanje prostora je zasnovano na primjeni različitih operatora rekombinovanja, pomjeranja, izmjena i odabira pojedinih tačaka, kako bi se u svakoj novoj iteraciji formirala nova populacija, sa potencijalno boljim jedinkama. Takve metaheuristike su: genetski algoritmi, mravlje kolonije, elektromagnetizam, jata ptica itd.
 U metaheuristikama koje raspolažu jednom tačkom, primjenjuje se strategija zasnovana na praćenju trajektorije (eng. trajectory methods), koji podrazumijeva da se kroz iteracije formira niz rješenja, od kojih je svako naredno (po pravilu, ali ne i obavezno) bolje od prethodnog. Ovi algoritmi najčešće, (ali opet ne i obavezno) koriste i neke metode lokalnog pretraživanja, gdje se novo, potencijalno bolje rješenje bira unutar neke okoline trenutnog rješenja. Neke od metoda koje pripadaju ovoj klasi su metoda promjenljivih okolina, tabu pretraživanje, simulirano kaljenje itd.
 
 Prema tipu funkcije cilja, može se napraviti klasifikacija na one metaheuristike koje koriste statičku, te one koje koriste dinamičku funkciju cilja.
 
 Neke od najčešće korištenih metaheuristika su:
 \begin{itemize}
 	\item pohlepni algoritam sa prilagođenom slučajnom pretragom (eng. Greedy randomized adaptive search procedure - GRASP);
 	\item tabu pretraživanje (eng. Tabu search - TS);
 	\item genetski algoritam (eng. Genetic algorithm - GA);
 	\item metod promjenljivih okolina (eng. Variable neighborhood search – VNS);
 	\item simulirano kaljenje (eng. Simulated annealing - SA);
 	\item mravlje kolonije (eng. Ant colony optimization - ACO);
 	\item pčelinje kolonije (eng. Artificial Bee Colony - ABC);
 	\item elektromagnetizam (eng. Electromagnetism - EM);
 	\item upravljano lokalno pretraživanje (eng. Guided Local Search - GLS).
 \end{itemize}


\subsection{Genetski algoritmi}\label{intro:ga}


Genetski algoritmi spadaju u klasu populacionih i evolucijskih algoritama, čije je ponašanje inspirisano procesom evolucije koji se odvija u prirodi.
Kao što je već rečeno, u osnovi se podrazumijeva rad sa populacijom jedinki, gdje svaka jedinka predstavlja potencijalno rješenje polaznog problema, dok je populacija  podskup ukupnog prostora pretraživanja. Populacija se u iterativnom postupku mijenja tako što se stare jedinke mijenjaju novim, potencijalno boljim jedinkama.

Osnovni okvir za funkcionisanje geneskih algoritama je dat od strane Džona Holanda, u radu ``Adaptation in natural and artificial system''.

Svakoj jedinki se dodjeljuje brojevna vrijednost, tzv. prilagođenost (engl.  fitness), koja ocjenjuje kvalitet posmatrane jedinke. Cilj genetskog algoritma je da se iz iteracije u iteraciju pronalaze jedinke sa sve boljom prilagođenošću, pod čime se smatra i pojedinačno poboljšanje svake jedinke, ali i prosječna prilagođenost kompletne populacije, što se postiže standardnim genetskim operatorima: selekcijom, ukrštanjem i mutacijom.

Populacija je centralna struktura kod genetskog algoritma i ona  obično broji od nekoliko, pa do nekoliko stotina jedinki (u rijetkim situacijama i do hiljadu). Svaka jedinka se predstavlja genetskim kodom, koji se zapisuje u nekoj konačnoj azbuci (najčešće binarnoj ili pak cjelobrojnoj).


Početna populacija se obično kreira na slučajan način, čime se omogućava kreiranje raznovrsnog genetskog materijala, korisnog za kasnije faze algoritma i raznovrsnost samih jedinki. U nekim slučajevima se za generisanje polaznih jedinki koristi i neka druga heuristika, čime se pretraga od početka usmjerava ka onim oblastima pretraživanja za koje se pretpostavlja da sadrže kvalitetnija rješenja.

Tokom rada algoritma, na populaciju se primjenjuju genetski operatori selekcije, mutacije i ukrštanja. Pored ovih osnovnih operatora, na neke jedinke se mogu primijeniti i drugi operatori, čijom se primjenom teži ka poboljšanju rješenja (na primjer, na jedinke sa boljom prilagođenošću se mogu primijeniti i tehnike lokalnog  pretraživanja).

Operator selekcije bira jedinke koje preživljavaju u procesu evolucije. Po pravilu, boljim jedinkama (jedinkama sa boljom prilagođenošću) se operatorom selekcije daje veća vjerovatnoća da će preživjeti u narednu generaciju, dok  slabije jedinke selekcijom dobijaju manju šansu da prežive, te se tako izbacuju iz populacije. Postoji veći broj tehnika selekcije, a najpoznatije su: jednostavna (ili rulet) selekcija, turnirska, eliminacijska selekcija i elitizam. Rulet selekcija diktira da je vjerovatnoća da će jedinka preživjeti u narednu generaciju proporcionalna prilagođenosti. Kod turnirske selekcije se formiraju skupovi jedinki, od kojih samo ona sa najboljom prilagođenošću preživljava u sljedeću generaciju. Eliminacijska selekcija je primarno zasnovana na izbacivanju loših jedinki, prije nego na odabiru boljih za narednu generaciju. Elitizam podrazumijeva da će nekoliko najboljih (elitnih) jedinki direktno preći u narednu generaciju, čime se daje pouzdana pretpostavka da  algoritam teži globalnom optimumu.

Ukrštanjem se rekombinuju geni jedinki. Rezultat ukrštanja jedinki su nove jedinke, koje potencijalno sadrže ``dobre'' gene  roditelja od kojih su nastale. Ovim mehanizmom  i jedinke slabije prilagođenosti, ali koje sadrže dobre gene, dobijaju šansu da učestvuju u reprodukciji i prenesu ``dobar'' genetski materijal na sljedeću generaciju. Najčešće korišteni operatori ukrštanja su tzv. jednopoziciono, odnosno dvopoziciono ukrštanje, kod kojih se određuje jedna, odnosno dvije tačke prekida na kojima se odvija razmjena genetskih kodova roditelja, respektivno.

Mutacijom se vrši slučajna promjena određenog gena (sa nekom malom vjerovatnoćom da će se mutacija desiti), čime se postiže mogućnost vraćanja dobrog genetskog materijala, ukoliko je on izgubljen primjenom operatora selekcije i ukrštanja. Time se proces pretrage izvlači iz preuranjene konvergencije i usmjerava ka onim oblastima pretraživanja koje sadrže potencijalno bolje jedinke.


Nakon primjene genetskih operatora, formira se naredna generacija. Populacija se tako sastoji od potomaka i nekih starijih jedinki koje su preživjele s obzirom na njihov kvalitet (elitne jedinke). Produkcija novih generacija se nastavlja sve dok ne budu ispunjeni uslovi za završetak algoritma. Najčešći kriterijumi za završetak algoritma su dostignuto maksimalno vrijeme izvršenja, dostignut  maksimalan ukupan broj iteracija, ili dostignut maksimalan broj iteracija bez poboljšanja najboljeg rješenja.

Osnovna šema funkcionisanja genetskog algoritma je prikazana Algoritmom \ref{alg:gascheme}.

$N_{pop}$ označava ukupan broj jedinki u populaciji.  $N_{elite}$ je broj elitnih jedinki, dok sy promjenljivima  $i$ i $obj_{i}$ predstavljene jedinke i odgovarajuća vrijednost funkcije cilja.
%\begin{figure}[htp]
%	\centering
%	\includegraphics[width= 0.8\textwidth]{gasrp2.eps} \caption {Osnovna šema GA algoritma}\label{fig:gascheme}
%\end{figure}

\begin{algorithm}
	\begin{algorithmic}[1]
		 \STATE  $ P \gets GenerisiInicijalnuPopulaciju()$
		 \WHILE{!$IspunjenKriterijZaustavljanja()$}
		       \FOR{$i=N_{elite}+1; i<N_{pop}; ++i$}
		            \STATE $Obj_i \gets RacunajFunkcijuCilja(P_i)$
		       \ENDFOR
		       \STATE $RacunajFunkcijuPrilagodjenosti(P)$
		       \STATE $IzvrsiSelekciju(P)$
		       \STATE $IzvrsiMutaciju(P)$
		       \STATE $IzvrsiUkrstanje(P)$
		 \ENDWHILE
	\end{algorithmic}
    \caption{Osnovna šema GA.}
    \label{alg:gascheme}
\end{algorithm}



\emph{Primjer}. U ovom primjeru posmatrajmo 0-1 problem ruksaka. Ponovimo da nam je, kod ovog problema, na raspolaganju određen broj proizvoda, od kojih svaki proizvod ima svoju vrijednost i težinu. Ruksak je ograničenog maksimalnog kapaciteta (težine) $C$. Podsjetimo se i da se u 0-1 problemu ruksaka svaki proizvod ili ne uzima nikako ili se uzima čitav. Cilj je, kao i u drugim problemima ruksaka, odabrati onaj skup proizvoda, tako da je njihova ukupna vrijednost maksimalna, a da se ne naruši kapacitet ruksaka.

Formalna matematička definicija 0-1 problema ruksaka će nam pomoći u konstrukciji genetskog algoritma, pa ćemo je ovdje navesti.

Neka je dato $n$ proizvoda, koji su opisani pomoću nizova $p$ i $w$. $p_i$ i $w_i$ predstavljaju vrijenost i težinu $i$-tog proizvoda. Neka je $C$ maksimalan kapacitet ruksaka.

Neka je $f(\cdot)$ funkcija koja se maksimizuje i neka je $x$ binarni niz dužine $n$ koji predstavlja jedno rješenje problema: ako je $i$-ti proizvod uključen u rješenje, tada je $x_i = 1$, u protivnom, $x_i =0$. 0-1 problem ruksaka se definiše kao

$$\max \{f(x)\} = \max \{\sum_{i=1}^{n}x_ip_i\}$$
s.t.
$$\sum_{i=1}^{n}x_iw_i\leqslant C$$
$$x_i\in\{0,1\}, i = 1,2,...,n$$

Konstrukciju elemenata genetskog algoritma ćemo prikazati služeći se konkretnim primjerom. U tabeli su prikazani polazni podaci vezani za proizvode, a maksimalan kapacitet rukasaka je 22. 

\emph{Kodiranje}. Genetski kod svake jedinke ćemo prikazati binarnim nizom dužine $n$ (u primjeru je $n=7$). Tako, na primjer, genetski kod 1100100 označava da su proizvodi pod rednim brojem 1, 2 i 5 uključeni u ruksak, dok ostali proizvodi nisu uključeni u ruksak. Vrijednost funkcije cilja za ovo rješenje je 5+8+7=20, dok je ukupna težina 7+8+4 = 19. 
Primijetimo da ovakav sistem kodiranja može da dovede do nedopustivih rješenja. Na primjer, genetski kod 0101010 označava da su proizvodi pod rednim brojem 2, 4 i 6 uključeni u rješenje, čija je ukupna težina 8+10+6 = 24, što je više od maksimalnog kapaciteta ruksaka.

Treba napomenuti da se u rješavanju velikog broja problema kombinatorne optimizacije pomoću genetskih algoritama (ali i drugih heurističkih metoda) često dozvoljava rad sa nedopustivim rješenjima. Razlog za to leži u činjenici da nisu sva nedopustiva rješenja ``podjednako loša'', a nekada je lakše popraviti nedopustivo rješenje u dopustivo rješenje visokog kvaliteta, nego vršiti pretragu samo na prostoru dopustivih rješenja slabijeg kvaliteta.  Zbog toga se za prevazilaženje pojave nedopustivih rješenja najčešće koristi jedna od sljedeće dvije strategije: 
\begin{itemize}
	\item
	nedopustiva rješenja (po automatizmu) dobijaju minimimalnu vrijednost funkcije prilagođenosti, čime se omogućava da sam genetski algoritam odbaci takva rješenja u procesu selekcije. 
	
	\item uvodi se tzv. kaznena funkcija, (eng. penalty function), kojom se ``kažnjavaju'' nedopustiva rješenja (najčešće smanjenjem vrijednosti funkcije prilagođenosti), ali se ona ne izbacuju iz razmatranja, u nadi da perspektivnija nedopustiva rješenja mogu prerasti u kvalitetna dopustiva rješenja.
\end{itemize}

U našem primjeru, pojavu nedopustivih rješenja, dakle, možemo riješiti automatskom dodjelom minimalne vrijednosti funkcije prilagođenosti, ili ``kažnjavanjem'' takvih rješenja smanjenjem vrijednosti funkcije fitnesa. Neke od strategije za ``kažnjavanje'' nedopustivih jedinki bi mogle biti zasnovane na procjeni broja proizvoda koje treba zamijeniti (ili izbaciti) iz datog rješenja, a da rješenje postane dopustivo. Na taj način bi se ona nedopustiva rješenja, koja se teže mogu popraviti u dopustiva, više kažnjavala (i samim tim češće i odbacivala), dok bi se perspektivnija nedopustiva rješenja zadržavala u populaciji, u nadi da će, primjenom nekog od genetskih operatora, prerasti u kvalitetna dopustiva rješenja. Uopšte, vrijednost kaznene funkcije bi trebalo da bude malo veća nego minimalna cijena potrebna da se odgovarajuće nedopustivo rješenje ``popravi'' na dopustivo. Suprotno, ako bi vrijednost kaznene funkcije bila manja od cijene minimalne korekcije, nedopustiva rješenja se mogu javiti kao konačno rješenje, što naravno nije dopušteno. Sa druge strane, ako je vrijednost kaznene funkcije značajno veća od cijene minimalne popravke, nedopustiva rješenja su u totalno diskriminisana i algoritam ih u startu odbacuje. 

\emph{Računanje funkcije prilagođenosti}. Za posmatrani problem, najprirodnija fukcija prilagođenosti bi se mogla definisati na način da ona bude jednaka ukupnom zbiru vrijednosti proizvoda uključenih u rješenje (pod uslovom da je to rješenje dopustivo), a da je vrijednost funkcije prilagođenosti  nedopustivih rješenja   jednaka nuli. 
Imajući u vidu prethodno razmatranje o nedopustivim rješenjima, funkcija prilagođenosti može biti definisana i drugačije, tj. mogla bi da sadrži i dio vezan za  ``kažnjavanje'' nedopustivih rješenja, po nekom od predloženih (ili drugih) principa. Time bi nedopustiva rješenja bila uključena u pretragu.

\emph{Operator ukrštanja}. Kao što je već pomenuto, osnovni operatori ukrštanja su tzv. jednopoziciono i dvopoziciono ukrštanje. Na našem primjeru ćemo objasniti  jednopoziciono ukrštanje, koje bi moglo biti realizovano na sljedeći način:
\begin{table}[H]
	\centering

\begin{tabular}{ccccc}
              &	Prije ukrštanja: &    &  Poslije ukrštanja:   \\
   Jednika 1: &	XXX $\mid$ XXXX  &    &   XXXYYYY             \\
   Jedinka 2:&	YYY $\mid$ YYYY  &    &   YYYXXXX             \\
\end{tabular}
	\caption{Primjer operatora ukrštanja: jednopoziciono ukrštanje.}
\end{table}
U ovom generičkom primjeru možemo vidjeti jednopoziciono ukrštanje u pozicijama $(3, 3).$  Specifičnije, pretpostavimo da imamo dva rješenja (jedinke) konstruisane u algoritamskom procesu: 1100100 i 0100011. Na osnovu jednopozicionog ukrštanja, one produkuju dva nova rješenja (dva potomka), tako što se lijevi dio genetskog koda prvog roditelja spaja sa desnim dijelom genetskog koda drugog roditelja i obrnuto, lijevi dio genetskog koda drugog roditelja se ukršta sa desnim dijelom prvog roditelja. 
Treba napomenuti da se primjenom ovakvog operatora ukrštanja takođe mogu dobiti potomci koji su nedopustive jedinke (bez obzira na to da li su jedinke roditelja dopustive ili ne), a njihova dalja egzistencija u populaciji ponovo zavisi od načina konstruisanja funkcije prilagođenosti. 

Kod dvopozicionog ukrštanja postoje dvije pozicije u svakoj od jedinki na osnovu kojih se radi ukrštanje. Generička procedura ovakvog ukrštanja je data sljedećom tabelom: 
\begin{table}[H]
	\centering
	
	\begin{tabular}{ccccc}
		&	Prije ukrštanja: &    &  Poslije ukrštanja:                         \\
		Jednika 1: &	XXX $\mid$ XXXX $\mid$ XX  &    &   XXXYYYYXX             \\
		Jedinka 2 :&	YYY $\mid$ YYYY $\mid$ YY  &    &   YYYXXXXYY             \\
	\end{tabular}
	\caption{Primjer operatora ukrštanja: dvopoziciono ukrštanje.}
\end{table}

U ovom primjeru ukrštanje je izvedeno u pozicijama $(3,7)$ prve jedinke i pozicijama $(3, 7)$ druge jedinke. Kao i kod jednopozicionog ukrštanja i ovdje je moguće da novonastale jedinke ne budu dopustive. 

Kod uniformnog ukrštanja, za svaki par jedinki koje se ukrštaju, prvo se generiše maska na slučajan način, tj. binarni niz dužine genetskog koda jedinki. Ukoliko je na poziciji $i$ generisane maske vrijednost 1, onda prvi potomak za $i$-ti gen uzima vrijednosti prve jedinke, dok je $i$-ti gen druge jedinke vrijednost $i$-tog gena druge jedinke. Inače, vrijedi obrnita situacija. Jedan primjer ovakvog ukrštanja je data sljedećom tabelom: 

\begin{table}[H]
	\centering
	
	\begin{tabular}{cc}
		Maska:      &   110001100   \\
		Jednika 1:  &	XXXXXXXXX   \\ 
		Jedinka 2 : &	YYYYYYYYY   \\
		Poslije ukrštanja:  &       \\ \hline
		            &  XXYYYXXYY    \\
		            &  YYXXXYYXX    \\
	\end{tabular}
	\caption{Primjer operatora ukrštanja: uniformno ukrštanje.}
\end{table}


\emph{Mutacija}. Kao što je pomenuto, mutacije podrazumijevaju male promjene u genetskom kodu, čija je osnovna namjena izlazak iz lokalnih suboptimalnih rješenja i omogućavanje dalje pretrage u cilju pronalaženja boljih rješenja. Najčešće se mutacija realizuje kao promjena vrijednosti jednog gena. U našem slučaju, u zavisnosti od drugih elemenata algoritma, mogao bi se konstruisati veći broj različitih operatora mutacije: 
\begin{itemize}
	\item Mutacija 1: prelazak neke nule u jedinicu. Ova mutacija bi modifikovala trenutnu jedinku na način da se neki proizvod, koji nije bio u rješenju, uključi u rješenje. Time bi se povećala ukupna vrijednost ruksaka, ali postoji opasnost da jedinka postane nedopustiva.
	\item  Mutacija 2: prelazak neke jedinice u nulu. Ova mutacija bi modifikovala trenutnu jedinku na način da se neki proizvod, koji je bio u rješenju, isljuči iz rješenja. Ovo bi dovelo do smanjenja ukupne vrijednosti ruksaka, ali bi, u slučaju rada sa nedopustivim jedinkama, postojala mogućnost da nedopustivo rješenje postane dopustivo (ili da se poboljša kvalitet nedopustivog rješenja).
	\item  Mutacija 3: dva gena različitih vrijednosti mijenjaju svoje vrijednosti. Preciznije, biraju se dva gena, od kojih jedan ima vrijednost 0, a drugi ima vrijednost 1, te prvi gen mijenja vrijednost na 1, a drugi na 0. Time se postiže da se, simultano, jedan proizvod, koji nije bio u rješenju, uključuje u rješenje, a drugi proizvod, koji je prije mutacije bio u rješenju, sada izbacuje iz rješenja. Kao i u prethodnim slučajevima, i ovdje je, na sličan način, potrebno razmatrati potencijalnu nedopustivost novonastale jedinke.
\end{itemize}

\begin{table}[H]
	\centering
	\begin{tabular}{lc}
		Maska:  & 10001000100  \\
		Jedinka: & 11001001000  \\
		Nakon mutacije &       \\
		               & 01000001100      \\
	\end{tabular}	
	\caption{Primjer operatora mutacije (uniformno mutiranje)}
\end{table}

\emph{Operator selekcije}. Da bismo ilustrovali princip rada najjednostavnije rulet selekcije, naprije pretpostavimo da je funkcija prilagođenosti jednaka vrijednosti funkcije cilja. Dalje, posmatrajmo populaciju od 4 jedinke, prikazane u Tabeli~\ref{tab:rulet}.

\begin{table}
	\centering
	\begin{tabular}{l|rrrrrrrrr}
		& \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{fitnes} & \multicolumn{1}{l}{težine}  \\\hline
		Jedinka1 & 1                    & 0                    & 0                    & 0                    & 0                    & 1                    & 1                    & 18                         & 17                          \\
		Jedinka2 & 0                    & 0                    & 0                    & 0                    & 0                    & 1                    & 0                    & 9                          & 6                           \\
		Jedinka3 & 0                    & 1                    & 0                    & 1                    & 1                    & 0                    & 0                    & 17                         & 22                          \\
		Jedinka4 & 0                    & 1                    & 0                    & 0                    & 1                    & 1                    & 1                    & 28                         & 22      \\\hline                   
	\end{tabular}\caption{Primjer korišten za ilustraciju upotrebe rulet selekcije}
	\label{tab:rulet}
\end{table}
Ukupan fitnes svih jedinki (zbir vrijednosti funkcija prilagođenosti svih jedinki) iznosi 72. Vjerovatnoće da će jedinke preživjeti u sljedeću generaciju jednake su redom: $\frac{18}{72},\ \frac{9}{72},\ \frac{17}{72}$ i $\frac{28}{72}$. 

Treba napomenuti da, iako se rulet selekcija na prvi pogled čini pogodnom za odabir jedinki koje preživljavaju u sljedećoj generaciju, ona ima i značajne nedostatke. Ovom selekcijom se jedinke sa slabom vrijednošću funkcije cilja često prerano odbacuju, iako možda sadrže potencijalno dobre gene, koji bi ukrštanjem sa drugim jedinkama mogli proizvesti još bolje potomke. Dalje, u kasnijim fazama algoritma, kada se javi više kvalitetnih jedinki koje imaju približno iste (ali ipak različite!) vrijednosti funkcije prilagođenosti, vjerovatnoće da će takve jedinke preživjeti su približno jednake, što dovodi do opasnosti da, nakon selekcije, najbolje jedinke i ne prežive u narednu generaciju. Stoga se u praksi značajno češće koristi turnirska selekcija, kojom se prevazilaze nedostaci rulet selekcije.


Na kraju ovog odjeljka treba pomenuti da je višedecenijska primjena genetskih algoritama u rješavanju velikog broja problema kombinatorne optimizacije dovela je do pojave velikog broja različitih varijanti algoritma, koje se, između ostalog, razlikuju po operatorima koji se primjenjuju, načinu formiranja početne populacije, primjenama različitih strategija lokalnog pretraživanja, tehnike keširanja međurezultata itd. 

 
\subsection{Lokalna Pretraga}\label{sec: local_search}

Lokalna pretrage je tehnika čija se strategija sastoji u izvođenju niza poboljšanja rješenja počevši od nekog unaprijed zadanog rješenja. Uvedimo prvo koncept okolina i lokalnih optimalnih rješenja kao baznih pojmova u algoritmu lokalne pretrage. Za dato rješenje $x$, definišimo skup (obično dopustivih) rješenja koja su ``blizu'' $x$ u odnosu na neku mjeru. Formalno, okolina predstavlja mapiranje  $\mathcal{N}$ gdje svakom (dopustivom) rješenju pridružujemo skup rješenja, koje zovemo okolina od $x$.  Funkcija okoline se takođe može definisati preko operatora  $\Delta$, koji predstavlja kolekciju   funkcija $\Delta:\Phi \mapsto \Phi$,  gdje je $\Phi$ prostor pretrage (rješenja) razmatrane instance, na sljedeći način:
$$ x' \in \mathcal{N}(x) \Longleftrightarrow \exists \delta \in \Delta,\delta(x)=x'.$$
 
Prirodan izbor u mnogim aplikacijama je $k$-promijenjena (eng. \emph{k-exchange}) okolina: $x$ i $x^{'}$ pripadaju istoj okolini akko se razlikuju na tačno $k$ komponenti rješenja. Npr. za TSP problem, 2-promijenjena okolina je prirodan izbor gdje su komponente rješenja grane datog grafa.  

  
Rješenje $x$ je \emph{lokalni optimum} u odnosu na okolinu $\mathcal{N}$ akko
$f(x) \leq f(x')$ ($f(x) \geq f(x')$), za sve $x' \in \mathcal{N}(x)$, ako minimizujemo (maksimizujemo) u odnosu na ciljnu funkciju $f$.  \emph{Globalni optimum} je rješenje koje je lokalni optimum u odnosu na bilo koju okolinu.  Imajte na umu da nije svaki lokalni optimum ujedno i globalni. 

\begin{algorithm}[!t] 
	\caption{Lokalna pretraga (maksimizacija)}\label{alg:ls}
	\begin{algorithmic}[1]
		\STATE \textbf{Ulaz:} instanca problema, okolina $\mathcal{N}$
		\WHILE{$ \left\{ x' \ni \mathcal{N}(x) \mid f(x') > f(x)\right\} \neq \emptyset$}
		\STATE $ x \gets  \text{ izaberi } x' \in \mathcal{N}(x) $ ako vrijedi  $f(x') > f(x)$ 
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

Pseudokod lokalne pretrage je dat u Algoritmu~\ref{alg:ls}. Ulaz u algoritam je instanca probelam i jedna okolona. U svakoj iteraciji, lokalna pretraga poboljšava trenutno (najbolje) rješenje ako je rješenje u okolini  $\mathcal{N}(x)$ ima bolju vrijednost ciljne funkcije. Algoritam se prekida ako je trenutno rješenje lokalno najbolje u odnosu na okolinu   $\mathcal{N}$.
 Postoje dvije strategije za izbor rješenja koje će zamijeniti trenutno najbolje rješenje pod pretpostavkom da postoji više od jednog rješenja sa boljom vrijednosti ciljne funkcije u posmatranoj okolini. Te strategije su:
 \begin{itemize}
 	\item \emph{prvo poboljšanje} (eng. the first imprvement) -- ova strategija prihvata prvo nađeno rješenje $x'$ u okolini $\mathcal{N}(x)$ koje poboljšava $x$. Pretraga se tada seli u tačku  $x = x'$, odakle se pokreće nova iteracija lokalne pretrage.
 	\item \emph{najbolje poboljšanje} (eng. the best improvement) --   ova strategija provjerava sva rješenja iz okoline $\mathcal{N}(x)$ i za novo najbolje rješenje bira ono koje je lokalno najbolje u toj okolini. Nalazak ovog  najboljeg rješenja zahtjeva enumeraciju svih rješenja iz okoline pa često ovakav proces u praksi traje dosta dugo,  tako da ona nije uvijek primjenjiva. U praksi se ipak pokazalo da  je čest slučaj da strategija \emph{najboljeg poboljšanja} vodi ka lokalnom optimumu problema u svega nekoliko iteracija lokalne pretrage. 
 \end{itemize}
  
  \emph{Primjer.} U   problemu 0-1 ruksaka, za okolinu $\mathcal{N}$ bi mogli uzeti $1$-\emph{swap} okolina. Recimo, za $n=4$ i rješenje $x=1100$ imali  bismo $$\mathcal{N}(x)= \{ 0100, 1000, 1110, 1101 \}.$$ 
  
\subsection{Metoda promjenljivih okolina}\label{intro:vns}
Metoda promjenljivih okolina je metaheuristika uvedena od strane Nenada Mladenovića i Pjera Hansena devedesetih godina prošlog vijeka.
Pretraga je zasnovana na sistematskoj promjeni okolina da bi se izbjegle situacije kada algoritam ``upada'' u suboptimalna rješenja. Efikasnost VNS algoritma je zasnovana na razmatranju da u mnogim praktičnim optimizacionim problemima postoji veza između lokalnih minimuma. Stoga metod promjenljivih okolina i ne prati unaprijed zadatu putanju, već ``skače'' na potencijalno bolja rješenja koja se nalaze u nekoj okolini trenutno najboljeg.
Na ovaj se način očuvavaju dobre osobine trenutnog rješenja (ako su neke promjenljive već dostigle optimalne vrijednosti), dok se u novim okolinama pokušavaju poboljšati preostale promjenljive. Ovaj sistem je dodatno ojačan sistemom lokalnog pretraživanja, kojim se prelazi iz trenutnog rješenja u najkvalitetnije rješenje u nekoj njegovoj okolini.

Ponovimo da algoritam zasnovan na metodi promjenljivih okolina raspolaže jednom tačkom u jednoj iteraciji (a ne populacijom tačaka kao što je to slučaj sa genetskim algoritmom).

Tako, ideja da se pretraga usmjeri sa jednog na (moguće bolji) drugi minimum koji je smješten u nekoj okolini polaznog minimuma predstavlja razuman  i, kao što je to slučaj u velikom broju raznih optimizacionih problema, opravdan pristup.
Da bi se postigli pomenuti efekti ``izlaska'' iz lokalnog suboptimuma, kao i detaljno pretraživanje nove okoline trenutnog najboljeg rješenja, metoda promjenljivih okolina se najčešće realizuje pomoću dvije važne procedure: procedure razmrdavanja (engl. shaking) i procedure lokalnog pretraživanja (engl. local search). Kao i što je to slučaj sa svim metaheurističkim metodama, dugogodišnja primjena metode promjenljivih okolina na rješavanje različitih problema dovela je do pojave velikog broja različitih varijanti, koje, pored osnovnih metoda razmrdavanja i lokalnog pretraživanja, uključuju u mnoge druge strategije.

Da bi se proširila pretraga,  VNS u potrazi za boljim lokalnim minimumom obično koristi okoline rastuće kardinalnosti. Da bi se definisao skup okolina, pretpostavimo da je $x$ proizvoljno rješenje i $N_k$, za $k=k_{min},\ldots,k_{max}$, konačan skup struktura okolina. Tada se  $N_k(x)$ definiše kao skup rješenja u $k$-toj okolini tačke $x$. 
Način funkcionisanja ove metode prikazan je Algoritmom~\ref{alg:vns}. 


U svakom koraku algoritma, VNS započinje od nekog rješenja $x$ i cijelog broja $k$, $k_{min}\leqslant k\leqslant k_{max}$, koji označava trenutnu okolinu $N_k$. U proceduri razmrdavanja
se na slučajan način bira rješenje  $x'$ iz okoline  $N_k(x)$. Zatim se na to rješenje primjenjuje procedura lokalnog pretraživanja. Najbolje rješenje koje se dobije u lokalnom pretraživanju se dalje poredi sa trenutno najboljim rješenjem i ukoliko je ono bolje od trenutno najboljeg rješenja, ono se proglašava najboljim rješenjem i algoritam nastavlja sa daljim izvršenjem. Postoje različite strategije kada algoritam prelazi u narednu okolinu (u proceduri razmrdavanja), kao i kada se okoline ``resetuju'', tj. kada se algoritam vraća na razmatranje najmanje okoline. 

Najčešći kriterijumi za prekid algoritma algoritma su: dostignuto maksimalno  vrijeme, dostignut maksimalan broj iteracija, maksimalni broj iteracija između dva poboljšanja ili maksimalan broj ponavljanja najboljeg rješenja.

    \begin{algorithm}[!t] 
	\caption{VNS metaheuristika}\label{alg:vns}
	\begin{algorithmic}[1]
		\STATE \textbf{Ulaz:} inicijalno rješenje $s$, okoline $\mathcal{N}_1,\ldots, \mathcal{N}_{k_{\max}}$ 
		\STATE \textbf{Izlaz:} (poboljšano) rješenje $s$
		\WHILE{$\neg$ (\emph{IspunjenKriterijzaustavljanja()})}
		\STATE $k \gets  k_{\min}$
		\WHILE{$k \leq k_{\max}$}
		\STATE  $s' \gets$ izabrati random rješenje iz $\mathcal{N}_k(s)$ \hspace{0.3cm}//\,shaking phase 
		\STATE $s' \gets  LokalnaPretraga(s^{'})$
		\IF{$f(s') > f(s)$}
		\STATE $s \gets s'$
		\STATE $k \gets 1$
		\ELSE 
		\STATE $k \gets k+1$ \hspace{0.3cm}//\, koristiti narednu (VNS) okolinu
		\ENDIF
		\ENDWHILE
		\ENDWHILE
		\STATE \textbf{return} $s$
	\end{algorithmic}
\end{algorithm}


\emph{Primjer}. Da bismo ilustrovali način funkcionisanja metode promjenljivih okolina, možemo posmatrati isti primjer kao i u slučaju genetskog algoritma: 0-1 problem ruksaka. 


\emph{Reprezentacija rješenja}. Kao i u slučaju genetskog algoritma, rješenje problema se može predstaviti binarnim nizom. Ako $i$-ti element niza ima vrijednost 1, to znači da je $i$-ti proizvod uključen u rješenje, a u suprotnom, nije.

\emph{Vrijednost funkcije cilja}. Slično kao u primjeru genetskog algoritma, vrijednost funkcije cilja se najlakše može definisati kao zbir vrijednosti proizvoda uključenih u rješenje. Eventualno, ako se u algoritmu dozvoljava rad sa nedopustivim rješenjima, funkcija cilja može da sadrži i dio za ``kažnjavanje'' nedopustivih rješenja. Razmatranje o kažnjavanju nodupistivih rješenja je slično kao u slučaju genetskog algoritma.

\emph{Razmrdavanje}. Može se primijeniti više različitih tehnika razmrdavanja, a u ovom primjeru ćemo objasniti jedan pristup. 
U okviru procedure razmrdavanja, kreira se novo rješenje $x'$, ($x' \in N_k(x)$) zasno\-vano na trenutno najboljem rješenju  $x$.
$k$-ta okolina se definiše na sljedeći način: Nekih $k$ proizvoda se bira na slučajan način. Svakom izabranom proizvodu mijenja se status: Ako je izabran proizvod koji je uključen u ruksak, on se izbacuje iz ruksaka i obrnuto. Formalno, $k$-ta okolina rješenja
$x$ se zapisuje kao  $N_k(x) = \{x':  \{i_1,i_2,...,i_k\}\subset \{1,2,...,n\}\  x'_{i_j}=1-x_{i_j}\}$.

Za pravilno funkcionisanje procedure razmrdavanja, potrebno je definisati kardinalnost najmanje i najveće okoline, koja zavisi od $k$. Obično se okolina najmanje kardinalnosti zasniva na malim vijednostima $k$, (na primjer $k_{min}=1$ ili $k_{min}=2$), dok se za maksimalnu vrijednost $k_{max}$  uzimaju vrijednosti 20, 30, ili čak i više, u zavisnosti od prirode i dimenzije problema.

Praktično gledano, u našem primjeru u $k$-tom koraku izvršenja procedure razmrdavanja, naš algoritam bi generisao jedno novo rješenje (označimo ga sa $x'$), koje se od trenutno najboljeg rješenja razlikuje u tačno $k$ koordinata, odnosno u tačno $k$ proizvoda. Na primjer, u slučaju da je rješenje $x$ predstavljeno nizom 1100100 i ako je $k=3$, tada bi rješenje    $x'$ moglo da  (između ostalog) izgleda
1000111. Odnosno, vidimo da se ova dva rješenja razlikuju na tačno tri indeksa (indeksima 2, 6 i 7).

\emph{Lokalno pretraživanje}. 
Za rješenje  $x'$ dobijeno u  proceduri razmrdavanja poziva se lokalno pretraživanje. Ova procedura podrazumijeva temeljno (ispcrpno) pretraživanje svih (ili skoro svih) rješenja, koja se blago razlikuju od rješenja  $x'$. Lokalno pretraživanje u ovom problemu bi moglo biti zasnovano na sličnim razmatranjima kao mutacije kod genetskog algoritma. Na primjer, jedno lokalno pretraživanje bi moglo da bude zasnovano na tzv. 1-swap pristupu (razmjena vrijednosti parova koordinata). Preciznije, lokalno pretraživanje razmatra sva rješenja nastala od rješenja $x'$ na način da je jedan proizvod koji je bio uključen u ruksak sada izbačen, a neki drugi proizvod, koji prvobitno nije bio u ruksaku, sada jeste.

Postoje različite strategije koliko dugo se izvršava lokalna pretraga. U opštem slučaju, potrebno je napraviti balans između utrošenog vremena pretraživanja i potrebe za lokalnim poboljšanjem rješenja. Stoga je generalno dobar pristup kostrukcija  procedura lokalnog pretraživanja koje se brzo izvršavaju (u idealnom slučaju u $O(1)$ vremenu), kako bi se omogućilo što iscrpnije pretraživanje okoline datog rješenja. Takođe, nekada se kombinuje više metoda lokalnog pretraživanja (ovo važi za većinu heurističkih metoda), koje, manje ili više temeljno, pretražuju okoline datog rješenja, u zavisnosti od brzine ili drugih parametara.



\section{Zadaci}

\begin{enumerate}
	\item Na šahovskoj tabli dimenzije 8x8 je postavljeno nekoliko topova, tako da se nikoja dva topa međusobno ne napadaju. Dodati na tu tablu još topova, tako da ih bude maksimalno 8, a da se i dalje nikoja dva topa ne napadaju.
	\item Istraži na internetu problem vraćanja kusura pomoću minimalnog broja novčanica (kovanica). Koristi google pretragu \textit{change-making problem} ili \textit{coin change problem}. Napiši pohlepni algoritam koji rješava ovaj problem. Ispitaj pod kojim uslovima pohlepni algoritam uvijek daje optimalno rješenje. Pronađi kontraprimjer kada pohlepni algoritam neće dati optimalno rješenje.
	\item Bojenje grafa je procedura koja svakom čvoru grafa dodjeljuje jednu boju, poštujući pravilo da susjedni čvorovi nisu obojeni istom bojom. Napiši pohlepni algoritam pomoću kog se vrši bojenje grafa, tako da se iskoristi što je manje moguće boja. Pokušaj da okarakterišeš neku klasu grafova za koju tvoj pohlepni algoritam uvijek daje optimalno rješenje. Konstruiši kontraprimjer kada pohlepni algoritam neće dati optimalno rješenje.
	
	\item Osmisli pohlepni algoritam koji rješava problem trgovačkog putnika. Pronađi kontraprimjer kada tvoj algoritam ne pronalazi optimalno rješenje.
	
	\item Osmisliti pohlepni algoritam koji rješava problem određivanja maksimalnog nezavisnog skupa čvorova u grafu. Odredi neke klase grafova za koje tvoj pohlepni algoritam uvijek pronalazi optimalno rješenje. Pronađi kontraprimjer kada pohlepni algoritam ne pronalazi optimalno rješenje.
	
	\item svaki razlomak se može napisati kao zbir razlomaka od kojih svaki ima jedinicu u brojiocu. Taj zapis su koristili još i stari Egipćani, po kojima se taj zapis i zove ``egipatski razlomak''. 
	Napisati pohlepni algoritam koji proizvoljan razlomak zapisuje kao ``egipatski razlomak'', odnosno kao zbir razlomaka koji imaju jedinicu u brojiocu.
	
	\item Zadat je skup $S$ koji se sastoji od $n$ brojeva. Koristeći pohlepni algoritam, podijeliti skup $S$ na dva podskupa, tako da se zbirovi elemenata u prvom i drugom podskupu što manje razlikuju.
	
	\item $N$ kajakaša koji su teški redom $1\leqslant w_1\leqslant w_2\leqslant \cdots \leqslant W_N$. Cilj je rasporediti kajakaše u što manje kajaka--dvosjeda. Maksimalna težina koju jedan kajak može da izdrži je $k$. Pretpostavka je da je $w_i\leqslant k$. Napisati pohlepni algoritam koji rješava ovaj zadatak.
	
		%http://poincare.matf.bg.ac.rs/~ezivkovm/nastava/12_asp-pohlepni-algoritmi.pdf
	\item  Napisati pohlepni algoritam koji ispituje da li je jedna riječ podriječ druge riječi.
	
	\item Poznate su visine $n$ momaka i $n$ djevojaka. Napisati program koji
	određuje koliko se najviše plesnih parova može formirati tako da je momak uvijek
	viši od djevojke.
	
	
	\item Problem postavljanja kraljica na šahovsku tablu podrazumijeva pozicioniranje kraljica tako da se nikoje dvije kraljice ne napadaju. Osmisliti genetski algoritam koji rješava ovaj problem.
	\item Osmisliti genetski algoritam i metodu promjenljivih okolina kojima se rješava problem bojenja čvorova grafa.
	
	\item Osmisliti genetski algoritam i metodu promjenljivih okolina kojima se rješava problem određivanja maksimalne klike u grafu.
	
		\item Osmisliti genetski algoritam i metodu promjenljivih okolina kojima se rješava problem određivanja maksimalnog nezavisnog skupa čvorova u grafu.
		\item %https://www.mpi-inf.mpg.de/fileadmin/inf/d1/teaching/winter15/ApproxAlg/ex01.pdf
		   Neka je dat ruksak čija je veličina jednaka $C$ i skup proizvoda $I = \{1,\ldots, n\}$, gdje proizvod $i$ ima svoju cijenu $c_i>0$ i veličinu $s_i>0$. Pokrivač ruksaka je skup proizvoda $I' \subseteq I$ tako da je $\sum_{i \in I'} s_i > C$.  Problem pokrivača ruksaka traži podskup proizvoda koji je pokrivač ruksaka sa minimalnom    cijenom.   Pretpostavimo da ne postoji proizvod čija je cijena veća od    cijene optimalnog rješenja. Konstruisati 2--aproksimativni algoritam za ovaj problem pod prethodnom pretpostavkom. 
		   \item Pokazali smo da postoji 2--aproksimativni algoritam za problem pokrivanja čvora. Da li se može konstruisati instanca na kojoj (jedan od dva algoritma) ne daje bolju aproksimaciju od faktora 2? 
		   \item %https://massivedatasets.files.wordpress.com/2011/04/approx1-exercisesf114.pdf
		   Neka je dat kompletan nedirektan graf $G = (V, E)$ u kojem težine grana zadovoljavaju nejednakost trougla i neka je $k$ pozitivan prirodan broj. Probem se sastoji u particionisanju skupa $V$ na $k$ disjunktnih skupova $V_1, \ldots, V_k$ da bi se minimizirala grana najveće cijene između dva čvora u istom skupu, ili simbolički 
		   $$ \max_{1 \leq i \leq k, u,v \in V_i} c(uv).$$
		   Konstruisati 2--aproksimativni algoritam za ovaj problem (metričko $k$--klasterovanje). 
		\item %https://www.ibr.cs.tu-bs.de/courses/ws1920/aa/exercises/exercise_03.pdf
		 Neka je dat netežinski graf $G=(V,E)$. Problem koji se razmatra je naći particiju $V$ na $k$ skupova $V_1,\ldots, V_k$ tako da je broj grana koje su između dvije različite particije minimizovan. Konstruisati (gridi) algoritam koji je 1-$\frac{1}{k}$--aproksimativni. 
		 \item U problemu bojanja grafa, u ulazu nam je dat neusmjeren graf $G = (V,E)$. Kažemo da je funkcija $f:V \mapsto \{1,\ldots, k\}$ $k$-bojenje akko ne postoje susjedni čvorovi grafa kojima je pridružen isti broj, tj. $f(u) \neq f(v)$, za $uv \in E$. Problem bojenja grafa traži za $k$-funkciju na grafu $G$, gdje je $k$ minimalan. Konstrusaiti pohlepni algoritam za koji je $k = \Delta + 1$, gdje je $\Delta$ maksimalni stepen čvora u $G$. 
		 \item %https://www.ibr.cs.tu-bs.de/courses/ws1920/aa/exercises/exercise_05.pdf
		 Problem obilaska segmenata (eng. \emph{Segment tour problem}). Neka je dat skup segmenata $S = \{s_0 = (p_0, p_1), s_1 =(p_2, p_3),\ldots\}$ u $\mathbb{R}^2$. Problem traži da se nađe (geometrijski) obilazak minimalne dužine koji sadrži sve segmente iz skupa $S$. Konstruisati 3--aproksimativni algoritam.  
		 \item Neka je dat kompletan težinski graf $G=(V,E)$ čije grane zadovoljavaju nejednakost trougla. $ k$ poštara treba da prođu grafom tako da svaka grana u datom podskupu grana $E' \subseteq E$ bude pređena barem od strane jednog poštara. Startni i završni čvor za svakog od poštara je izabran po slobodnoj volji. Zadatak ovog problema je naći šetnju u grafu sa minimalnom dužinom (za sve poštare). 
		 Konstruisati 2--aproksimativni graf ovog problema. 
		 \item %https://www.ibr.cs.tu-bs.de/courses/ws1920/aa/exercises/exercise_03.pdf
		 Neka je dat usmjereni graf $G = (V,E) $ sa nenegativnim težinama grana $w:E\mapsto\mathbb{R}$. Zadatak je naći  podskup čvorova $S \subseteq V$ tako da je suma grana iz $S$ u $V\setminus S$ najveća moguća, tj. 
		  $$ \sum_{s \in S, t \notin S, st \in E }w(st)$$
		  je maksimizovana.  
		  
		  Konstruisati $\frac{1}{4}$--aproksimativni algoritam.
		 \item  %https://www.cs.cornell.edu/gomes/MYPAPERS/gomes-williams05.pdf
		 Neka je data instanca problema sa pozitivnim prirodnim  brojem $k$ i multi-skupom 
		 $T = \{t_1,\ldots, t_n\}$ vremena (procesiranja poslova), $t_i \in \mathbb{Q}$ za sve $i=1,\ldots, n$. 
		 Zadatak je da se nađe dodjela poslova svakoj od $k$ mašina (dakle, funkcija $f:\{1,\ldots, n\} \mapsto \{1,\ldots, k\}$) tako da je vrijeme završetka svih poslova na mašinama minimizovano, pod uslovom da one mogu izvršavati poslove paralelno, tj. funkcija cilja koja se minimizuje je data sa 
		 $$\max \{  \sum_{i: f(i) = j } t_i \mid j=1,\ldots, k \}$$
		 Konstruisati 2--aproksimativni algoritam.
\end{enumerate}



 \chapter{Optimizacioni rješavači}
 
 Kao što smo i pomenuli u uvodnoj sekciji, modelovanje problema koji odgovara rješenju problema je 
 dio koji uzima najveći dio vremena. Kada dođemo do modela koji približno odgovara potrebama uprave 
 koja naručuje sistem zasnovan na OR istraživanju, rješavanje modela se svodi na pozivanje odgovarajućih rješavača. Neki od najpoznatijih su 
 CPLEX koji može biti pozivan u Javi, C++ i Python-u uz pomoć odgovarajućih API-ja, zatim Lindo, Gurobi te modul PuLP u Python-u, među ostalima.  
 
 U nastavku opisujemo korištenje Cplex i PuLP rješavača u implementaciji modela i njegovog rješavanja. 
 %https://realpython.com/linear-programming-python/
 %https://www.ibm.com/products/ilog-cplex-optimization-studio
 %https://www.youtube.com/watch?v=J7tNzCsYgy8
 
 \section{Optimizacioni rješavač Cplex}
 CPLEX alat je generalni rješavač za rješavanje optimizacionih problema, a među njima  LP, ILP i MILP. Konstruisan je od strane IBM-a, i može da se preuzme sa linka \url{https://www.ibm.com/products/ilog-cplex-optimization-studio}. On je dio \emph{IBM ILOG CPLEX Optimization Studio}-a koji ukljucuje i druge opcije poput \emph{Constraint Programming} (CP) solvera itd.
 
 U nastavku opisujemo proces same implementacije modela u CPLEX-u, preko programskog jezika $C$++.
 Da bismo ukljucili CPLEX u $C$++ kod, nepohodno ga je uključiti u $C$++ program sa:
 \begin{verbatim}
 	#include<ilcplex/ilocplex.h>
 	ILOSTLBEGIN
 \end{verbatim}
 Da bi se inicijalizovao LP model, neophodno je prvo inicijalizovati okrizenje za modelovanje. Dakle, konstruišemo instancu klase \emph{IloEnv} sa: 
 \begin{verbatim}
 	IloEnv env;
 	try{
 		//ovdje se deklarise model
 	}
 	catch(IloException& e){
 		cer >> "Greska: " >> e >> endl;
 	}
 \end{verbatim}
 
 \noindent Unutar \emph{try-catch} bloka implementiramo prvo objekat modela (instanca klase \emph{IloModel}), a zatim se model uvlači u rješavač CPLEX (kreira se objekat klase \emph{IloColex}) i rješava pozivanjem odgovarajuće metode (\emph{solve}).
 Model je instanca klase \emph{IloModel} čiji konstruktor uzima objekat klase \emph{IloEnv} kao parameter dok je model koji se rješava pomoću CPLEX-a instanca klase \emph{IloCplex} koji uzima instancu klase \emph{IloModel} kao vrijednost svog parametra.  Ako bismo željeli da riješimo model pomoću CP slovera, mjesto \emph{IloCplex} bismo koristili klasu \emph{IloCP}. 
 

 \begin{verbatim}
 	IloModel model(env); //def. modela
 	// potrebno deklarisati ciljnu funkciju, varijable i ogranjčenja
 	IloCplex cplex(model);
 	if(!cplex.solve()){ // poziv cplex  solver-a
 		    env.error() << " Nije optimizovan." << endl;
 		    throw(-1);
 	}
 	//cplex zavrsio sa optimizovanjem problema ... ispis rjesenja
 \end{verbatim}
 
 \noindent Sljedeći korak je implementacija varijabli, funkcije cilja i ograničenja u modelu. 
 
 \noindent \textbf{\emph{Deklarisanje varijabli}}. Ako želimo da deklarisemo (realnu) varijablu $x$ gdje je $0 \leq x \leq 40$, koristimo klasu \emph{IloNumVar}, što odgovara sljedećoj liniji koda:
 \begin{verbatim}
 	IloNumVar x = IloNumVar(env,0.0,40.0);
 \end{verbatim}
 Ova definicija je ekvivalentna sa time ako bi dodali u prethodnom konstruktoru ILOFLOAT kao četvrti argument. 
Ako je potrebno implementirati varijablu za koju je $x \geq 0$ to radimo kao u prethodnom primjeru uz korištenje  \emph{IloInfinity} konstante.
 
 Ako želimo da implementiramo varijablu koja je cjelobrojna, recimo binarna varijabla, to radimo sa:
 \begin{verbatim}
 	IloNumVar x = IloNumVar(env,0.0, 1.0, ILOINT);
 \end{verbatim}
 
 \noindent Ako je potrebno definisati vektor promjenjivih $x=(x_1,...,x_n)$, gdje je recimo $x_i \geq 1$, onda se definiše objekat klase \emph{IloNumVarArray}, tj.:
 \begin{verbatim}
 	IloNumVarArray x(env);
 	for(int i=0; i<n; i++){
 		   x.add(IloNumVar(env, 1.0, IloInfinity));
 	}
 \end{verbatim}
 
 \noindent Ako želimo da deklarišemo visedimenzionalne promjenjive kao što je $x_{i,j}, i=1,...,n$ i $j=1,...,m$, onda pozivamo templejt klasu $\textbf{IloArray}<>$.
 
 \begin{verbatim}
 	typedef IloArray<IloNumVarArray> FloatMatrix; // x_ij 
 	typedef IloArray<FloatMatrix> Float3Matrix; // 3D niz var: x_ijk
 	
 	FloatMatrix x(env, n);
 	for(int i = 0; i < n; i++){
 		     x[i] = IloNumVarArray(env, m);
 		for(int j = 0; j < m; j++){
 		  	  x[i][j] = IloNumVar(env, 0.0) // x_ij>=0
 		}
 	}
 \end{verbatim}
 
 \noindent \textbf{\emph{Funkcija cilja}}. 
 Postoje dvije klase koje služe za deklarisanje funkcija cilja: \emph{IloMaximize} i \emph{IloMinimize}, zavisno od toga da li maksimizujemo ili minimizujemo. \emph{IloMaximize} se prosljeđuju dva parametra: objekat IloEnv okruženja, te objekat klase \emph{IloExpr} gdje se definiše  izraz koji odgovara funkciji cilja. 
 
 \begin{verbatim}
 	IloExpr expr(env);
 	//definisanje expr
 	IloObjective obj = IloMaximize(env, expr);
 	model.add(obj);
 \end{verbatim}
 
 \noindent Za deklarisanje izraza $expr$ možemo koristiti operatora ``+='', gdje se na desnoj strani nalazi objekat IloNumVar koji predstavlja varijablu (eventualno pomnožena sa nekim koeficijentom). 
 Recimo, ako želimo da implementiramo funkciju cilja $\sum_{i=1}^n c_i x_i$, implementacija bi bila ovakva:
 
 \begin{verbatim}
 	IloExpr expr(env);
 	// pretp. da je niz c[] deklarisan
 	for(int i = 0; i < n; i++){
       IloNumVar x = IlonumVar(env);
 	     expr+= c[i] * x;
 	}
 	IloObjective obj = IloMaximize(env, expr);
 	model.add(obj); // dodavanje funkcije cilja u model
 \end{verbatim}
 
 \noindent \textbf{\emph{Dodavanje ograničenja u model}}. Ograničenja se direktno mogu dodati  u model sa funkcijom \emph{add}, dakle kao 
 model.add($expr1 <= expr2$), gdje mjesto ``$<=$'' mogu biti ``=='' ili ``$>=$''. Umjesto izraza $expr1$ ili $expr2$ može da stoji i skalar. Recimo da treba da modelujemo sljedeće ograničenje:
 $$s_j = \sum_{t=1}^n t \cdot x_{jt}, \forall j.$$ 
 Sljedeća implementacija odgovara ovom ograničenju: 
 \begin{verbatim}
 	// neka je definisan niz s[]
 	for (j = 0; j < N; j++) {
 		  IloExpr expr(env);
 		  for (t = 1; t <= n; t++)
 	  	     expr += t * x[j][t];            
 		  model.add(s[j] == expr);
 		  expr.end();
 	}
 \end{verbatim}
 Još jedan od načina dodavanja ograničenja u model je implementacija preko kontejnera \emph{IloRangeArray} u koji se ograničenja dodaju preko funkcije \emph{add}.   
 Recimo da je potrebno dodati ograničenja $x_i + x_j \leq 1$ za sve $i<j, i.j \in [n]$ u IloCplex model
 
 \begin{verbatim}
 	     IloRangeArray constr(env);
 	     // neka su definisane varijable x (IloNumVarArray) 
 	     for (i=0; i<n-1; ++i)
 	          for(j=i+1; i<n; ++j)
 	               constr.add( x[i] + x[j] <= 1)     
      	 model.add(constr); //dodavanje ograničenja u model
 \end{verbatim}
 
 \noindent \textbf{\emph{Metode za eksport rješenja (statistike) iz modela}}. Metod \emph{getStatus} (koji se poziva na instancu klase \emph{IloCplex})  pokazuje da li je rješenje koje je nađeno dopustivo, ograničeno ili optimalno ili je CPLEX pokazao da je model nedopustiv ili neograničen.
 
 \begin{verbatim}
 	// kreiranje modela 
 	timer.start();
 	// pokretanje cplex-a (.solve)
 	// Output
 	timer.end();
 	IloNumArray xval(env); // ovdje ce se cuvati rjesenje
 	env.out() << "Status rjesenja = " << cplex.getStatus() << endl;
 	env.out() << "Vrijednost = " << cplex.getObjValue() << endl;
 	env.out() << "Vrijeme = " << timer.getTime() << endl;
 	cplex.getValues(xval, x);
 	env.out() << "sj vrijednosti = " << xval << endl;
 \end{verbatim}
\begin{itemize}
	\item Metod \emph{getObjValue} vraća optimalnu vrijednost funkcije cilja (ili najbolju vrijdnost nađenu u toku unaprijed definisanog vremena).
	\item Metod \emph{getStatus}: vraća status rješenja koje je CPLEX našao u zadanom vremenu (dopustivo, optimalno, nedopustivo).
	\item Metod \emph{getValues}(\emph{vals, var}) gdje je 
	\begin{itemize}
	 	  \item \emph{vals} -- numerički niz (najčešće instanca klase \emph{IloNumArray}) u koju će se kopirati krajnja rješenja koje je Cplex našao;    
          \item \emph{var} -- varijable u modelu.
    \end{itemize}
     \item Metod \emph{getDuals(vals, con)}:
     \begin{itemize}
     	\item \emph{vals} -- numerički niz (najčešće instanca klase \emph{IloNumArray}) u koju će se kopirati rješenja duala;
     	\item \emph{con} -- ograničenja u modelu (instanca klase \emph{IloRangeArray}) za koje se računaju koeficijenti koji odgovaraju dualu. 
     \end{itemize}
\end{itemize}
Eksportovanje modela za eventualno ponovno korištenje se može dobiti pozivom metoda \emph{exportModel}, čiji je argument naziv fajla (.$lp$ ekstenzija).  
 \section{Alat PuLP}
 % http://www.optimization-online.org/DB_FILE/2011/09/3178.pdf
 % https://coin-or.github.io/pulp/main/the_optimisation_process.html
 PuLP je biblioteka visokog nivoa za implementaciju modela i njihovo rješavanje, izgrađena u programskom jeziku Python.  
 Ona omogućava korisniku da kreira programe koristeći izraze prirodne za ovaj programski jezik,  
 pri tome izbjegavajući pojavljivanje specijalne sintakse gdje god je to moguće. PuLP je fokusirana na podršći modelovanju i rješavanju LP i MILP modela. Interesantno je da PuLP 
 ne zavisi od nekih drugih softverskih paketa.   Podržava mnogo komercijalnih i nekomercijalnih rješavača, te može biti proširena za podržavanje dodatnih rješavača. 
 
 PuLP radi na principu modularnog pristupa prevođenja modela napisanog prema definisanim pravilima na njegovu vektorsku prezentaciju (koristeći vektore, rijetke matrice itd.), nakon čega je tako konvertovani model proslijeđen u interfejs klase nekod od rješavača. Kako je interfejs mnogih rješavača sličan, ili se sa njima rukuje tako što se model napiše u standardnim .$lp$ ili .$mps$  formatima  datoteka, osnovne generičke klase rješavača uključene su u PuLP  pored specifičnih interfejsa %popularnih rješavača. 
 Ove generičke klase rješavača se mogu proširiti od strane korisnika novih rješavača uz minimalan trud.   
 
 Da bismo koristili PuLp modul, prvo importujemo:
 \begin{verbatim}
 	  from pulp import *
 \end{verbatim}
 Konkretno, ovaj paket se (u Linux-u) može instalirati pozivom: \emph{sudo pip install pulp} ili \emph{sudo apt-get install glpk-utils}. 
 % https://www.coin-or.org/PuLP/CaseStudies/index.html (za primjere) 
 Kreiranje jedne instance problema je dato sljedećim kodom:
 \begin{verbatim}
 	prob = LpProblem("Naziv problema", LpMinimize)
 \end{verbatim}
Ovdje je   riječ o problemu minimizacije. Ako bi bilo potrebno da maksimizujemo, drugi argument bi bio 
LpMaximize. 

\textbf{\emph{Deklarisanje varijabli}}.  Za deklarisanje varijabli se koristi klasa \emph{LpVariable}. Ona ima četiri atributa: prvi je naziv varijable, drugi donja granica vrijednosti varijable, treći gornju granicu za vrijednost varijable, dok četvrti označava tip varijable. Tip varijable koji je moguć LpContinuous ili LpInteger, označavajući neprekidnu (realnu) i diskretnu varijablu, redom.  
Ako želimo deklarisati varijablu $x_1\geq 0$, koja je neprekidna, imali bismo sljedeću liniju koda:
\begin{verbatim}
	 x1 = LpVariable( "x1", 0, None, LpContinuous)
\end{verbatim}
\textbf{\emph{Deklarisanje funkcije cilja}}. Uz pomoć definisanih varijabli koristeći operatore iz skupa $\{+,-, \cdot \}$, dodajemo takvu funkciju na instancu problema (koristeći operator +=). Primjera radi, ako želimo da modelujemo funkciju cilja $x_1 + x_2$ (neprekidnih, pozitivnih varijabili), to bi uradili na sljedeći način:
\begin{verbatim}
	 x1 = LpVariable("x1", 0, None)
	 x2 = LpVariable("x2", 0, None) 
	 prob += (x1 + x2) # dodavanje funkcije cilja x1+x2 u model prob
\end{verbatim}  
\textbf{\emph{Deklarisanje ograničenja u modelu}}.  Na sličan način kao i za funkciju cilja, ograničenja se  u model dodaju pomoću operatora +=. Implementacija ograničenja je bliska ograničenjima u modelu, dakle prvo se konstruišu izrazi koji su vezani nekim operatorom poređenja. Primjera radi, ako bi željeli dodati ograničenja $x_1 + 2 x_2 \leq 2$ i $x_1-x_2 \geq 0$,  u prethodni model, imali bi 
\begin{verbatim}
	 prob +=  x1 + 2 * x2 <=2, "Ogranicenje 1"
	 prob +=  x1 - x2 >= 0, "Ogranicenje 2" 
\end{verbatim}
Upisivanje modela u .$lp$ format se vrši pozivom funkcije \emph{writeLP()}, čiji je argument naziv fajla. 

 \noindent \textbf{\emph{Metode za eksport rješenja (statistike) iz modela}}. Rješavanje modela se inicira pozivom funkcije \emph{solve}() na instancu modela. Čitanje svih varijabli iz modela ide pomoću funkcije $variables()$. Svaka varijabla kao atribute ima svoj naziv (atribut name), te vrijednost koju je dobila pri rješavanju modela (atribut varValue). Atribut objective instance modela nosi (najbolju) vrijednost funkcije cilja dobijene rješavanjem modela. Status rješavanja se dobija iz atributa status instance modela. 
 
 \begin{verbatim}
 	print "Status:", LpStatus[prob.status]
 	for v in prob.variables():
 	print(v.name, "=", v.varValue)
 	print("Vrijednost funkcije cilja: ", value(prob.objective))
 \end{verbatim}
 \section{Primjena alata PuLP na rješavanje jednog Problema Lokacija}%Capacitated Facility Location
 Posmatrajmo već modelovan problem lokacija iz Sekcije~\ref{sec:modeli_lp} uz pomoć PuLP rješavača. Model ovog problema je dat sa:
 \begin{align*}
 	   & \min \sum_{i=1}^n f_i x_i  + \sum_{i,j} c_{ij} y_{ij} d_j  \\
 	   & \sum_{i} y_{ij} = 1, \forall j\in\{1,\ldots,m\} \\
 	   & \sum_{j} d_j y_{ij} \leq u_i x_i, \forall i \in \{1,\ldots,n\} \\
 	   & x_i \in \{0, 1\}, \forall i \in \{1, \ldots, n\} \\
 	   & y_{ij} \geq 0, \forall i \in \{1,\ldots,n \}, j \in \{1, \ldots, m\}.
 \end{align*}
 Ulazni parametri problema su konstante $m, n$, vektor $f$ koji odgovara cijeni otvaranja postrojenja, vektor $d$ koji odgovara potražnji svakog od kupaca, vektor $u$ koji odgovara kapacitetu postrojenja, te matrica $c_{ij}$ koja 
 odgovara cijeni zadovoljenja potreba kupca $j$ od strane postrojenja $i$ (kao što je cijena isporuke).  Definišimo kroz program jednu instancu (obično se ona čita iz fajla). 
 \begin{verbatim}
   from pulp import *
 	  locations = [1, 2, 3]
 	  customers = [1, 2, 3]
 	  f = { 1 :  50,
 	        2 :  32,
 	        3 :  40 
 	  }
    u = {
            1 : 220,
            2 : 100,
            3 : 150
    }
     d = {
          1 : 25,
          2 : 44,
          3 : 48
     }
     c = {
       1 : { 1 : 2.0, 2 : 1.5, 3 : 0.75 },
       2 : { 1 : 1.75, 2 : 1.5, 3 :  2.2 },  
       3 : { 1 : 1.1, 2 : 2.2, 3 : 2.1  }
    }
    # modelovanje:
    model = LpProblem("Lokacijski problem", LpMinimize) 
    # varijable:
    x = LpVariable.dicts("x_vars", locations, 0, 1, LpBinary)
    y = LpVariable.dicts("y_vars", [ (i, j) for i in locations \ 
                                            for j in customers ],\  
                                            0, None, LpContinous)
    #funkcija cilja: 
    model += lpSum( f[i] * x[i] for i in locations )\ 
          + lpSum(  y[ (i, j) ] * c[ i ][ j ] * d[ j ] \ 
            for i in locations for j in customers )
   
    #ograničenja:
    for j in customers:
        model += lpSum( y[ (i, j) ] for i in locations ) == 1
    for i in locations: 
        model += lpSum( y[ (i, j) ] * d[ j ] for j in customers ) \ 
                 <= u[ i ] * x[ i ]
    # solve:
    model.solve()
    # rješenja:
    print("Otvorene lokacije su \n:")
    for i in locations:
        if  x[ i ].varValue > 0:
            print(str(i) + "\t")
    print("y =>\n")
    for i in locations:
         for j in customers:
             print(y[ (i, j) ].varValue)
    print("Vrijednost: ", value(model.objective))    
 \end{verbatim}
 Optimalna vrijednost ove instance je 202.0 a dostiže se za vrijednost varijabli $x = (1, 0, 0)$, te $y_{11}= y_{12}= y_{13} = 1$, dok su ostale vrijednosti 0.
 \section{Primjena Cplex rješavača na jedan problem stringova}
 
 % opisati RFLCS problem, modelovati ga:
 U ovoj sekciji modelujemo problem \emph{najdužeg zajedničkog podniza bez ponavljanja}. Ovaj problem kao ulaz prihvata dva (proizvoljna) stringa $s_1$ i $s_2$ nad proizvoljnom abecedom, a kao izlaz vraća string $s$ maksimalne dužine sa sljedećim karakteristikama:  
 \begin{itemize}
 	\item $s$ je zajednički podniz oba stringa; 
 	\item $s$ ne sadrži karakter koji se u njemu pojavljuje dva ili više puta.
 \end{itemize}
Za ovaj problem je poznato da je NP-težak. 

Za primjer, neka su data dva stringa $s_1 = \texttt{abdcccab}$ i $s_2=\texttt{abccacd}$, rješenje ovog problema je $s=\texttt{abc}$. Primijetimo da je $s$ zajednički podniz za oba ulazna stringa te da ispunjava uslov o ``neponavljajućim'' karakterima u sebi. Takođe, može se provjeriti da ne postoji duži zajednički podniz sa takvim svojstvom za ove ulazne stringove, što znači da je ovo rješenje optimalno. Konstruišimo sada jedan Binarni cjelobrojni model za ovaj problem. Nazovimo par $(a, b), 1 \leq i \leq |s_1|, 1 \leq j \leq |s_2|$ \emph{mečing} akko je $s_1[a]=s_2[b], a < b$. Dalje, sa $\mathcal{M}$ označimo skup svih mečinga za dati ulaz $S=\{s_1, s_2\}$. Takođe, označimo sa  $\mathcal{M}_{\texttt{a}}$, skup svih mečinga koji pokrivaju isto slovo, tj. 
$\mathcal{M}_{\texttt{a}} = \{ (i, j) \mid s_1[i]=s_2[j]=\texttt{a}\}$, $\texttt{a} \in \Sigma$. Za svaki mečing $p=(p(a),p(b))$, pridružimo jednu binarnu varijablu $z_{p} \in \{0, 1\}$. Označimo $l(z_p)= s_1[ p(a) ], Z_{\texttt{a}} = \{ z_p \mid p \in \mathcal{M} \ \wedge\  l(z_p) = \texttt{a}\}, \texttt{a}\in \Sigma$, te skup svih varijabli sa $Z = \cup_{\texttt{a} \in \Sigma} Z_{\texttt{a}}$. 

Za svake dvije binarne varijable $z_{p_1}$ i $z_{p_2}$ kažemo da su u \emph{konflitu} akko vrijedi $$ p_1(a) \geq p_1(a) \mbox{ i } p_1(b) \leq p_2(b)     $$ 
ili 
 $$ p_1(a) \leq p_1(a) \mbox{ i } p_1(b) \geq p_2(b).$$ 
ili 
$$ l(z_{p_1}) = l(z_{p_2}).$$

Sada možemo formirati ograničenja u modelu. Uslov da je svaki karakter prisutan najviše jednom u rješenju problema se modeluje sa 
\begin{equation}\label{eq:rflcs-max-1}
	 \sum_{z \in  Z_{\texttt{a} }} z \leq 1, \forall \texttt{a} \in \Sigma 
\end{equation}
Takođe, s obzirom da rješenje problema odgovara nalasku skupa (međusobno) nekonfliktnih mečinga (odgovarajućih $z$-varijabli) maksimalne kardinalnosti, dodajemo ograničenje
\begin{equation}\label{eq:rflce-non-conflict}
	 z_{p} + z_q \leq 1, \forall p,q \in Z, p\neq q, p\mbox{ je u konfliktu sa } q.
\end{equation}
Kako tražimo skup maksimalne kardinalnosti, imamo funkciju cilja 
\begin{equation}\label{eq:rflcs-objective}
	 \max \sum_{z \in Z } z 
\end{equation}
Dakle, uz funkciju cilja (\ref{eq:rflcs-objective}), ograničenja (\ref{eq:rflcs-max-1})--(\ref{eq:rflce-non-conflict}) sa uslovom $z \in \{0, 1\}, z \in Z$, dobili smo model problema najdužeg stringa bez ponavljanja. 

 Implementirajmo ovaj model, uz pretpostavku da je svaki string u ulazu narednog programa dat svojom numeričkom prezentacijom. To znači da je svakom karakteru stringa pridružen jedinstven broj i kao takav se importuje u program. Primjera rad, za string $s_1=\texttt{abbcba}$, pridružen je numerički niz (vektor) 011210. Naravno, ovo je moguće riješiti i na drugačiji način, bez ovakve konverzije stringa u vektor prezentaciju. 
 
 Model je implementiran u programskom jeziku C++, a riješen uz pomoć Cplex rješavača. 
 
\begin{verbatim}
#include <string>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <limits>
#include <unordered_map>
#include <map>

#include "path-to-ilocplex.h"

ILOSTLBEGIN	
struct Point2d // point for structure
{
	
   	public:
   	int a,b;
   	Point2d(): a(0), b(0){}; // default constructor...
   	Point2d(int _a,int _b): a(_a), b(_b){};
   	
   	bool operator == (const Point2d & p2) const
   	{
   		     return (a == p2.a and b == p2.b);
   	}
   	friend std::ostream&  operator << (std::ostream & os, const Point2d&  p)
   	{
     	    	os<< "(" << p.a << ", " << p.b << ") " << endl;
    		return os;
   	
    	
};	
	
class Hash2d  //hashing the points
{
	   // works if the length of strings <= 5000 (can be adapted)
	   public:
	   std::size_t operator()(const Point2d & pl ) const
	   {
	    	   return 5000*pl.a  + pl.b;   
	   }
};

bool conflict(const Point2d& p1, const Point2d& p2)
{
    	if( ( p1.a > p2.a and  p1.b > p2.b ) or 
    	    ( p1.a < p2.a and  p1.b < p2.b ) ) 
         	return false;
    	return true;
}

int main( int argc, char **argv ) 
{ 
   vector<int> s1;
   vector<int> s2;
   // import stringova u s1 i s2 (numericka prezentacija)
   IloEnv env;
   env.setOut(env.getNullStream());
   try
   {  
 	    cout << "model creation..." << endl;
 	    IloModel model(env);
 	    int vars_num = 0;
 	    IloObjective obj = IloMaximize(env);
 	    // defining the set of binary variables Z
      unordered_map<Point2d, IloNumVar, Hash2d> Z;
 	    for (int i = 0; i < s1.size(); ++i){
 		    for (int j = 0; j < s2.size(); ++j)
 		    {
 		  	   if( s1[i] == s2[j] )
 		  	   {   
 		  	      Point2d p(i, j);
 		  	      IloNumVar myIntVar(env, 0, 1, ILOINT);
 		  	      Z[p] = myIntVar;
 		  	      obj.setLinearCoef(Z[p], 1.0); // define objective function
 		  	      ++vars_num;
 		    } 
 	    }
     }
     map<int, IloExpr> cs;   
     // repetition-free constraints: 
     for(unordered_map<Point2d, IloNumVar, Hash2d >::iterator itx 
      = Z.begin(); itx != Z.end(); ++itx)
     {	
	         if(cs.find(s1[(*itx).first.a]) == cs.end() ){
	    	        IloExpr xpr(env);
	    	        cs.insert({s1[(*itx).first.a], xpr });
	         }
	         cs[s1[(*itx).first.a]] += (*itx).second;
     }
       for(int i = 0; i < alphabet_size; i++)
           if(cs.find(i) != cs.end())
              model.add(cs[i] <= 1); 
            
       // define a set of constraints:
       for(unordered_map<Point2d, IloNumVar, Hash2d >::iterator it1 
       = Z.begin(); it1 != Z.end(); ++it1)
       {
	         for(unordered_map<Point2d, IloNumVar, Hash2d >::iterator it2 
	         = Z.begin(); it2 != Z.end(); ++it2)
	         {
		           if(conflict( (*it1).first, (*it2).first ) and  
		             ! ((*it1).first == (*it2).first) ){   // conflict constraints
			             model.add( (*it1).second + (*it2).second <= 1);
		           }
	         }
       }
      model.add(obj);
      IloCplex cplex(model);
      int time_limit = 900;
      //pass the time limit to CPLEX
      cplex.setParam(IloCplex::TiLim, time_limit); 
      IloNum lastObjVal = std::numeric_limits<double>::max();
      cplex.solve();  
      // rjesenja:
      if (cplex.getStatus() == IloAlgorithm::Optimal 
          or cplex.getStatus() == IloAlgorithm::Feasible)
      {
    	   if(cplex.getStatus() == IloAlgorithm::Optimal)
    	        cout << "CPLEX finds optimal" << endl;
    	   else
    	        cout << "CPLEX finds feasible solution" << endl;
    	      
    	  double lastVal = double(cplex.getObjValue());
    	   // print the objective point
    	   cout << "components in the solution: {" <<endl;
    	   bool first = true;
    	  for(unordered_map<Point2d, IloNumVar, Hash2d >::iterator it = Z.begin();
    	       it != (Z.end()); ++it)
    	  {
               IloNum xval = cplex.getValue((*it).second);
    	       if (xval > 0.9) {
                   cout << (*it).first;
    	       }
         }
         cout << " } \n";  
     }
     cout << "value: " << lastVal << endl;
     cout << "dual bound: " << double(cplex.getBestObjValue()) << endl;
   catch(IloException& e) {
     	cerr  << " ERROR: " << e << endl;
   }
   env.end();
 }
} 
\end{verbatim}

%\vspace{1cm} \\
\textbf{\large Zadaci}
\begin{enumerate}
	\item Istraži na internetu dostupne optimizacione  rješavače za probleme linearnog, cjelobrojnog (i mješovitog cjelobrojno--linearnog) programiranja. Procijeni njihov kvalitet, upotrebnu vrijednost i prepoznaj njihove prednosti i nedostatke u svakog od njih u odnosu na ostale.
	
	\item Koristeći neki od rješavača, provjeri ispravnost rješenja zadataka iz Glave 4 i Glave 6.
	
	\item Neka je u ulazu dat graf  $G = (V, E)$ kao instanca problema. Implementirati sljedeći ILP model:
	\begin{align*}
		& \max \sum_{v \in V} x_v \\
		& s.t. \\
		& x_{v'} + x_{v''} \leq 1, \forall (v' v'')\in E \\
		& x_v \in \{0, 1 \}, \forall v \in  V.
	\end{align*}
Izbaciti rješenje problema u obliku skupa odabranih čvorova koji su komponeneta optimalnog rješenja. Riješiti relaksaciju datog ILP-a. Zaokružiti dobijeno rješenje, tj. transformisati ga u najbliže cjelobrojno rješenje (gledajući po koordinatama).  Model implementirati:

 ($a$) uz pomoć Cplex-a; ($b$) uz pomoć PuLP modula.
\item % http://courses.ieor.berkeley.edu/ieor151/lecture_notes/ieor151_lec13.pdf
     Neka je instanca modela sljedećeg problema data sa usmjerenim težinskim grafom $G= (V_1 \cup V_2, E)$, gdje su $V_1$ i $V_2$ disjunktni skupovi, te prirodan broj $p\geq 1$. Težine grane između čvorova $i$ i $j$ je data sa $d_{i,j}\geq 0 $ i postoje samo grane između čvorova iz skupa $V_1$ u skup $V_2$. Svakom čvoru iz skupa $V_1$ pridružena je težina $h_{i}$. 
     Neka je MILP model dat  sa:
     \begin{align*}
     	 &\min \sum_{j \in V_2}\sum_{i \in V_1} h_i d_{i,j} Y_{i,j} \\
     	 &s.t. \\
     	 & \sum_{j \in V_2} Y_{i, j} = 1, \forall i \in V_1 \\
     	 & Y_{i,j} - X_j \leq 0, \forall i  \in V_1, \forall j \in V_2 \\     	 
     	 & \sum_{i \in V_2} X_j  = p \\
     	 & X_j \in \{0, 1\}, \forall j \in V_2 \\
     	 & Y_{i,j} \in \{0, 1\}, \forall i \in V_1, \forall j \in V_2.
     \end{align*}
      Model implementirati:
      
      ($a$) uz pomoć Cplex-a; ($b$) uz pomoć PuLP modula. 
   \item   %https://www.researchgate.net/publication/220316431_An_efficient_ILP_formulation_for_the_single_machine_scheduling_problem
   Neka je data instanca koja se sastoji od skupa $V$ poslova koji treba da budu urađeni na mašini. Svaki posao $j$ je dat intervalom $[r_j, d_j]$, $r_j < d_j$, gdje $r_j$ označava dopustivo vrijeme puštanja posla u rad (na mašini) dok $d_j$ označava vrijeme do kada se posao mora završiti.  Vrijeme procesiranja posla $j$ je dato sa $d_j$. 
   Potrebno je za sve poslove $j  \in V$ naći dopustiv redosljed izvršavanja (na mašini) tako što su nađena startna vremena izvršenja $s_j$ ($s_j \geq r_j \wedge s_j + p_j \leq d_j$). Ovaj problem je modelovan iz pomoć sljedećeg modela:
   \begin{align*}
          &\max D - R \\
          & s.t. \\
          & R \geq r_i, \forall i \in V \\
          & D \leq d_i, \forall i \in V \\
          & R \geq r_i + \sum_{ \{ j \in V \setminus \{t\} \mid r_j \geq r_i \} } p_j x_j^+, \forall i \in V \\
          & D \leq d_i -  \sum_{ \{ j \in V \setminus \{t\} \mid d_j \leq d_i \}} p_j x_j^-, \forall i \in V \\
          & x_j^+ + x_j^-  = 1, \forall i \in V \\
          &   x_j^+, x_j^- \in \{0, 1\}, \forall i \in V \\
          & D, R \in \mathbb{Z}. 
   \end{align*} 
          Model implementirati:
    
    ($a$) uz pomoć Cplex-a; ($b$) uz pomoć PuLP modula. 
    \item Neka je data instanca koja se sastoji  $n$ brojeva iz skupa $\mathbb{R}^p$, $p\in \mathbb{N}$. Sa $w_{i}=(w_{i1},\ldots, w_{ip})$ označimo $i$-ti element u skupu $S$. 
    Neka je $s_j = \sum_{i=1}^n w_{ij}, j=1,\ldots, p$ i neka je dat model:
    \begin{align*}
    	&\min t  \\
    	& s.t. \\
    	&-0.5 \cdot t + \sum_{i=1}^n w_{i,j}    x_i  \leq 0.5 \cdot s_j, j=1,\ldots,p \\
    	& 0.5 \cdot t + \sum_{i=1}^n w_{i,j} x_i  \geq 0.5 \cdot s_j, j=1,\ldots,p \\
    	& x_j \in \{0, 1\}, j = 1,\ldots,n.
    \end{align*}
             Model implementirati:
     
     ($a$) uz pomoć Cplex-a; ($b$) uz pomoć PuLP modula.
    \item %http://elib.mi.sanu.ac.rs/files/journals/publ/119/publn119p51-58.pdf
    Neka je data instanca koja se sastoji od grafa $G=(V,E)$ pri čemu je svakom od čvorova grafa data težina $f(v)  \in \{0, 1, 2\}, v \in V$. Neka je dat model:
    \begin{align*}
          &\min \sum_{i \in V} x_i + \sum_{i \in V} y_i \\
          &s.t. \\
          & x_i + \sum_{j \in N_i } y_j  \geq 1 \\
          & y_i \leq x_i, i \in V \\
          &x_i, y_i \in \{0, 1\}, i \in V.
    \end{align*}
     Model implementirati:

($a$) uz pomoć Cplex-a; ($b$) uz pomoć PuLP modula. 
\end{enumerate}
\begin{thebibliography}{widest entry}
	\bibitem[1]{cite_key1}  {https://towardsdatascience.com/the-big-picture-of-operations-research-8652d5153aad}
	\bibitem[2]{cite_key2} Hillier, Frederick S. Introduction to operations research. Tata McGraw-Hill Education, 2012.
	\bibitem[3]{cite_key3}  https://faculty.math.illinois.edu/~mlavrov/
	 \bibitem[4]{cite_key4}  Bisschop, Johannes. AIMMS optimization modeling. Lulu. com, 2006.
	  \bibitem[5]{cite_key5} Feillet, Dominique. ``A tutorial on column generation and branch-and-price for vehicle routing problems.'' 4or 8.4 (2010): 407-424.
	  \bibitem[6]{cite_key6}  Rebeka Čordaš. Linearno programiranje i primjene. Sveu\v cili\v ste J.J.Strossmayera u Osijeku, diplomski rad (2012)
	  \bibitem[7]{cite_key7}   Manual, CPLEX User’S. ``Ibm ilog cplex optimization studio.'' Version 12 (1987): 1987-2018.
	  \bibitem[8]{cite_key8} Mitchell, Stuart, Michael OSullivan, and Iain Dunning. "PuLP: a linear programming toolkit for python." The University of Auckland, Auckland, New Zealand (2011): 65.
	  \bibitem[9]{cite_key9}    Talbi, El-Ghazali. Metaheuristics: from design to implementation. Vol. 74. John Wiley \& Sons, 2009.
	  \bibitem[10]{cite_key10}     Vazirani, Vijay V. Approximation algorithms. Springer Science \& Business Media, 2013.
	   \bibitem[11]{cite_key11}     Blum, Christian, Maria J. Blesa, and Manuel Lopez-Ibanez. ``Beam search for the longest common subsequence problem.'' Computers \& Operations Research 36.12 (2009): 3178-3186.
	 % Odjel za matematiku
	   \bibitem[12]{cite_key12}   Raidl, Günther R., and Jakob Puchinger. ``Combining (integer) linear programming techniques and metaheuristics for combinatorial optimization.'' Hybrid metaheuristics (2008): 31-62.
	     \bibitem[13]{cite_key13}      Rahmaniani, Ragheb, et al. "The Benders decomposition algorithm: A literature review." European Journal of Operational Research 259.3 (2017): 801-817.
	     \bibitem[14]{cite_key14}    Raidl, Günther R. ``Decomposition based hybrid metaheuristics.'' European journal of operational research 244.1 (2015): 66-76.
	      \bibitem[15]{cite_key15}  Hansen, Pierre, Nenad Mladenović, and José A. Moreno Pérez. ``Variable neighbourhood search: methods and applications.'' 4OR 6.4 (2008): 319-360.
\end{thebibliography}

\end{document}

